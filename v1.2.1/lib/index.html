<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library ¬∑ Piccolo.jl</title><meta name="title" content="Library ¬∑ Piccolo.jl"/><meta property="og:title" content="Library ¬∑ Piccolo.jl"/><meta property="twitter:title" content="Library ¬∑ Piccolo.jl"/><meta name="description" content="Documentation for Piccolo.jl."/><meta property="og:description" content="Documentation for Piccolo.jl."/><meta property="twitter:description" content="Documentation for Piccolo.jl."/><meta property="og:url" content="https://docs.harmoniqs.co/Piccolo.jl/lib/"/><meta property="twitter:url" content="https://docs.harmoniqs.co/Piccolo.jl/lib/"/><link rel="canonical" href="https://docs.harmoniqs.co/Piccolo.jl/lib/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Piccolo.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Piccolo.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Piccolo.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../generated/getting-started/installation/">Installation</a></li><li><a class="tocitem" href="../generated/quickstart/">Quickstart</a></li></ul></li><li><span class="tocitem">Concepts</span><ul><li><a class="tocitem" href="../concepts/">Overview</a></li><li><a class="tocitem" href="../generated/concepts/trajectories/">Trajectories</a></li><li><a class="tocitem" href="../generated/concepts/pulses/">Pulses</a></li><li><a class="tocitem" href="../generated/concepts/objectives/">Objectives</a></li><li><a class="tocitem" href="../generated/concepts/constraints/">Constraints</a></li><li><a class="tocitem" href="../generated/concepts/operators/">Operators</a></li><li><a class="tocitem" href="../generated/concepts/isomorphisms/">Isomorphisms</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/">Overview</a></li><li><a class="tocitem" href="../generated/first_gate/">Your First Gate</a></li><li><a class="tocitem" href="../generated/multilevel_transmon/">Multilevel Transmon</a></li><li><a class="tocitem" href="../generated/state_transfer/">State Transfer</a></li><li><a class="tocitem" href="../generated/robust_control/">Robust Control</a></li></ul></li><li><span class="tocitem">Problem Templates</span><ul><li><a class="tocitem" href="../problem-templates/">Overview</a></li><li><a class="tocitem" href="../generated/problem-templates/smooth_pulse/">SmoothPulseProblem</a></li><li><a class="tocitem" href="../generated/problem-templates/spline_pulse/">SplinePulseProblem</a></li><li><a class="tocitem" href="../generated/problem-templates/minimum_time/">MinimumTimeProblem</a></li><li><a class="tocitem" href="../generated/problem-templates/sampling/">SamplingProblem</a></li><li><a class="tocitem" href="../generated/problem-templates/composition/">Composing Templates</a></li></ul></li><li><span class="tocitem">Quantum Systems</span><ul><li><a class="tocitem" href="../systems/">Overview</a></li><li><a class="tocitem" href="../generated/systems/transmons/">Transmon Qubits</a></li><li><a class="tocitem" href="../generated/systems/trapped_ions/">Trapped Ions</a></li><li><a class="tocitem" href="../generated/systems/rydberg_atoms/">Rydberg Atoms</a></li><li><a class="tocitem" href="../generated/systems/cat_qubits/">Cat Qubits</a></li><li><a class="tocitem" href="../generated/systems/silicon_spins/">Silicon Spins</a></li></ul></li><li><span class="tocitem">How-To Guides</span><ul><li><a class="tocitem" href="../guides/">Overview</a></li><li><a class="tocitem" href="../generated/guides/leakage_suppression/">Leakage Suppression</a></li><li><a class="tocitem" href="../generated/guides/global_variables/">Global Variables</a></li><li><a class="tocitem" href="../generated/guides/visualization/">Visualization</a></li><li><a class="tocitem" href="../generated/guides/custom_objectives/">Custom Objectives</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../reference/">Overview</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#lib-quantum-systems"><span>Quantum Systems</span></a></li><li><a class="tocitem" href="#lib-quantum-system-templates"><span>Quantum System Templates</span></a></li><li><a class="tocitem" href="#lib-quantum-system-utils"><span>Quantum System Utilities</span></a></li><li><a class="tocitem" href="#lib-gates"><span>Gates and Pauli Matrices</span></a></li><li><a class="tocitem" href="#lib-quantum-object-utils"><span>Quantum Object Utilities</span></a></li><li><a class="tocitem" href="#lib-trajectories"><span>Trajectories</span></a></li><li><a class="tocitem" href="#lib-pulses"><span>Pulses</span></a></li><li><a class="tocitem" href="#lib-rollouts"><span>Rollouts</span></a></li><li><a class="tocitem" href="#lib-embedded-operators"><span>Embedded Operators</span></a></li><li><a class="tocitem" href="#lib-lifted-operators"><span>Lifted Operators</span></a></li><li><a class="tocitem" href="#lib-direct-sums"><span>Direct Sums</span></a></li><li><a class="tocitem" href="#lib-isomorphisms"><span>Isomorphisms</span></a></li><li><a class="tocitem" href="#lib-quantum-control-problems"><span>Quantum Control Problems</span></a></li><li><a class="tocitem" href="#lib-problem-templates"><span>Problem Templates</span></a></li><li><a class="tocitem" href="#lib-objectives"><span>Objectives</span></a></li><li><a class="tocitem" href="#lib-constraints"><span>Constraints</span></a></li><li><a class="tocitem" href="#lib-options"><span>Options</span></a></li><li><a class="tocitem" href="#lib-visualizations"><span>Visualizations</span></a></li></ul></li></ul></li><li><span class="tocitem">Development</span><ul><li><a class="tocitem" href="../development/contributing/">Contributing</a></li><li><a class="tocitem" href="../development/release-notes/">Release Notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/harmoniqs/Piccolo.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/harmoniqs/Piccolo.jl/blob/main/docs/src/lib.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><p>Full docstring reference for all public types and functions in Piccolo.jl.</p><h2 id="lib-quantum-systems"><a class="docs-heading-anchor" href="#lib-quantum-systems">Quantum Systems</a><a id="lib-quantum-systems-1"></a><a class="docs-heading-anchor-permalink" href="#lib-quantum-systems" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.AbstractQuantumSystem"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.AbstractQuantumSystem"><code>Piccolo.Quantum.QuantumSystems.AbstractQuantumSystem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractQuantumSystem</code></pre><p>Abstract type for defining systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/_quantum_systems.jl#L77-L81">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem"><code>Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CompositeQuantumSystem &lt;: AbstractQuantumSystem</code></pre><p>A composite quantum system consisting of multiple <code>subsystems</code> with optional coupling terms.</p><p>Composite systems represent multiple quantum subsystems (e.g., multiple qubits or oscillators) that may be coupled together. Each subsystem&#39;s Hamiltonians are automatically lifted to the  full tensor product space, and subsystem drives are appended to any coupling drives.</p><p><strong>Fields</strong></p><ul><li><code>H::Function</code>: The total Hamiltonian function: (u, t) -&gt; H(u, t)</li><li><code>G::Function</code>: The isomorphic generator function: (u, t) -&gt; G(u, t)</li><li><code>H_drift::SparseMatrixCSC{ComplexF64, Int}</code>: The total drift Hamiltonian including subsystem drifts and couplings</li><li><code>H_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}</code>: All drive Hamiltonians (coupling drives + subsystem drives)</li><li><code>drive_bounds::Vector{Tuple{Float64, Float64}}</code>: Drive amplitude bounds for each control</li><li><code>n_drives::Int</code>: Total number of control drives</li><li><code>levels::Int</code>: Total dimension of the composite system (product of subsystem dimensions)</li><li><code>subsystem_levels::Vector{Int}</code>: Dimensions of each subsystem</li><li><code>subsystems::Vector{QuantumSystem}</code>: The individual quantum subsystems</li></ul><p>See also <a href="#lib-lifted-operators">Lifted Operators</a>, <a href="../generated/concepts/operators/#lift_operator"><code>lift_operator</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Two qubits with ZZ coupling
sys1 = QuantumSystem([PAULIS[:X]], [(-1.0, 1.0)])
sys2 = QuantumSystem([PAULIS[:Y]], [(-1.0, 1.0)])
H_coupling = 0.1 * kron(PAULIS[:Z], PAULIS[:Z])
csys = CompositeQuantumSystem(H_coupling, [sys1, sys2], Float64[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/composite_quantum_systems.jl#L5-L35">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Tuple{AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:AbstractMatrix{&lt;:Number}}, AbstractVector{&lt;:QuantumSystem}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Tuple{AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:AbstractMatrix{&lt;:Number}}, AbstractVector{&lt;:QuantumSystem}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}"><code>Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CompositeQuantumSystem(
    H_drift::AbstractMatrix,
    H_drives::AbstractVector{&lt;:AbstractMatrix},
    subsystems::AbstractVector{&lt;:QuantumSystem},
    drive_bounds::DriveBounds
)</code></pre><p>Construct a CompositeQuantumSystem with coupling drift and drive terms.</p><p><strong>Arguments</strong></p><ul><li><code>H_drift::AbstractMatrix</code>: Coupling drift Hamiltonian (in full tensor product space)</li><li><code>H_drives::AbstractVector{&lt;:AbstractMatrix}</code>: Coupling drive Hamiltonians</li><li><code>subsystems::AbstractVector{&lt;:QuantumSystem}</code>: Vector of subsystems to compose</li><li><code>drive_bounds::DriveBounds</code>: Drive bounds for the coupling drives (subsystem bounds are inherited). Can be:<ul><li>Tuples <code>(lower, upper)</code> for asymmetric bounds</li><li>Scalars which are interpreted as symmetric bounds <code>(-value, value)</code></li></ul></li></ul><p>The total drift includes both the coupling drift and all subsystem drifts (automatically lifted). The total drives include coupling drives followed by all subsystem drives (automatically lifted).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">sys1 = QuantumSystem(PAULIS[:Z], [PAULIS[:X]], [1.0])
sys2 = QuantumSystem([PAULIS[:Y]], [1.0])
g12 = 0.1 * kron(PAULIS[:X], PAULIS[:X])  # coupling drift
csys = CompositeQuantumSystem(g12, Matrix{ComplexF64}[], [sys1, sys2], Float64[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/composite_quantum_systems.jl#L48-L76">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Tuple{AbstractVector{&lt;:QuantumSystem}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Tuple{AbstractVector{&lt;:QuantumSystem}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}"><code>Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CompositeQuantumSystem(
    subsystems::AbstractVector{&lt;:QuantumSystem},
    drive_bounds::DriveBounds
)</code></pre><p>Convenience constructor for a composite system with no coupling terms (neither drift nor drives).</p><p>Use this when you have independent subsystems that you want to represent in a single composite space, but without any direct coupling between them.</p><p><strong>Arguments</strong></p><ul><li><code>subsystems::AbstractVector{&lt;:QuantumSystem}</code>: Vector of subsystems to compose</li><li><code>drive_bounds::DriveBounds</code>: Drive bounds for the coupling drives (typically empty). Can be:<ul><li>Tuples <code>(lower, upper)</code> for asymmetric bounds</li><li>Scalars which are interpreted as symmetric bounds <code>(-value, value)</code></li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sys1 = QuantumSystem([PAULIS[:X]], [1.0])
sys2 = QuantumSystem([PAULIS[:Y]], [1.0])
csys = CompositeQuantumSystem([sys1, sys2], Float64[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/composite_quantum_systems.jl#L197-L220">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{&lt;:QuantumSystem}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}} where T&lt;:Number"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{&lt;:QuantumSystem}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}} where T&lt;:Number"><code>Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CompositeQuantumSystem(
    H_drift::AbstractMatrix,
    subsystems::AbstractVector{&lt;:QuantumSystem},
    drive_bounds::DriveBounds
)</code></pre><p>Convenience constructor for a composite system with coupling drift but no coupling drives.</p><p><strong>Arguments</strong></p><ul><li><code>H_drift::AbstractMatrix</code>: Coupling drift Hamiltonian</li><li><code>subsystems::AbstractVector{&lt;:QuantumSystem}</code>: Vector of subsystems to compose</li><li><code>drive_bounds::DriveBounds</code>: Drive bounds for the coupling drives (typically empty). Can be:<ul><li>Tuples <code>(lower, upper)</code> for asymmetric bounds</li><li>Scalars which are interpreted as symmetric bounds <code>(-value, value)</code></li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sys1 = QuantumSystem([PAULIS[:X]], [1.0])
sys2 = QuantumSystem([PAULIS[:Y]], [1.0])
H_coupling = 0.1 * kron(PAULIS[:Z], PAULIS[:Z])  # coupling drift
csys = CompositeQuantumSystem(H_coupling, [sys1, sys2], Float64[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/composite_quantum_systems.jl#L165-L188">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Union{Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, AbstractVector{&lt;:QuantumSystem}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}} where T&lt;:Number"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Union{Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, AbstractVector{&lt;:QuantumSystem}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}} where T&lt;:Number"><code>Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CompositeQuantumSystem(
    H_drives::AbstractVector{&lt;:AbstractMatrix},
    subsystems::AbstractVector{&lt;:QuantumSystem},
    drive_bounds::DriveBounds
)</code></pre><p>Convenience constructor for a composite system with coupling drives but no coupling drift.</p><p><strong>Arguments</strong></p><ul><li><code>H_drives::AbstractVector{&lt;:AbstractMatrix}</code>: Coupling drive Hamiltonians</li><li><code>subsystems::AbstractVector{&lt;:QuantumSystem}</code>: Vector of subsystems to compose</li><li><code>drive_bounds::DriveBounds</code>: Drive bounds for the coupling drives. Can be:<ul><li>Tuples <code>(lower, upper)</code> for asymmetric bounds</li><li>Scalars which are interpreted as symmetric bounds <code>(-value, value)</code></li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sys1 = QuantumSystem([PAULIS[:X]], [1.0])
sys2 = QuantumSystem([PAULIS[:Y]], [1.0])
g12 = 0.1 * kron(PAULIS[:X], PAULIS[:X])  # coupling drive
csys = CompositeQuantumSystem([g12], [sys1, sys2], [1.0])  # symmetric bound</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/composite_quantum_systems.jl#L127-L150">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.DriveBounds"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.DriveBounds"><code>Piccolo.Quantum.QuantumSystems.DriveBounds</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DriveBounds</code></pre><p>Type alias for drive amplitude bounds input. Bounds can be specified as:</p><ul><li>A tuple <code>(lower, upper)</code> for asymmetric bounds</li><li>A scalar value which is interpreted as symmetric bounds <code>(-value, value)</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">drive_bounds = [(-1.0, 1.0), 0.5, (-0.3, 0.7)]
# Interpreted as: [(-1.0, 1.0), (-0.5, 0.5), (-0.3, 0.7)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/_quantum_systems.jl#L27-L39">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.OpenQuantumSystem"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem"><code>Piccolo.Quantum.QuantumSystems.OpenQuantumSystem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OpenQuantumSystem &lt;: AbstractQuantumSystem</code></pre><p>A struct for storing open quantum dynamics.</p><p><strong>Fields</strong></p><ul><li><code>H::Function</code>: The Hamiltonian function: (u, t) -&gt; H(u, t)</li><li><code>ùí¢::Function</code>: The Lindbladian generator function: u -&gt; ùí¢(u)</li><li><code>H_drift::SparseMatrixCSC{ComplexF64, Int}</code>: The drift Hamiltonian</li><li><code>H_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}</code>: The drive Hamiltonians</li><li><code>drive_bounds::Vector{Tuple{Float64, Float64}}</code>: Drive amplitude bounds</li><li><code>n_drives::Int</code>: The number of control drives</li><li><code>levels::Int</code>: The number of levels in the system</li><li><code>dissipation_operators::Vector{SparseMatrixCSC{ComplexF64, Int}}</code>: The dissipation operators</li><li><code>time_dependent::Bool</code>: Whether the Hamiltonian has explicit time dependence</li><li><code>global_params::NamedTuple</code>: Global parameters stored with the system (e.g., physical constants)</li></ul><p>See also <a href="#Piccolo.Quantum.QuantumSystems.QuantumSystem"><code>QuantumSystem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/open_quantum_systems.jl#L5-L23">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Tuple{AbstractMatrix{&lt;:Number}, Vector{&lt;:AbstractMatrix{&lt;:Number}}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Tuple{AbstractMatrix{&lt;:Number}, Vector{&lt;:AbstractMatrix{&lt;:Number}}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}"><code>Piccolo.Quantum.QuantumSystems.OpenQuantumSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">OpenQuantumSystem(
    H_drift::AbstractMatrix{&lt;:Number},
    H_drives::AbstractVector{&lt;:AbstractMatrix{&lt;:Number}},
    drive_bounds::DriveBounds;
    dissipation_operators=Matrix{ComplexF64}[],
    time_dependent::Bool=false,
    global_params::NamedTuple=NamedTuple()
)
OpenQuantumSystem(
    H_drift::AbstractMatrix{&lt;:Number};
    dissipation_operators=Matrix{ComplexF64}[],
    time_dependent::Bool=false,
    global_params::NamedTuple=NamedTuple()
)
OpenQuantumSystem(
    H_drives::Vector{&lt;:AbstractMatrix{&lt;:Number}},
    drive_bounds::DriveBounds;
    dissipation_operators=Matrix{ComplexF64}[],
    time_dependent::Bool=false,
    global_params::NamedTuple=NamedTuple()
)
OpenQuantumSystem(
    H::Function,
    drive_bounds::DriveBounds;
    dissipation_operators=Matrix{ComplexF64}[],
    time_dependent::Bool=false,
    global_params::NamedTuple=NamedTuple()
)
OpenQuantumSystem(
    system::QuantumSystem;
    dissipation_operators=Matrix{ComplexF64}[]
)</code></pre><p>Constructs an OpenQuantumSystem object from the drift and drive Hamiltonian terms and dissipation operators.</p><p><strong>Drive Bounds</strong></p><p>The <code>drive_bounds</code> parameter can be:</p><ul><li>Tuples <code>(lower, upper)</code> for asymmetric bounds</li><li>Scalars which are interpreted as symmetric bounds <code>(-value, value)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/open_quantum_systems.jl#L37-L78">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Tuple{QuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Tuple{QuantumSystem}"><code>Piccolo.Quantum.QuantumSystems.OpenQuantumSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">OpenQuantumSystem(system::QuantumSystem; dissipation_operators=[])</code></pre><p>Construct an OpenQuantumSystem from a QuantumSystem by adding dissipation operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/open_quantum_systems.jl#L214-L218">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ&lt;:Number"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ&lt;:Number"><code>Piccolo.Quantum.QuantumSystems.OpenQuantumSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">OpenQuantumSystem(H_drift; dissipation_operators=[], time_dependent=false)</code></pre><p>Construct an OpenQuantumSystem with only drift (no drives).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/open_quantum_systems.jl#L151-L155">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{F}, Tuple{F, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}} where {F&lt;:Function, ‚ÑÇ&lt;:Number}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{F}, Tuple{F, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}} where {F&lt;:Function, ‚ÑÇ&lt;:Number}"><code>Piccolo.Quantum.QuantumSystems.OpenQuantumSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">OpenQuantumSystem(H::Function, drive_bounds; dissipation_operators=[], time_dependent=false)</code></pre><p>Construct an OpenQuantumSystem from a Hamiltonian function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/open_quantum_systems.jl#L172-L176">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{Vector{&lt;:AbstractMatrix{‚ÑÇ}}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}} where ‚ÑÇ&lt;:Number"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{Vector{&lt;:AbstractMatrix{‚ÑÇ}}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}} where ‚ÑÇ&lt;:Number"><code>Piccolo.Quantum.QuantumSystems.OpenQuantumSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">OpenQuantumSystem(H_drives, drive_bounds; dissipation_operators=[], time_dependent=false)</code></pre><p>Construct an OpenQuantumSystem with no drift.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/open_quantum_systems.jl#L128-L132">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.QuantumSystem"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.QuantumSystem"><code>Piccolo.Quantum.QuantumSystems.QuantumSystem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">QuantumSystem &lt;: AbstractQuantumSystem</code></pre><p>A struct for storing quantum dynamics.</p><p><strong>Fields</strong></p><ul><li><code>H::Function</code>: The Hamiltonian function: (u, t) -&gt; H(u, t), where u is the control vector and t is time</li><li><code>G::Function</code>: The isomorphic generator function: (u, t) -&gt; G(u, t), including the Hamiltonian mapped to superoperator space</li><li><code>H_drift::SparseMatrixCSC{ComplexF64, Int}</code>: The drift Hamiltonian (time-independent component)</li><li><code>H_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}</code>: The drive Hamiltonians (control-dependent components)</li><li><code>drive_bounds::Vector{Tuple{Float64, Float64}}</code>: Drive amplitude bounds for each control (lower, upper)</li><li><code>n_drives::Int</code>: The number of control drives in the system</li><li><code>levels::Int</code>: The number of levels (dimension) in the system</li><li><code>time_dependent::Bool</code>: Whether the Hamiltonian has explicit time dependence beyond control modulation</li><li><code>global_params::NamedTuple</code>: Global parameters that the Hamiltonian may depend on (e.g., (Œ¥=0.5, Œ©=1.0))</li></ul><p>See also <a href="#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem"><code>OpenQuantumSystem</code></a>, <a href="#Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem"><code>VariationalQuantumSystem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/quantum_systems.jl#L15-L32">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.QuantumSystem-Tuple{AbstractMatrix{&lt;:Number}, Vector{&lt;:AbstractMatrix{&lt;:Number}}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.QuantumSystem-Tuple{AbstractMatrix{&lt;:Number}, Vector{&lt;:AbstractMatrix{&lt;:Number}}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}"><code>Piccolo.Quantum.QuantumSystems.QuantumSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">QuantumSystem(
    H_drift::AbstractMatrix{&lt;:Number},
    H_drives::Vector{&lt;:AbstractMatrix{&lt;:Number}},
    drive_bounds::Vector{&lt;:Union{Tuple{Float64, Float64}, Float64}};
    time_dependent::Bool=false
)</code></pre><p>Construct a QuantumSystem from drift and drive Hamiltonian terms.</p><p><strong>Arguments</strong></p><ul><li><code>H_drift::AbstractMatrix</code>: The drift (time-independent) Hamiltonian</li><li><code>H_drives::Vector{&lt;:AbstractMatrix}</code>: Vector of drive Hamiltonians, one for each control</li><li><code>drive_bounds::DriveBounds</code>: Drive amplitude bounds for each control. Can be:<ul><li>Tuples <code>(lower, upper)</code> for asymmetric bounds</li><li>Scalars which are interpreted as symmetric bounds <code>(-value, value)</code></li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>time_dependent::Bool=false</code>: Set to <code>true</code> if using time-dependent modulation (typically handled at a higher level)</li><li><code>global_params::NamedTuple=NamedTuple()</code>: Global parameters stored with the system. Note: for matrix-based systems, matrices are fixed at construction, so global<em>params are mainly for storage/bookkeeping and later updates via `update</em>global_params!`</li></ul><p>The resulting Hamiltonian is: H(u, t) = H<em>drift + Œ£·µ¢ u·µ¢ * H</em>drives[i]</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">sys = QuantumSystem(
    PAULIS[:Z],                    # drift
    [PAULIS[:X], PAULIS[:Y]],      # drives
    [1.0, 1.0]                     # symmetric bounds: [(-1.0, 1.0), (-1.0, 1.0)]
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/quantum_systems.jl#L115-L147">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.QuantumSystem-Tuple{Function, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.QuantumSystem-Tuple{Function, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}"><code>Piccolo.Quantum.QuantumSystems.QuantumSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">QuantumSystem(H::Function, drive_bounds::Vector; time_dependent::Bool=false)</code></pre><p>Construct a QuantumSystem from a Hamiltonian function.</p><p><strong>Arguments</strong></p><ul><li><code>H::Function</code>: Hamiltonian function with signature (u, t) -&gt; H(u, t) where:<ul><li><code>u</code> is a vector containing <code>[controls..., globals...]</code> (if system has global parameters)</li><li>For matrix-based systems, only the first n_drives elements are used for controls</li><li>For function-based systems, handle globals via closure or by accessing u beyond control indices</li><li><code>t</code> is time</li></ul></li><li><code>drive_bounds::DriveBounds</code>: Drive amplitude bounds for each control. Can be:<ul><li>Tuples <code>(lower, upper)</code> for asymmetric bounds</li><li>Scalars which are interpreted as symmetric bounds <code>(-value, value)</code></li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>time_dependent::Bool=false</code>: Set to <code>true</code> if the Hamiltonian has explicit time dependence (e.g., cos(œât) modulation)</li><li><code>global_params::NamedTuple=NamedTuple()</code>: Global parameters stored with the system for bookkeeping</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Define a time-dependent Hamiltonian
H = (u, t) -&gt; PAULIS[:Z] + u[1] * cos(œâ * t) * PAULIS[:X]
sys = QuantumSystem(H, [(-1.0, 1.0)]; time_dependent=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/quantum_systems.jl#L45-L70">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.QuantumSystem-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ&lt;:Number"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.QuantumSystem-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ&lt;:Number"><code>Piccolo.Quantum.QuantumSystems.QuantumSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">QuantumSystem(H_drift::AbstractMatrix; time_dependent::Bool=false)</code></pre><p>Convenience constructor for a system with only a drift Hamiltonian (no drives).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">sys = QuantumSystem(PAULIS[:Z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/quantum_systems.jl#L232-L241">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.QuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{Vector{&lt;:AbstractMatrix{‚ÑÇ}}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}} where ‚ÑÇ&lt;:Number"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.QuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{Vector{&lt;:AbstractMatrix{‚ÑÇ}}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}} where ‚ÑÇ&lt;:Number"><code>Piccolo.Quantum.QuantumSystems.QuantumSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">QuantumSystem(H_drives::Vector{&lt;:AbstractMatrix}, drive_bounds::Vector; time_dependent::Bool=false)</code></pre><p>Convenience constructor for a system with no drift Hamiltonian (H_drift = 0).</p><p><strong>Arguments</strong></p><ul><li><code>H_drives::Vector{&lt;:AbstractMatrix}</code>: Vector of drive Hamiltonians</li><li><code>drive_bounds::DriveBounds</code>: Drive amplitude bounds for each control. Can be:<ul><li>Tuples <code>(lower, upper)</code> for asymmetric bounds</li><li>Scalars which are interpreted as symmetric bounds <code>(-value, value)</code></li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Using scalars for symmetric bounds
sys = QuantumSystem([PAULIS[:X], PAULIS[:Y]], [1.0, 1.0])
# Equivalent to: drive_bounds = [(-1.0, 1.0), (-1.0, 1.0)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/quantum_systems.jl#L198-L215">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem"><code>Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VariationalQuantumSystem &lt;: AbstractQuantumSystem</code></pre><p>A struct for storing variational quantum dynamics, used for sensitivity and robustness analysis.</p><p>Variational systems allow exploring how the dynamics change under perturbations to the Hamiltonian. The variational operators represent directions of uncertainty or perturbation in the system.</p><p><strong>Fields</strong></p><ul><li><code>H::Function</code>: The Hamiltonian function: (u, t) -&gt; H(u, t)</li><li><code>G::Function</code>: The isomorphic generator function: (u, t) -&gt; G(u, t)</li><li><code>G_vars::AbstractVector{&lt;:Function}</code>: Variational generator functions, one for each perturbation direction</li><li><code>drive_bounds::Vector{Tuple{Float64, Float64}}</code>: Drive amplitude bounds</li><li><code>n_drives::Int</code>: The number of control drives in the system</li><li><code>levels::Int</code>: The number of levels (dimension) in the system</li></ul><p>See also <a href="#Piccolo.Quantum.QuantumSystems.QuantumSystem"><code>QuantumSystem</code></a>, <a href="#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem"><code>OpenQuantumSystem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/variational_quantum_systems.jl#L7-L24">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem-Tuple{AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:AbstractMatrix{&lt;:Number}}, AbstractVector{&lt;:AbstractMatrix{&lt;:Number}}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem-Tuple{AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:AbstractMatrix{&lt;:Number}}, AbstractVector{&lt;:AbstractMatrix{&lt;:Number}}, Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}"><code>Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VariationalQuantumSystem(
    H_drift::AbstractMatrix,
    H_drives::AbstractVector{&lt;:AbstractMatrix},
    H_vars::AbstractVector{&lt;:AbstractMatrix},
    drive_bounds::DriveBounds
)</code></pre><p>Construct a VariationalQuantumSystem from drift, drive, and variational Hamiltonian terms.</p><p><strong>Arguments</strong></p><ul><li><code>H_drift::AbstractMatrix</code>: The drift (time-independent) Hamiltonian</li><li><code>H_drives::AbstractVector{&lt;:AbstractMatrix}</code>: Vector of drive Hamiltonians for control</li><li><code>H_vars::AbstractVector{&lt;:AbstractMatrix}</code>: Vector of variational Hamiltonians representing perturbation directions</li><li><code>drive_bounds::DriveBounds</code>: Drive amplitude bounds for each control. Can be:<ul><li>Tuples <code>(lower, upper)</code> for asymmetric bounds</li><li>Scalars which are interpreted as symmetric bounds <code>(-value, value)</code></li></ul></li></ul><p>The variational operators allow sensitivity analysis by exploring how dynamics change under perturbations: H<em>perturbed = H + Œ£·µ¢ Œµ·µ¢ * H</em>vars[i]</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">varsys = VariationalQuantumSystem(
    PAULIS[:Z],                    # drift
    [PAULIS[:X], PAULIS[:Y]],      # drives
    [PAULIS[:X]],                  # variational perturbations
    [1.0, 1.0]                     # symmetric bounds: [(-1.0, 1.0), (-1.0, 1.0)]
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/variational_quantum_systems.jl#L38-L68">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems._float_params-Union{Tuple{NamedTuple{K}}, Tuple{K}} where K"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems._float_params-Union{Tuple{NamedTuple{K}}, Tuple{K}} where K"><code>Piccolo.Quantum.QuantumSystems._float_params</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_float_params(nt::NamedTuple)</code></pre><p>Convert all values in a NamedTuple to their floating-point equivalents. Ensures type-stable ODE solutions when global parameters are updated during optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/_quantum_systems.jl#L120-L125">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.compact_lindbladian_generators-Tuple{OpenQuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.compact_lindbladian_generators-Tuple{OpenQuantumSystem}"><code>Piccolo.Quantum.QuantumSystems.compact_lindbladian_generators</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compact_lindbladian_generators(sys::OpenQuantumSystem)</code></pre><p>Compute the compact Lindbladian generators for use with the compact density isomorphism. Returns <code>(ùí¢c_drift, ùí¢c_drives)</code> where:</p><ul><li><code>ùí¢c_drift = P * (ùí¢_drift + ùíü) * L</code> ‚Äî compact drift + dissipation generator (n¬≤ √ó n¬≤)</li><li><code>ùí¢c_drives[i] = P * ùí¢_drives[i] * L</code> ‚Äî compact drive generators (each n¬≤ √ó n¬≤)</li></ul><p>These satisfy <code>·∫ã = (ùí¢c_drift + Œ£ u·µ¢ ùí¢c_drives[i]) * x</code> where <code>x</code> is the compact iso vector from <code>density_to_compact_iso</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/open_quantum_systems.jl#L237-L248">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.get_drift-Tuple{AbstractQuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.get_drift-Tuple{AbstractQuantumSystem}"><code>Piccolo.Quantum.QuantumSystems.get_drift</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_drift(sys::AbstractQuantumSystem)</code></pre><p>Returns the drift Hamiltonian of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/_quantum_systems.jl#L88-L92">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.get_drives-Tuple{AbstractQuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.get_drives-Tuple{AbstractQuantumSystem}"><code>Piccolo.Quantum.QuantumSystems.get_drives</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_drives(sys::AbstractQuantumSystem)</code></pre><p>Returns the drive Hamiltonians of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/_quantum_systems.jl#L95-L99">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.is_hermitian-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.is_hermitian-Tuple{AbstractMatrix}"><code>Piccolo.Quantum.QuantumSystems.is_hermitian</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_hermitian(H::AbstractMatrix; tol=1e-10)</code></pre><p>Check if a matrix is Hermitian within a tolerance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/quantum_systems.jl#L6-L10">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystems.normalize_drive_bounds-Tuple{Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystems.normalize_drive_bounds-Tuple{Vector{&lt;:Union{Float64, Tuple{Float64, Float64}}}}"><code>Piccolo.Quantum.QuantumSystems.normalize_drive_bounds</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">normalize_drive_bounds(bounds::DriveBounds)</code></pre><p>Convert drive bounds to a consistent tuple format. Scalar values are converted to  symmetric bounds around zero: <code>b</code> becomes <code>(-b, b)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>bounds::DriveBounds</code>: Input bounds, can be tuples or scalars</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Tuple{Float64, Float64}}</code>: Normalized bounds as tuples</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># All scalars (symmetric bounds)
normalize_drive_bounds([1.0, 1.5, 0.5])
# Returns: [(-1.0, 1.0), (-1.5, 1.5), (-0.5, 0.5)]

# All tuples (asymmetric bounds)
normalize_drive_bounds([(-2.0, 3.0), (-1.0, 1.0)])
# Returns: [(-2.0, 3.0), (-1.0, 1.0)]

# Mixed types (requires explicit type annotation)
normalize_drive_bounds(Union{Float64, Tuple{Float64,Float64}}[1.0, (-2.0, 3.0)])
# Returns: [(-1.0, 1.0), (-2.0, 3.0)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/systems/_quantum_systems.jl#L42-L68">source</a></section></details></article><h2 id="lib-quantum-system-templates"><a class="docs-heading-anchor" href="#lib-quantum-system-templates">Quantum System Templates</a><a id="lib-quantum-system-templates-1"></a><a class="docs-heading-anchor-permalink" href="#lib-quantum-system-templates" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemTemplates.CatSystem-Tuple{}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemTemplates.CatSystem-Tuple{}"><code>Piccolo.Quantum.QuantumSystemTemplates.CatSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CatSystem(;
    g2=0.36, œá_aa=-7e-3, œá_bb=-32, œá_ab=0.79,
    Œ∫a=53e-3, Œ∫b=13,
    cat_levels=13, buffer_levels=3,
    prefactor=1, drive_bounds=[1.0, 1.0],
)::OpenQuantumSystem</code></pre><p>Construct an <code>OpenQuantumSystem</code> for a two-mode cat qubit (cat ‚äó buffer).</p><p><strong>Hamiltonian</strong></p><p>The drift Hamiltonian includes Kerr, cross-Kerr, and two-photon exchange terms:</p><p class="math-container">\[H = -\frac{\chi_{aa}}{2} a^{\dagger 2} a^2
    -\frac{\chi_{bb}}{2} b^{\dagger 2} b^2
    -\chi_{ab}\, a^\dagger a\, b^\dagger b
    + g_2\, a^{\dagger 2} b
    + g_2^*\, a^2 b^\dagger\]</p><p>The two drives are the buffer displacement <span>$b + b^\dagger$</span> and a Kerr correction <span>$a^\dagger a$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>g2</code>: Two-photon exchange coupling (MHz ¬∑ 2œÄ)</li><li><code>œá_aa</code>: Cat self-Kerr (MHz ¬∑ 2œÄ)</li><li><code>œá_bb</code>: Buffer self-Kerr (MHz ¬∑ 2œÄ)</li><li><code>œá_ab</code>: Cross-Kerr between cat and buffer (MHz ¬∑ 2œÄ)</li><li><code>Œ∫a</code>: Cat decay rate (MHz ¬∑ 2œÄ)</li><li><code>Œ∫b</code>: Buffer decay rate (MHz ¬∑ 2œÄ)</li><li><code>cat_levels</code>: Truncation of cat mode Fock space</li><li><code>buffer_levels</code>: Truncation of buffer mode Fock space</li><li><code>prefactor</code>: Global scaling applied to all couplings and rates</li><li><code>drive_bounds</code>: Bounds on the two drive amplitudes</li></ul><p>All parameters are scaled by <span>$2œÄ$</span> (Hamiltonian) or <span>$\\sqrt{2œÄ}$</span> (dissipators) internally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/templates/cats/cat_system.jl#L14-L53">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemTemplates.IonChainSystem-Tuple{}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemTemplates.IonChainSystem-Tuple{}"><code>Piccolo.Quantum.QuantumSystemTemplates.IonChainSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">IonChainSystem(;
    N_ions::Int=2,
    ion_levels::Int=2,
    N_modes::Int=1,
    mode_levels::Int=10,
    œâq::Union{Float64, Vector{Float64}}=1.0,
    œâm::Union{Float64, Vector{Float64}}=0.1,
    Œ∑::Union{Float64, Matrix{Float64}}=0.1,
    lab_frame::Bool=false,
    frame_œâ::Float64=lab_frame ? 0.0 : (œâq isa Vector ? œâq[1] : œâq),
    multiply_by_2œÄ::Bool=true,
    drive_bounds::Vector{&lt;:Union{Tuple{Float64, Float64}, Float64}}=fill(1.0, 2*N_ions),
) -&gt; QuantumSystem</code></pre><p>Returns a <code>QuantumSystem</code> object for a chain of trapped ions coupled via motional modes.</p><p>The system consists of <code>N_ions</code> ions, each with <code>ion_levels</code> internal states, coupled to  <code>N_modes</code> shared motional modes with <code>mode_levels</code> Fock states each.</p><p><strong>Hamiltonian</strong></p><p>In the lab frame:</p><p class="math-container">\[H = \sum_{i=1}^{N_{\text{ions}}} \omega_{q,i} \sigma_i^+ \sigma_i^- 
    + \sum_{m=1}^{N_{\text{modes}}} \omega_{m} a_m^\dagger a_m
    + \sum_{i,m} \eta_{i,m} (\sigma_i^+ + \sigma_i^-)(a_m + a_m^\dagger)
    + \sum_i \Omega_{x,i}(t) \sigma_i^x + \sum_i \Omega_{y,i}(t) \sigma_i^y\]</p><p>In the rotating frame at frequency <code>frame_œâ</code>:</p><p class="math-container">\[H = \sum_{i=1}^{N_{\text{ions}}} (\omega_{q,i} - \omega_{\text{frame}}) \sigma_i^+ \sigma_i^- 
    + \sum_{m=1}^{N_{\text{modes}}} \omega_{m} a_m^\dagger a_m
    + \sum_{i,m} \eta_{i,m} (\sigma_i^+ + \sigma_i^-)(a_m + a_m^\dagger)
    + \sum_i \Omega_{x,i}(t) \sigma_i^x + \sum_i \Omega_{y,i}(t) \sigma_i^y\]</p><p>where:</p><ul><li><span>$\sigma_i^+, \sigma_i^-$</span> are raising/lowering operators for ion <code>i</code></li><li><span>$\sigma_i^x, \sigma_i^y$</span> are Pauli operators for ion <code>i</code></li><li><span>$a_m, a_m^\dagger$</span> are annihilation/creation operators for mode <code>m</code></li><li><span>$\omega_{q,i}$</span> is the transition frequency of ion <code>i</code></li><li><span>$\omega_m$</span> is the frequency of motional mode <code>m</code></li><li><span>$\eta_{i,m}$</span> is the Lamb-Dicke parameter coupling ion <code>i</code> to mode <code>m</code></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>N_ions</code>: Number of ions in the chain</li><li><code>ion_levels</code>: Number of internal levels per ion (typically 2 for qubit)</li><li><code>N_modes</code>: Number of motional modes to include</li><li><code>mode_levels</code>: Number of Fock states per motional mode</li><li><code>œâq</code>: Ion transition frequency (or frequencies). Scalar or vector of length <code>N_ions</code>. In GHz.</li><li><code>œâm</code>: Motional mode frequency (or frequencies). Scalar or vector of length <code>N_modes</code>. In GHz.</li><li><code>Œ∑</code>: Lamb-Dicke parameter(s). Scalar (uniform coupling), or <code>N_ions √ó N_modes</code> matrix.</li><li><code>lab_frame</code>: If true, use lab frame Hamiltonian. If false, use rotating frame.</li><li><code>frame_œâ</code>: Rotating frame frequency in GHz. Defaults to first ion frequency.</li><li><code>multiply_by_2œÄ</code>: Whether to multiply Hamiltonian by 2œÄ (default true, since frequencies are in GHz).</li><li><code>drive_bounds</code>: Control bounds. Vector of length <code>2*N_ions</code> for [Œ©x‚ÇÅ, Œ©y‚ÇÅ, Œ©x‚ÇÇ, Œ©y‚ÇÇ, ...].</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Two ions, one motional mode, M√∏lmer-S√∏rensen setup
sys = IonChainSystem(
    N_ions=2,
    N_modes=1,
    œâq=1.0,      # 1 GHz qubit frequency
    œâm=0.1,      # 100 MHz mode frequency  
    Œ∑=0.1,       # Lamb-Dicke parameter
    mode_levels=5,
)</code></pre><p><strong>References</strong></p><ul><li>S√∏rensen, A. &amp; M√∏lmer, K. &quot;Quantum computation with ions in thermal motion.&quot;  Phys. Rev. Lett. 82, 1971 (1999).</li><li>S√∏rensen, A. &amp; M√∏lmer, K. &quot;Entanglement and quantum computation with ions in thermal motion.&quot; Phys. Rev. A 62, 022311 (2000).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/templates/ions/ion_chain.jl#L4-L81">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemTemplates.MolmerSorensenCoupling-Tuple{Int64, Int64, Int64, Int64, Union{Float64, Matrix{Float64}}, Union{Float64, Vector{Float64}}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemTemplates.MolmerSorensenCoupling-Tuple{Int64, Int64, Int64, Int64, Union{Float64, Matrix{Float64}}, Union{Float64, Vector{Float64}}}"><code>Piccolo.Quantum.QuantumSystemTemplates.MolmerSorensenCoupling</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MolmerSorensenCoupling(
    N_ions::Int,
    N_modes::Int,
    ion_levels::Int,
    mode_levels::Int,
    Œ∑::Union{Float64, Matrix{Float64}},
    œâm::Union{Float64, Vector{Float64}},
) -&gt; Matrix{ComplexF64}</code></pre><p>Returns the M√∏lmer-S√∏rensen coupling term for an ion chain, which mediates  effective ion-ion interactions via the motional modes.</p><p>In the Lamb-Dicke regime with appropriate drive detunings, the effective Hamiltonian is:</p><p class="math-container">\[H_{\text{MS}} = \sum_{i&lt;j} J_{ij} \sigma_i^x \sigma_j^x\]</p><p>where the coupling strength is:</p><p class="math-container">\[J_{ij} = \sum_m \frac{\eta_{i,m} \eta_{j,m} \Omega_i \Omega_j}{4 \Delta_m}\]</p><p>with <span>$\Delta_m$</span> being the detuning from mode <span>$m$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>N_ions</code>: Number of ions</li><li><code>N_modes</code>: Number of motional modes</li><li><code>ion_levels</code>: Internal levels per ion</li><li><code>mode_levels</code>: Fock states per mode</li><li><code>Œ∑</code>: Lamb-Dicke parameters (scalar or N<em>ions √ó N</em>modes matrix)</li><li><code>œâm</code>: Mode frequencies (scalar or vector)</li></ul><p><strong>Returns</strong></p><p>Matrix representing the œÉÀ£·µ¢ œÉÀ£‚±º interaction for use in building MS gates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/templates/ions/ion_chain.jl#L177-L212">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemTemplates.MultiTransmonSystem-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemTemplates.MultiTransmonSystem-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}}"><code>Piccolo.Quantum.QuantumSystemTemplates.MultiTransmonSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MultiTransmonSystem(
    œâs::AbstractVector{Float64},
    Œ¥s::AbstractVector{Float64},
    gs::AbstractMatrix{Float64};
    drive_bounds::Union{Float64, Vector{&lt;:Union{Tuple{Float64, Float64}, Float64}}}=1.0,
    levels_per_transmon::Int = 3,
    subsystem_levels::AbstractVector{Int} = fill(levels_per_transmon, length(œâs)),
    lab_frame=false,
    subsystems::AbstractVector{Int} = 1:length(œâs),
    subsystem_drive_indices::AbstractVector{Int} = 1:length(œâs),
    kwargs...
) -&gt; CompositeQuantumSystem</code></pre><p>Returns a <code>CompositeQuantumSystem</code> object for a multi-transmon system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/templates/transmons/transmon_system.jl#L178-L193">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemTemplates.RadialMSGateSystem-Tuple{}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemTemplates.RadialMSGateSystem-Tuple{}"><code>Piccolo.Quantum.QuantumSystemTemplates.RadialMSGateSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">RadialMSGateSystem(;
    N_ions::Int=2,
    mode_levels::Int=5,
    œâm_radial::Vector{Float64}=[5.0, 5.0, 5.1, 5.1],  # 4 radial modes for 2 ions
    Œ¥::Union{Float64, Vector{Float64}}=0.2,           # Detuning(s) from mode(s)
    Œ∑::Union{Float64, Matrix{Float64}}=0.1,           # Lamb-Dicke parameters
    multiply_by_2œÄ::Bool=true,
    drive_bounds::Vector{&lt;:Union{Tuple{Float64, Float64}, Float64}}=fill(1.0, N_ions),
) -&gt; QuantumSystem</code></pre><p>Returns a time-dependent <code>QuantumSystem</code> for the <strong>radial-mode M√∏lmer-S√∏rensen gate</strong>  as described in the paper:</p><p><em>&quot;Realization and Calibration of Continuously Parameterized Two-Qubit Gates on a  Trapped-Ion Quantum Processor&quot;</em> (IEEE TQE 2024)</p><p>This implements the MS gate using <strong>only radial motional modes</strong> (not axial modes), which provides 2N modes for N ions (N modes along each of two transverse axes).</p><p><strong>Hamiltonian (Equation 2 from paper)</strong></p><p>In the interaction picture:</p><p class="math-container">\[H(t) = -\frac{i\hbar}{2} \sum_{i,k} \sigma_{x,i} \eta_{k,i} \Omega_i a_k e^{-i\delta_k t} + \text{h.c.}\]</p><p>Expanding the Hermitian conjugate:</p><p class="math-container">\[H(t) = -\frac{i}{2} \sum_{i,k} \eta_{k,i} \Omega_i \sigma_{x,i} \left(a_k e^{-i\delta_k t} - a_k^\dagger e^{i\delta_k t}\right)\]</p><p>where:</p><ul><li><p class="math-container">\[k\]</p>indexes the <strong>2N radial modes</strong> (N along x, N along y)</li><li><p class="math-container">\[\sigma_{x,i}\]</p>is Pauli-X on ion <span>$i$</span> </li><li><p class="math-container">\[\eta_{k,i}\]</p>is the Lamb-Dicke parameter for ion <span>$i$</span>, mode <span>$k$</span></li><li><p class="math-container">\[\Omega_i(t)\]</p>is the control amplitude (Rabi frequency) for ion <span>$i$</span></li><li><p class="math-container">\[\delta_k\]</p>is the detuning from motional sideband of mode <span>$k$</span></li><li><p class="math-container">\[a_k, a_k^\dagger\]</p>are phonon operators for radial mode <span>$k$</span></li></ul><p><strong>Radial Mode Structure</strong></p><p>For N ions in a linear trap with <strong>radial confinement</strong>:</p><ul><li><strong>Axial modes</strong> (along trap axis): Not used for this gate</li><li><strong>Radial modes</strong>: 2N modes total<ul><li>N modes along transverse x-direction  </li><li>N modes along transverse y-direction</li></ul></li></ul><p>For N=2 ions: <strong>4 radial modes</strong> participate in the gate dynamics.</p><p><strong>Typical Parameters (Q-SCOUT platform at Sandia, ¬π‚Å∑¬πYb‚Å∫)</strong></p><ul><li>Radial frequencies: <span>$\omega_r / 2\pi \sim 5$</span> MHz (higher than axial ~2 MHz)</li><li>Lamb-Dicke: <span>$\eta \sim 0.05 - 0.15$</span></li><li>Detuning: <span>$\delta / 2\pi \sim 100 - 500$</span> kHz</li><li>Gate time: <span>$50 - 200$</span> Œºs</li><li>Phonon states: <span>$n_{\max} = 3-5$</span> typically sufficient</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>N_ions</code>: Number of ions (default: 2)</li><li><code>mode_levels</code>: Fock states per radial mode (default: 5)</li><li><code>œâm_radial</code>: Radial mode frequencies in GHz. Vector of length 2N.  Example for 2 ions: <code>[5.0, 5.0, 5.1, 5.1]</code> (nearly degenerate pairs)</li><li><code>Œ¥</code>: Detuning(s) from sideband in GHz. Scalar (uniform) or vector per mode.</li><li><code>Œ∑</code>: Lamb-Dicke parameter(s). Scalar (uniform) or N_ions √ó 2N matrix.</li><li><code>multiply_by_2œÄ</code>: Multiply by 2œÄ (default true, since frequencies in GHz)</li><li><code>drive_bounds</code>: Control amplitude bounds for each ion (length N_ions)</li></ul><p><strong>Example: Two-Ion Radial MS Gate</strong></p><pre><code class="language-julia hljs">sys = RadialMSGateSystem(
    N_ions=2,
    mode_levels=5,
    œâm_radial=[5.0, 5.0, 5.1, 5.1],  # Two nearly-degenerate pairs
    Œ¥=0.2,                            # 200 kHz detuning
    Œ∑=0.1,                            # Lamb-Dicke parameter
    drive_bounds=[1.0, 1.0]           # Amplitude bounds (GHz)
)

# Create trajectory for XX gate
U_goal = exp(-im * œÄ/4 * kron([0 1; 1 0], [0 1; 1 0]))  # XX(œÄ/2)
qtraj = UnitaryTrajectory(sys, U_goal, 100e-6)  # 100 Œºs gate</code></pre><p><strong>Optimization Considerations</strong></p><ol><li><strong>Motional closure</strong>: All 2N modes must satisfy <span>$|\alpha_k(\tau)| \approx 0$</span></li><li><strong>Target mode</strong>: Choose one mode (e.g., k=1) as primary entangling mode</li><li><strong>Spectator modes</strong>: Other modes should remain minimally excited</li><li><strong>Control strategy</strong>: Individual ion addressing via <span>$\Omega_i(t)$</span></li></ol><p><strong>References</strong></p><ul><li>S√∏rensen &amp; M√∏lmer, &quot;Quantum computation with ions in thermal motion,&quot; PRL 82, 1971 (1999)</li><li>Mizrahi et al., &quot;Realization and Calibration of Continuously Parameterized Two-Qubit  Gates...,&quot; IEEE TQE (2024)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/templates/ions/radial_ms.jl#L3-L100">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemTemplates.RadialMSGateSystemWithPhase-Tuple{}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemTemplates.RadialMSGateSystemWithPhase-Tuple{}"><code>Piccolo.Quantum.QuantumSystemTemplates.RadialMSGateSystemWithPhase</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">RadialMSGateSystemWithPhase(;
    N_ions::Int=2,
    mode_levels::Int=5,
    œâm_radial::Vector{Float64}=[5.0, 5.0, 5.1, 5.1],
    Œ¥::Union{Float64, Vector{Float64}}=0.2,
    Œ∑::Union{Float64, Matrix{Float64}}=0.1,
    multiply_by_2œÄ::Bool=true,
    amplitude_bounds::Vector{&lt;:Union{Tuple{Float64, Float64}, Float64}}=fill(1.0, N_ions),
    phase_bounds::Vector{&lt;:Union{Tuple{Float64, Float64}, Float64}}=fill((-œÄ, œÄ), N_ions),
) -&gt; QuantumSystem</code></pre><p>Returns a time-dependent <code>QuantumSystem</code> for the radial-mode MS gate <strong>with phase controls</strong> to enable AC Stark shift compensation.</p><p><strong>Hamiltonian (with phase modulation)</strong></p><p>Instead of <span>$\sigma_x = \sigma^+ + \sigma^-$</span>, we use phase-modulated drives:</p><p class="math-container">\[H(t) = \frac{1}{2} \sum_{i,k} \eta_{k,i} \Omega_i(t) \left(\sigma^+_i e^{i\phi_i(t)} + \sigma^-_i e^{-i\phi_i(t)}\right) 
       \left(a_k e^{-i\delta_k t} + a_k^\dagger e^{i\delta_k t}\right)\]</p><p>where <span>$\Omega_i(t)$</span> and <span>$\phi_i(t)$</span> are independent controls.</p><p><strong>Why Phase Controls?</strong></p><p>Off-resonant coupling to spectator modes creates <strong>AC Stark shifts</strong>:</p><p class="math-container">\[\Delta E_{\text{Stark}} \sim \frac{\eta^2 \Omega^2(t)}{\delta_{\text{spectator}}}\]</p><p>This causes <strong>time-varying phase accumulation</strong> that <span>$\sigma_x$</span> control alone cannot compensate. The solution: actively modulate <span>$\phi_i(t)$</span> to cancel the Stark-induced phase, typically using:</p><p class="math-container">\[\phi(t) \sim \int_0^t \frac{\eta^2 \Omega^2(t&#39;)}{\delta} dt&#39; \sim \text{erf}(\sqrt{2}t) \text{ for Gaussian pulses}\]</p><p>This enables <strong>loop closure</strong> in phase space and high-fidelity gates (<span>$F &gt; 0.99$</span>).</p><p><strong>Control Structure</strong></p><p>Controls: <span>$[\\Omega_1, \phi_1, \\Omega_2, \phi_2, \ldots]$</span> for <span>$N_{\text{ions}}$</span> ions.</p><ul><li>Even indices (1, 3, 5, ...): Amplitudes <span>$\Omega_i(t)$</span> (Rabi frequency)</li><li>Odd indices (2, 4, 6, ...): Phases <span>$\phi_i(t)$</span> (laser phase)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sys = RadialMSGateSystemWithPhase(
    N_ions=2,
    mode_levels=3,
    œâm_radial=[5.0, 5.0, 5.1, 5.1],
    Œ¥=0.2,
    Œ∑=0.1,
    amplitude_bounds=[1.0, 1.0],
    phase_bounds=[(-Float64(œÄ), Float64(œÄ)), (-Float64(œÄ), Float64(œÄ))]
)

# sys.n_drives == 4 (Œ©‚ÇÅ, œÜ‚ÇÅ, Œ©‚ÇÇ, œÜ‚ÇÇ)</code></pre><p><strong>See Also</strong></p><ul><li><code>RadialMSGateSystem</code>: Amplitude-only version (simpler but limited fidelity)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/templates/ions/radial_ms.jl#L227-L290">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemTemplates.RydbergChainSystem-Tuple{}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemTemplates.RydbergChainSystem-Tuple{}"><code>Piccolo.Quantum.QuantumSystemTemplates.RydbergChainSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">RydbergChainSystem(;
    N::Int=3, # number of atoms
    C::Float64=862690*2œÄ,
    distance::Float64=10.0, # Œºm
    cutoff_order::Int=2, # 1 is nearest neighbor, 2 is next-nearest neighbor, etc.
    local_detune::Bool=false, # If true, include one local detuning pattern.
    all2all::Bool=true, # If true, include all-to-all interactions.
    ignore_Y_drive::Bool=false, # If true, ignore the Y drive. (In the experiments, X&amp;Y drives are implemented by Rabi amplitude and its phase.)
    drive_bounds::Vector{&lt;:Union{Tuple{Float64, Float64}, Float64}}=[1.0, 1.0, 1.0], # Bounds for [Œ©x, Œ©y, Œî] or [Œ©x, Œî] if ignore_Y_drive
) -&gt; QuantumSystem</code></pre><p>Returns a <code>QuantumSystem</code> object for the Rydberg atom chain in the spin basis     |g‚ü© = |0‚ü© = [1, 0], |r‚ü© = |1‚ü© = [0, 1].</p><p class="math-container">\[H = \sum_i 0.5*\Omega_i(t)\cos(\phi_i(t)) \sigma_i^x - 0.5*\Omega_i(t)\sin(\phi_i(t)) \sigma_i^y - \sum_i \Delta_i(t)n_i + \sum_{i&lt;j} \frac{C}{|i-j|^6} n_i n_j\]</p><p><strong>Keyword Arguments</strong></p><ul><li><code>N</code>: Number of atoms.</li><li><code>C</code>: The Rydberg interaction strength in MHz*Œºm^6.</li><li><code>distance</code>: The distance between atoms in Œºm.</li><li><code>cutoff_order</code>: Interaction range cutoff, 1 is nearest neighbor, 2 is next nearest neighbor.</li><li><code>local_detune</code>: If true, include one local detuning pattern.</li><li><code>all2all</code>: If true, include all-to-all interactions.</li><li><code>ignore_Y_drive</code>: If true, ignore the Y drive. (In the experiments, X&amp;Y drives are implemented by Rabi amplitude and its phase.)</li><li><code>drive_bounds</code>: Bounds for drive amplitudes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/templates/atoms/rydberg_chain.jl#L36-L65">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemTemplates.TransmonCavitySystem-Tuple{}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemTemplates.TransmonCavitySystem-Tuple{}"><code>Piccolo.Quantum.QuantumSystemTemplates.TransmonCavitySystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TransmonCavitySystem(;
    qubit_levels::Int=4,
    cavity_levels::Int=12,
    œá::Float64=2œÄ * 32.8e-6,    # Dispersive shift (GHz)
    œá‚Ä≤::Float64=2œÄ * 1.5e-9,    # Higher-order dispersive shift (GHz)
    K_c::Float64=2œÄ * 1e-9 / 2, # Cavity self-Kerr (GHz)
    K_q::Float64=2œÄ * 193e-3 / 2, # Qubit self-Kerr (GHz)
    drive_bounds::Vector{&lt;:Union{Tuple{Float64, Float64}, Float64}}=fill(1.0, 4),
    multiply_by_2œÄ::Bool=false, # Already in GHz with 2œÄ factors
) -&gt; QuantumSystem</code></pre><p>Returns a <code>QuantumSystem</code> for a transmon qubit dispersively coupled to a cavity mode.</p><p>This system models circuit QED architectures where a transmon (artificial atom) is coupled  to a microwave resonator in the dispersive regime, enabling quantum state manipulation and  readout.</p><p><strong>Hamiltonian</strong></p><p class="math-container">\[H = \tilde{\Delta} \hat{b}^\dagger \hat{b} 
    - \chi \hat{a}^\dagger \hat{a} \hat{b}^\dagger \hat{b}
    - \chi&#39; \hat{b}^{\dagger 2} \hat{b}^2 \hat{a}^\dagger \hat{a}
    - K_q \hat{a}^{\dagger 2} \hat{a}^2
    - K_c \hat{b}^{\dagger 2} \hat{b}^2\]</p><p>where:</p><ul><li><span>$\hat{a}$</span>, <span>$\hat{a}^\dagger$</span> are the transmon annihilation/creation operators</li><li><span>$\hat{b}$</span>, <span>$\hat{b}^\dagger$</span> are the cavity annihilation/creation operators  </li><li><span>$\tilde{\Delta} = \chi/2$</span> is the shifted cavity frequency</li><li><span>$\chi$</span> is the dispersive shift (qubit-cavity coupling)</li><li><span>$\chi&#39;$</span> is a higher-order dispersive correction</li><li><span>$K_q$</span>, <span>$K_c$</span> are self-Kerr nonlinearities</li></ul><p>The drives are:</p><ol><li><span>$\hat{a}^\dagger + \hat{a}$</span> - Real transmon drive</li><li><span>$i(\hat{a}^\dagger - \hat{a})$</span> - Imaginary transmon drive</li><li><span>$\hat{b}^\dagger + \hat{b}$</span> - Real cavity drive</li><li><span>$i(\hat{b}^\dagger - \hat{b})$</span> - Imaginary cavity drive</li></ol><p><strong>Keyword Arguments</strong></p><ul><li><code>qubit_levels</code>: Number of transmon Fock states (typically 3-5)</li><li><code>cavity_levels</code>: Number of cavity Fock states (typically 10-20)</li><li><code>œá</code>: Dispersive shift in GHz (with 2œÄ). Typical: ~2œÄ √ó 30-50 kHz</li><li><code>œá‚Ä≤</code>: Higher-order dispersive shift in GHz. Typically small (~2œÄ √ó 1-2 Hz)</li><li><code>K_c</code>: Cavity self-Kerr in GHz. Typically ~2œÄ √ó 1 Hz</li><li><code>K_q</code>: Qubit self-Kerr (anharmonicity/2) in GHz. Typical: ~2œÄ √ó 100-200 MHz</li><li><code>drive_bounds</code>: Control bounds for [Œ©·µ£(qubit), Œ©·µ¢(qubit), Œ±·µ£(cavity), Œ±·µ¢(cavity)]</li><li><code>multiply_by_2œÄ</code>: Whether to multiply by 2œÄ (default false, assuming parameters already include it)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Standard cQED parameters
sys = TransmonCavitySystem(
    qubit_levels=4,
    cavity_levels=15,
    œá=2œÄ * 32.8e-6,   # 32.8 kHz dispersive shift
    K_q=2œÄ * 193e-3/2, # ~193 MHz anharmonicity
)</code></pre><p><strong>References</strong></p><ul><li>Blais et al., &quot;Circuit quantum electrodynamics,&quot; Rev. Mod. Phys. 93, 025005 (2021)</li><li>Koch et al., &quot;Charge-insensitive qubit design derived from Cooper pair box,&quot;  Phys. Rev. A 76, 042319 (2007)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/templates/transmons/transmon_system.jl#L347-L414">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemTemplates.TransmonDipoleCoupling"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemTemplates.TransmonDipoleCoupling"><code>Piccolo.Quantum.QuantumSystemTemplates.TransmonDipoleCoupling</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">TransmonDipoleCoupling(
    g_ij::Float64,
    pair::Tuple{Int, Int},
    subsystem_levels::Vector{Int};
    lab_frame::Bool=false,
) -&gt; QuantumSystemCoupling

TransmonDipoleCoupling(
    g_ij::Float64,
    pair::Tuple{Int, Int},
    sub_systems::Vector{QuantumSystem};
    kwargs...
) -&gt; QuantumSystemCoupling</code></pre><p>Returns a <code>QuantumSystemCoupling</code> object for a transmon qubit. In the lab frame, the Hamiltonian coupling term is</p><p class="math-container">\[H = g_{ij} (a_i + a_i^\dagger) (a_j + a_j^\dagger)\]</p><p>In the rotating frame, the Hamiltonian coupling term is</p><p class="math-container">\[H = g_{ij} (a_i a_j^\dagger + a_i^\dagger a_j)\]</p><p>where <code>a_i</code> is the annihilation operator for the <code>i</code>th transmon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/templates/transmons/transmon_system.jl#L102-L131">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemTemplates.TransmonSystem-Tuple{}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemTemplates.TransmonSystem-Tuple{}"><code>Piccolo.Quantum.QuantumSystemTemplates.TransmonSystem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TransmonSystem(;
    œâ::Float64=4.4153,  # GHz
    Œ¥::Float64=0.17215, # GHz
    levels::Int=3,
    lab_frame::Bool=false,
    frame_œâ::Float64=œâ,
) -&gt; QuantumSystem</code></pre><p>Returns a <code>QuantumSystem</code> object for a transmon qubit, with the Hamiltonian</p><p class="math-container">\[H = \omega a^\dagger a - \frac{\delta}{2} a^\dagger a^\dagger a a\]</p><p>where <code>a</code> is the annihilation operator.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>œâ</code>: The frequency of the transmon, in GHz.</li><li><code>Œ¥</code>: The anharmonicity of the transmon, in GHz.</li><li><code>levels</code>: The number of levels in the transmon.</li><li><code>lab_frame</code>: Whether to use the lab frame Hamiltonian, or an œâ-rotating frame.</li><li><code>frame_œâ</code>: The frequency of the rotating frame, in GHz.</li><li><code>mutiply_by_2œÄ</code>: Whether to multiply the Hamiltonian by 2œÄ, set to true by default because the frequency is in GHz.</li><li><code>lab_frame_type</code>: The type of lab frame Hamiltonian to use, one of (:duffing, :quartic, :cosine).</li><li><code>drives</code>: Whether to include drives in the Hamiltonian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/templates/transmons/transmon_system.jl#L7-L33">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemTemplates.coherent_ket-Tuple{Union{Real, Complex}, Int64}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemTemplates.coherent_ket-Tuple{Union{Real, Complex}, Int64}"><code>Piccolo.Quantum.QuantumSystemTemplates.coherent_ket</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coherent_ket(Œ±, levels)</code></pre><p>Construct a coherent state <span>$|Œ±‚ü©$</span> in the Fock basis truncated to <code>levels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/templates/cats/cat_system.jl#L5-L9">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemTemplates.get_cat_controls-Tuple{AbstractQuantumSystem, Real, Int64}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemTemplates.get_cat_controls-Tuple{AbstractQuantumSystem, Real, Int64}"><code>Piccolo.Quantum.QuantumSystemTemplates.get_cat_controls</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_cat_controls(sys::AbstractQuantumSystem, Œ±, N)</code></pre><p>Compute static cat qubit controls for <code>N</code> time steps at coherent amplitude <code>Œ±</code>, reading <code>g2</code> and <code>œá_aa</code> from <code>sys.global_params</code>.</p><p>Returns a <code>2 √ó N</code> matrix where row 1 is the buffer drive and row 2 is the Kerr correction drive. These are the steady-state controls that maintain a coherent state <span>$|Œ±‚ü©$</span> in the cat mode.</p><p><strong>Arguments</strong></p><ul><li><code>sys</code>: A quantum system with <code>g2</code> and <code>œá_aa</code> in its <code>global_params</code></li><li><code>Œ±</code>: Coherent state amplitude</li><li><code>N</code>: Number of time steps</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/templates/cats/cat_system.jl#L113-L127">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemTemplates.lift-Tuple{Char, Int64, Int64}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemTemplates.lift-Tuple{Char, Int64, Int64}"><code>Piccolo.Quantum.QuantumSystemTemplates.lift</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lift(x::Char, i::Int, N::Int)::String</code></pre><p>Embed a character into a string of the form &#39;I&#39; * N at a specific position (meant for use with <code>Piccolo.QuantumObjectUtils.operator_from_string</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/templates/atoms/rydberg_chain.jl#L25-L29">source</a></section></details></article><h2 id="lib-quantum-system-utils"><a class="docs-heading-anchor" href="#lib-quantum-system-utils">Quantum System Utilities</a><a id="lib-quantum-system-utils-1"></a><a class="docs-heading-anchor-permalink" href="#lib-quantum-system-utils" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemUtils.is_linearly_dependent-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemUtils.is_linearly_dependent-Tuple{AbstractMatrix}"><code>Piccolo.Quantum.QuantumSystemUtils.is_linearly_dependent</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_linearly_dependent(M::AbstractMatrix; eps=eps(Float32), verbose=true)</code></pre><p>Check if the columns of the matrix <code>M</code> are linearly dependent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/system_utils.jl#L24-L28">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{&lt;:Number}, AbstractQuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{&lt;:Number}, AbstractQuantumSystem}"><code>Piccolo.Quantum.QuantumSystemUtils.is_reachable</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_reachable(gate::AbstractMatrix{&lt;:Number}, system::AbstractQuantumSystem; kwargs...)</code></pre><p>Check if the <code>gate</code> is reachable using the given <code>system</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>use_drift::Bool=true</code>: include drift Hamiltonian in the generators</li><li><code>kwargs...</code>: keyword arguments for <code>is_reachable</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/system_utils.jl#L263-L271">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:AbstractMatrix{&lt;:Number}}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:AbstractMatrix{&lt;:Number}}}"><code>Piccolo.Quantum.QuantumSystemUtils.is_reachable</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_reachable(gate, hamiltonians; kwargs...)</code></pre><p>Check if the <code>gate</code> is reachable using the given <code>hamiltonians</code>.</p><p><strong>Arguments</strong></p><ul><li><code>gate::AbstractMatrix</code>: target gate</li><li><code>hamiltonians::AbstractVector{&lt;:AbstractMatrix}</code>: generators of the Lie algebra</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>subspace::AbstractVector{&lt;:Int}=1:size(gate, 1)</code>: subspace indices</li><li><code>compute_basis::Bool=true</code>: compute the basis or use the Hamiltonians directly</li><li><code>remove_trace::Bool=true</code>: remove trace from generators</li><li><code>verbose::Bool=true</code>: print information about the operator algebra</li><li><code>atol::Float32=eps(Float32)</code>: absolute tolerance</li></ul><p>See also <a href="#Piccolo.Quantum.QuantumSystemUtils.operator_algebra-Union{Tuple{Vector{&lt;:AbstractMatrix{T}}}, Tuple{T}} where T&lt;:Number"><code>QuantumSystemUtils.operator_algebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/system_utils.jl#L219-L236">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumSystemUtils.operator_algebra-Union{Tuple{Vector{&lt;:AbstractMatrix{T}}}, Tuple{T}} where T&lt;:Number"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumSystemUtils.operator_algebra-Union{Tuple{Vector{&lt;:AbstractMatrix{T}}}, Tuple{T}} where T&lt;:Number"><code>Piccolo.Quantum.QuantumSystemUtils.operator_algebra</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">operator_algebra(generators; kwargs...)</code></pre><p>Compute the Lie algebra basis for the given <code>generators</code>.</p><p><strong>Arguments</strong></p><ul><li><code>generators::Vector{&lt;:AbstractMatrix}</code>: generators of the Lie algebra</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>return_layers::Bool=false</code>: return the Lie tree layers</li><li><code>normalize::Bool=false</code>: normalize the basis</li><li><code>verbose::Bool=false</code>: print information</li><li><code>remove_trace::Bool=true</code>: remove trace from generators</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/system_utils.jl#L83-L96">source</a></section></details></article><h2 id="lib-gates"><a class="docs-heading-anchor" href="#lib-gates">Gates and Pauli Matrices</a><a id="lib-gates-1"></a><a class="docs-heading-anchor-permalink" href="#lib-gates" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Quantum.Gates.GATES"><a class="docstring-binding" href="#Piccolo.Quantum.Gates.GATES"><code>Piccolo.Quantum.Gates.GATES</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><section><div><p>A constant dictionary <code>GATES</code> containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix.</p><ul><li><code>GATES[:I]</code> - Identity: Leaves the state unchanged.</li><li><code>GATES[:X]</code> - Pauli-X (NOT): Flips the qubit state.</li><li><code>GATES[:Y]</code> - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere.</li><li><code>GATES[:Z]</code> - Pauli-Z: Flips the phase of the qubit state.</li><li><code>GATES[:H]</code> - Hadamard: Creates superposition by transforming basis states.</li><li><code>GATES[:CX]</code> - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1‚ü©.</li><li><code>GATES[:CZ]</code> - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1‚ü©.</li><li><code>GATES[:XI]</code> - Complex: A gate for complex operations.</li><li><code>GATES[:sqrtiSWAP]</code> - Square root of iSWAP: Partially swaps two qubits with a phase.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/gates.jl#L30-L42">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Gates.PAULIS"><a class="docstring-binding" href="#Piccolo.Quantum.Gates.PAULIS"><code>Piccolo.Quantum.Gates.PAULIS</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><section><div><p>The 2√ó2 Pauli matrics and identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/gates.jl#L8-L10">source</a></section></details></article><h2 id="lib-quantum-object-utils"><a class="docs-heading-anchor" href="#lib-quantum-object-utils">Quantum Object Utilities</a><a id="lib-quantum-object-utils-1"></a><a class="docs-heading-anchor-permalink" href="#lib-quantum-object-utils" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumObjectUtils.annihilate-Tuple{Int64}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumObjectUtils.annihilate-Tuple{Int64}"><code>Piccolo.Quantum.QuantumObjectUtils.annihilate</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">annihilate(levels::Int)</code></pre><p>Get the annihilation operator for a system with <code>levels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/object_utils.jl#L149-L153">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumObjectUtils.create-Tuple{Int64}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumObjectUtils.create-Tuple{Int64}"><code>Piccolo.Quantum.QuantumObjectUtils.create</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create(levels::Int)</code></pre><p>Get the creation operator for a system with <code>levels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/object_utils.jl#L156-L160">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumObjectUtils.haar_identity-Tuple{Int64, Number}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumObjectUtils.haar_identity-Tuple{Int64, Number}"><code>Piccolo.Quantum.QuantumObjectUtils.haar_identity</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">haar_identity(n::Int, radius::Number)</code></pre><p>Generate a random unitary matrix close to the identity matrix using the Haar measure for an <code>n</code>-dimensional system with a given <code>radius</code>. The smaller the radius, the closer the matrix will be to the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/object_utils.jl#L129-L135">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumObjectUtils.haar_random-Tuple{Int64}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumObjectUtils.haar_random-Tuple{Int64}"><code>Piccolo.Quantum.QuantumObjectUtils.haar_random</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">haar_random(n::Int)</code></pre><p>Generate a random unitary matrix using the Haar measure for an <code>n</code>-dimensional system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/object_utils.jl#L115-L119">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumObjectUtils.ket_from_bitstring-Tuple{String}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumObjectUtils.ket_from_bitstring-Tuple{String}"><code>Piccolo.Quantum.QuantumObjectUtils.ket_from_bitstring</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ket_from_bitstring(ket::String)</code></pre><p>Get the state vector for a qubit system given a ket string <code>ket</code> of 0s and 1s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/object_utils.jl#L99-L103">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumObjectUtils.ket_from_string-Tuple{String, Vector{Int64}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumObjectUtils.ket_from_string-Tuple{String, Vector{Int64}}"><code>Piccolo.Quantum.QuantumObjectUtils.ket_from_string</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ket_from_string(
    ket::String,
    levels::Vector{Int};
    level_dict=Dict(:g =&gt; 0, :e =&gt; 1, :f =&gt; 2, :h =&gt; 3, :i =&gt; 4, :j =&gt; 5, :k =&gt; 6, :l =&gt; 7),
    return_states=false
)</code></pre><p>Construct a quantum state from a string ket representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/object_utils.jl#L32-L41">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumObjectUtils.operator_from_string-Tuple{String}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumObjectUtils.operator_from_string-Tuple{String}"><code>Piccolo.Quantum.QuantumObjectUtils.operator_from_string</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">operator_from_string(operator::String; lookup=PAULIS)</code></pre><p>Reduce the string (each character is one key) via operators from a dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/object_utils.jl#L18-L22">source</a></section></details></article><h2 id="lib-trajectories"><a class="docs-heading-anchor" href="#lib-trajectories">Trajectories</a><a id="lib-trajectories-1"></a><a class="docs-heading-anchor-permalink" href="#lib-trajectories" title="Permalink"></a></h2><article><details class="docstring"><summary id="NamedTrajectories.StructNamedTrajectory.NamedTrajectory"><a class="docstring-binding" href="#NamedTrajectories.StructNamedTrajectory.NamedTrajectory"><code>NamedTrajectories.StructNamedTrajectory.NamedTrajectory</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NamedTrajectory(qtraj::MultiKetTrajectory; kwargs...)
NamedTrajectory(qtraj::MultiKetTrajectory, N::Int; kwargs...)
NamedTrajectory(qtraj::MultiKetTrajectory, times::AbstractVector; kwargs...)</code></pre><p>Convert an MultiKetTrajectory to a NamedTrajectory for optimization.</p><p><strong>Stored Variables</strong></p><ul><li><code>œàÃÉ1</code>, <code>œàÃÉ2</code>, ...: Isomorphisms of each ket state</li><li><code>u</code> (or custom drive_name): Control values sampled at times</li><li><code>du</code>: Control derivatives (only for CubicSplinePulse)</li><li><code>t</code>: Times</li></ul><p><strong>Arguments</strong></p><ul><li><code>N_or_times</code>: One of:<ul><li><code>nothing</code> (default): Use native knot times from spline pulse</li><li><code>N::Int</code>: Number of uniformly spaced time points</li><li><code>times::AbstractVector</code>: Specific times to sample at</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Œît_bounds</code>: Optional tuple <code>(lower, upper)</code> for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: <code>nothing</code> (no bounds).</li><li><code>global_data</code>: Optional Dict mapping global variable names to initial values (as vectors). Note: global variables are optimization variables without explicit box constraints.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/named_trajectory_conversion.jl#L427-L451">source</a></section></details></article><article><details class="docstring"><summary id="NamedTrajectories.StructNamedTrajectory.NamedTrajectory"><a class="docstring-binding" href="#NamedTrajectories.StructNamedTrajectory.NamedTrajectory"><code>NamedTrajectories.StructNamedTrajectory.NamedTrajectory</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NamedTrajectory(qtraj::KetTrajectory; kwargs...)
NamedTrajectory(qtraj::KetTrajectory, N::Int; kwargs...)
NamedTrajectory(qtraj::KetTrajectory, times::AbstractVector; kwargs...)</code></pre><p>Convert a KetTrajectory to a NamedTrajectory for optimization.</p><p><strong>Stored Variables</strong></p><ul><li><code>œàÃÉ</code>: Isomorphism of ket state (real representation)</li><li><code>u</code> (or custom drive_name): Control values sampled at times</li><li><code>du</code>: Control derivatives (only for CubicSplinePulse)</li><li><code>t</code>: Times</li></ul><p><strong>Arguments</strong></p><ul><li><code>N_or_times</code>: One of:<ul><li><code>nothing</code> (default): Use native knot times from spline pulse</li><li><code>N::Int</code>: Number of uniformly spaced time points</li><li><code>times::AbstractVector</code>: Specific times to sample at</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Œît_bounds</code>: Optional tuple <code>(lower, upper)</code> for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: <code>nothing</code> (no bounds).</li><li><code>global_data</code>: Optional Dict mapping global variable names to initial values (as vectors). Note: global variables are optimization variables without explicit box constraints.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/named_trajectory_conversion.jl#L341-L365">source</a></section></details></article><article><details class="docstring"><summary id="NamedTrajectories.StructNamedTrajectory.NamedTrajectory"><a class="docstring-binding" href="#NamedTrajectories.StructNamedTrajectory.NamedTrajectory"><code>NamedTrajectories.StructNamedTrajectory.NamedTrajectory</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NamedTrajectory(qtraj::UnitaryTrajectory; kwargs...)
NamedTrajectory(qtraj::UnitaryTrajectory, N::Int; kwargs...)
NamedTrajectory(qtraj::UnitaryTrajectory, times::AbstractVector; kwargs...)</code></pre><p>Convert a UnitaryTrajectory to a NamedTrajectory for optimization.</p><p>The trajectory stores actual times <code>:t</code> (not timesteps <code>:Œît</code>), which is required for time-dependent integrators used with <code>SplinePulseProblem</code>.</p><p><strong>Stored Variables</strong></p><ul><li><code>≈®‚Éó</code>: Isomorphism of unitary (vectorized real representation)</li><li><code>u</code> (or custom drive_name): Control values sampled at times</li><li><code>du</code>: Control derivatives (only for CubicSplinePulse)</li><li><code>t</code>: Times</li></ul><p><strong>Arguments</strong></p><ul><li><code>qtraj</code>: The quantum trajectory to convert</li><li><code>N_or_times</code>: One of:<ul><li><code>nothing</code> (default): Use native knot times from spline pulse (error for non-spline pulses)</li><li><code>N::Int</code>: Number of uniformly spaced time points</li><li><code>times::AbstractVector</code>: Specific times to sample at</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Œît_bounds</code>: Optional tuple <code>(lower, upper)</code> for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: <code>nothing</code> (no bounds).</li><li><code>global_data</code>: Optional Dict mapping global variable names to initial values (as vectors). Note: global variables are optimization variables without explicit box constraints.</li></ul><p><strong>Returns</strong></p><p>A NamedTrajectory suitable for direct collocation optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/named_trajectory_conversion.jl#L244-L275">source</a></section></details></article><article><details class="docstring"><summary id="NamedTrajectories.StructNamedTrajectory.NamedTrajectory"><a class="docstring-binding" href="#NamedTrajectories.StructNamedTrajectory.NamedTrajectory"><code>NamedTrajectories.StructNamedTrajectory.NamedTrajectory</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NamedTrajectory(qtraj::DensityTrajectory; kwargs...)
NamedTrajectory(qtraj::DensityTrajectory, N::Int; kwargs...)
NamedTrajectory(qtraj::DensityTrajectory, times::AbstractVector; kwargs...)</code></pre><p>Convert a DensityTrajectory to a NamedTrajectory for optimization.</p><p>Uses the compact density isomorphism (n¬≤ real parameters) which exploits the Hermiticity of density matrices. This halves the state dimension compared to the full [vec(Re(œÅ)); vec(Im(œÅ))] representation.</p><p><strong>Stored Variables</strong></p><ul><li><code>œÅ‚ÉóÃÉ</code>: Compact isomorphism of the density matrix (n¬≤ real parameters)</li><li><code>u</code> (or custom drive_name): Control values sampled at times</li><li><code>du</code>: Control derivatives (only for CubicSplinePulse)</li><li><code>t</code>: Times</li></ul><p><strong>Arguments</strong></p><ul><li><code>N_or_times</code>: One of:<ul><li><code>nothing</code> (default): Use native knot times from spline pulse</li><li><code>N::Int</code>: Number of uniformly spaced time points</li><li><code>times::AbstractVector</code>: Specific times to sample at</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Œît_bounds</code>: Optional tuple <code>(lower, upper)</code> for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: <code>nothing</code> (no bounds).</li><li><code>global_data</code>: Optional Dict mapping global variable names to initial values (as vectors). Note: global variables are optimization variables without explicit box constraints.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/named_trajectory_conversion.jl#L525-L553">source</a></section></details></article><article><details class="docstring"><summary id="NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{P}, Tuple{SamplingTrajectory{P, &lt;:UnitaryTrajectory{P}}, Union{Int64, AbstractVector{&lt;:Real}}}} where P&lt;:AbstractPulse"><a class="docstring-binding" href="#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{P}, Tuple{SamplingTrajectory{P, &lt;:UnitaryTrajectory{P}}, Union{Int64, AbstractVector{&lt;:Real}}}} where P&lt;:AbstractPulse"><code>NamedTrajectories.StructNamedTrajectory.NamedTrajectory</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NamedTrajectory(sampling::SamplingTrajectory, N::Int)
NamedTrajectory(sampling::SamplingTrajectory, times::AbstractVector)</code></pre><p>Convert a SamplingTrajectory to a NamedTrajectory for optimization.</p><p>Creates a trajectory with multiple state variables (one per system),  all sharing the same control pulse. Each state gets a numeric suffix:</p><ul><li>UnitaryTrajectory base ‚Üí <code>:≈®‚Éó1</code>, <code>:≈®‚Éó2</code>, ...</li><li>KetTrajectory base ‚Üí <code>:œàÃÉ1</code>, <code>:œàÃÉ2</code>, ...</li></ul><p>For robust optimization, each state variable represents the evolution under a different system (e.g., parameter variations), but all share the same controls.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create sampling trajectory with 3 system variations
sampling = SamplingTrajectory(base_qtraj, [sys1, sys2, sys3])

# Convert to NamedTrajectory with 51 timesteps
traj = NamedTrajectory(sampling, 51)
# Result has: :≈®‚Éó1, :≈®‚Éó2, :≈®‚Éó3, :u, :Œît, :t</code></pre><p><strong>Keyword Arguments</strong></p><ul><li><code>Œît_bounds</code>: Optional tuple <code>(lower, upper)</code> for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: <code>nothing</code> (no bounds).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/sampling_trajectory.jl#L115-L142">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.AbstractQuantumTrajectory"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.AbstractQuantumTrajectory"><code>Piccolo.Quantum.QuantumTrajectories.AbstractQuantumTrajectory</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractQuantumTrajectory{P&lt;:AbstractPulse}</code></pre><p>Abstract type for quantum trajectories that wrap physics (system, pulse, solution, goal). Parametric on pulse type <code>P</code> to enable dispatch in problem templates.</p><p>All concrete subtypes should implement:</p><ul><li><code>state_name(traj)</code> - Get the state variable symbol (fixed per type)</li><li><code>drive_name(traj)</code> - Get the drive variable symbol (from pulse)</li><li><code>time_name(traj)</code> - Get the time variable symbol (fixed <code>:t</code>)</li><li><code>timestep_name(traj)</code> - Get the timestep variable symbol (fixed <code>:Œît</code>)</li><li><code>duration(traj)</code> - Get the duration (from pulse)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/abstract_trajectory.jl#L5-L17">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.DensityTrajectory"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.DensityTrajectory"><code>Piccolo.Quantum.QuantumTrajectories.DensityTrajectory</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DensityTrajectory{P&lt;:AbstractPulse, S&lt;:ODESolution} &lt;: AbstractQuantumTrajectory{P}</code></pre><p>Trajectory for open quantum systems (Lindblad dynamics).</p><p><strong>Fields</strong></p><ul><li><code>system::OpenQuantumSystem</code>: The open quantum system</li><li><code>pulse::P</code>: The control pulse</li><li><code>initial::Matrix{ComplexF64}</code>: Initial density matrix œÅ‚ÇÄ</li><li><code>goal::Matrix{ComplexF64}</code>: Target density matrix œÅ_goal</li><li><code>solution::S</code>: Pre-computed ODE solution</li></ul><p><strong>Callable</strong></p><p><code>traj(t)</code> returns the density matrix at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/density_trajectory.jl#L5-L19">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.DensityTrajectory-Tuple{OpenQuantumSystem, AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, Real}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.DensityTrajectory-Tuple{OpenQuantumSystem, AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, Real}"><code>Piccolo.Quantum.QuantumTrajectories.DensityTrajectory</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DensityTrajectory(system, initial, goal, T::Real; drive_name=:u, algorithm=Tsit5())</code></pre><p>Convenience constructor that creates a zero pulse of duration T.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/density_trajectory.jl#L61-L65">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.DensityTrajectory-Tuple{OpenQuantumSystem, AbstractPulse, AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.DensityTrajectory-Tuple{OpenQuantumSystem, AbstractPulse, AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}"><code>Piccolo.Quantum.QuantumTrajectories.DensityTrajectory</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DensityTrajectory(system, pulse, initial, goal; algorithm=Tsit5())</code></pre><p>Create a density matrix trajectory by solving the Lindblad master equation.</p><p><strong>Arguments</strong></p><ul><li><code>system::OpenQuantumSystem</code>: The open quantum system</li><li><code>pulse::AbstractPulse</code>: The control pulse</li><li><code>initial::Matrix</code>: Initial density matrix œÅ‚ÇÄ</li><li><code>goal::Matrix</code>: Target density matrix œÅ_goal</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>algorithm</code>: ODE solver algorithm (default: Tsit5())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/density_trajectory.jl#L29-L42">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.KetTrajectory"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.KetTrajectory"><code>Piccolo.Quantum.QuantumTrajectories.KetTrajectory</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">KetTrajectory{P&lt;:AbstractPulse, S&lt;:ODESolution} &lt;: AbstractQuantumTrajectory{P}</code></pre><p>Trajectory for quantum state transfer. The ODE solution is computed at construction.</p><p><strong>Fields</strong></p><ul><li><code>system::QuantumSystem</code>: The quantum system</li><li><code>pulse::P</code>: The control pulse</li><li><code>initial::Vector{ComplexF64}</code>: Initial state |œà‚ÇÄ‚ü©</li><li><code>goal::Vector{ComplexF64}</code>: Target state |œà_goal‚ü©</li><li><code>solution::S</code>: Pre-computed ODE solution</li></ul><p><strong>Callable</strong></p><p><code>traj(t)</code> returns the state at time <code>t</code> by interpolating the solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/ket_trajectory.jl#L5-L19">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.KetTrajectory-Tuple{QuantumSystem, AbstractPulse, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.KetTrajectory-Tuple{QuantumSystem, AbstractPulse, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>Piccolo.Quantum.QuantumTrajectories.KetTrajectory</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KetTrajectory(system, pulse, initial, goal; algorithm=MagnusGL4())</code></pre><p>Create a ket trajectory by solving the Schr√∂dinger equation.</p><p><strong>Arguments</strong></p><ul><li><code>system::QuantumSystem</code>: The quantum system</li><li><code>pulse::AbstractPulse</code>: The control pulse</li><li><code>initial::Vector</code>: Initial state |œà‚ÇÄ‚ü©</li><li><code>goal::Vector</code>: Target state |œà_goal‚ü©</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>algorithm</code>: ODE solver algorithm (default: MagnusGL4())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/ket_trajectory.jl#L29-L42">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.KetTrajectory-Tuple{QuantumSystem, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, Real}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.KetTrajectory-Tuple{QuantumSystem, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, Real}"><code>Piccolo.Quantum.QuantumTrajectories.KetTrajectory</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KetTrajectory(system, initial, goal, T::Real; drive_name=:u, algorithm=MagnusGL4())</code></pre><p>Convenience constructor that creates a zero pulse of duration T.</p><p><strong>Arguments</strong></p><ul><li><code>system::QuantumSystem</code>: The quantum system</li><li><code>initial::Vector</code>: Initial state |œà‚ÇÄ‚ü©</li><li><code>goal::Vector</code>: Target state |œà_goal‚ü©</li><li><code>T::Real</code>: Duration of the pulse</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>drive_name::Symbol</code>: Name of the drive variable (default: <code>:u</code>)</li><li><code>algorithm</code>: ODE solver algorithm (default: MagnusGL4())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/ket_trajectory.jl#L61-L75">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory"><code>Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultiKetTrajectory{P&lt;:AbstractPulse, S} &lt;: AbstractQuantumTrajectory{P}</code></pre><p>Trajectory for multi-state transfer with a shared pulse. Useful for state-to-state problems with multiple initial/goal pairs.</p><p><strong>Fields</strong></p><ul><li><code>system::QuantumSystem</code>: The quantum system</li><li><code>pulse::P</code>: The shared control pulse</li><li><code>initials::Vector{Vector{ComplexF64}}</code>: Initial states</li><li><code>goals::Vector{Vector{ComplexF64}}</code>: Target states</li><li><code>weights::Vector{Float64}</code>: Weights for fidelity calculation</li><li><code>solution::S</code>: Pre-computed ensemble solution</li></ul><p><strong>Callable</strong></p><p><code>traj(t)</code> returns a vector of states at time <code>t</code>. <code>traj[i]</code> returns the i-th trajectory&#39;s solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/ensemble_trajectory.jl#L5-L22">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory-Tuple{QuantumSystem, AbstractPulse, Vector{&lt;:AbstractVector{&lt;:Number}}, Vector{&lt;:AbstractVector{&lt;:Number}}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory-Tuple{QuantumSystem, AbstractPulse, Vector{&lt;:AbstractVector{&lt;:Number}}, Vector{&lt;:AbstractVector{&lt;:Number}}}"><code>Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MultiKetTrajectory(system, pulse, initials, goals; weights=..., algorithm=MagnusGL4())</code></pre><p>Create a multi-ket trajectory by solving multiple Schr√∂dinger equations.</p><p><strong>Arguments</strong></p><ul><li><code>system::QuantumSystem</code>: The quantum system</li><li><code>pulse::AbstractPulse</code>: The shared control pulse</li><li><code>initials::Vector{Vector}</code>: Initial states</li><li><code>goals::Vector{Vector}</code>: Target states</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>weights</code>: Weights for fidelity (default: uniform)</li><li><code>algorithm</code>: ODE solver algorithm (default: MagnusGL4())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/ensemble_trajectory.jl#L32-L46">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory-Tuple{QuantumSystem, Vector{&lt;:AbstractVector{&lt;:Number}}, Vector{&lt;:AbstractVector{&lt;:Number}}, Real}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory-Tuple{QuantumSystem, Vector{&lt;:AbstractVector{&lt;:Number}}, Vector{&lt;:AbstractVector{&lt;:Number}}, Real}"><code>Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MultiKetTrajectory(system, initials, goals, T::Real; weights=..., drive_name=:u, algorithm=MagnusGL4())</code></pre><p>Convenience constructor that creates a zero pulse of duration T.</p><p><strong>Arguments</strong></p><ul><li><code>system::QuantumSystem</code>: The quantum system</li><li><code>initials::Vector{Vector}</code>: Initial states</li><li><code>goals::Vector{Vector}</code>: Target states</li><li><code>T::Real</code>: Duration of the pulse</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>weights</code>: Weights for fidelity (default: uniform)</li><li><code>drive_name::Symbol</code>: Name of the drive variable (default: <code>:u</code>)</li><li><code>algorithm</code>: ODE solver algorithm (default: MagnusGL4())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/ensemble_trajectory.jl#L74-L89">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.SamplingTrajectory"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.SamplingTrajectory"><code>Piccolo.Quantum.QuantumTrajectories.SamplingTrajectory</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SamplingTrajectory{QT&lt;:AbstractQuantumTrajectory} &lt;: AbstractQuantumTrajectory</code></pre><p>Wrapper for robust optimization over multiple systems with shared controls.</p><p>Used for sampling-based robust optimization where:</p><ul><li>All systems share the same control pulse</li><li>Each system has different dynamics (e.g., parameter variations)</li><li>Optimization minimizes weighted fidelity across all systems</li></ul><p>This type does NOT store a NamedTrajectory - use <code>NamedTrajectory(sampling, N)</code> for conversion.</p><p><strong>Fields</strong></p><ul><li><code>base_trajectory::QT</code>: Base quantum trajectory (defines pulse, initial, goal)</li><li><code>systems::Vector{&lt;:AbstractQuantumSystem}</code>: Multiple systems to optimize over</li><li><code>weights::Vector{Float64}</code>: Weights for each system in objective</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sys_nom = QuantumSystem(...)
sys_variations = [QuantumSystem(...) for _ in 1:3]  # Parameter variations
qtraj = UnitaryTrajectory(sys_nom, pulse, U_goal)
sampling = SamplingTrajectory(qtraj, sys_variations, [0.5, 0.3, 0.2])

# Convert to NamedTrajectory for optimization
traj = NamedTrajectory(sampling, 51)  # Creates :≈®‚Éó1, :≈®‚Éó2, :≈®‚Éó3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/sampling_trajectory.jl#L7-L34">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.SamplingTrajectory-Union{Tuple{QT}, Tuple{P}, Tuple{QT, Vector{&lt;:AbstractQuantumSystem}}} where {P&lt;:AbstractPulse, QT&lt;:AbstractQuantumTrajectory{P}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.SamplingTrajectory-Union{Tuple{QT}, Tuple{P}, Tuple{QT, Vector{&lt;:AbstractQuantumSystem}}} where {P&lt;:AbstractPulse, QT&lt;:AbstractQuantumTrajectory{P}}"><code>Piccolo.Quantum.QuantumTrajectories.SamplingTrajectory</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SamplingTrajectory(base_trajectory, systems; weights=nothing)</code></pre><p>Create a SamplingTrajectory for robust optimization.</p><p><strong>Arguments</strong></p><ul><li><code>base_trajectory</code>: Base quantum trajectory (defines pulse, initial, goal)</li><li><code>systems</code>: Vector of systems with parameter variations</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>weights</code>: Optional weights for each system (default: equal weights)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/sampling_trajectory.jl#L42-L53">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory"><code>Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnitaryTrajectory{P&lt;:AbstractPulse, S&lt;:ODESolution, G} &lt;: AbstractQuantumTrajectory{P}</code></pre><p>Trajectory for unitary gate synthesis. The ODE solution is computed at construction.</p><p><strong>Fields</strong></p><ul><li><code>system::QuantumSystem</code>: The quantum system</li><li><code>pulse::P</code>: The control pulse (stores drive_name)</li><li><code>initial::Matrix{ComplexF64}</code>: Initial unitary (default: identity)</li><li><code>goal::G</code>: Target unitary operator (AbstractPiccoloOperator or Matrix)</li><li><code>solution::S</code>: Pre-computed ODE solution</li></ul><p><strong>Callable</strong></p><p><code>traj(t)</code> returns the unitary at time <code>t</code> by interpolating the solution.</p><p><strong>Conversion to NamedTrajectory</strong></p><p>Use <code>NamedTrajectory(traj, N)</code> or <code>NamedTrajectory(traj, times)</code> for optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/unitary_trajectory.jl#L5-L22">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory-Union{Tuple{G}, Tuple{QuantumSystem, AbstractPulse, G}} where G"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory-Union{Tuple{G}, Tuple{QuantumSystem, AbstractPulse, G}} where G"><code>Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">UnitaryTrajectory(system, pulse, goal; initial=I, algorithm=MagnusGL4())</code></pre><p>Create a unitary trajectory by solving the Schr√∂dinger equation.</p><p><strong>Arguments</strong></p><ul><li><code>system::QuantumSystem</code>: The quantum system</li><li><code>pulse::AbstractPulse</code>: The control pulse</li><li><code>goal</code>: Target unitary (Matrix or AbstractPiccoloOperator)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>initial</code>: Initial unitary (default: identity matrix)</li><li><code>algorithm</code>: ODE solver algorithm (default: MagnusGL4())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/unitary_trajectory.jl#L32-L45">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory-Union{Tuple{G}, Tuple{QuantumSystem, G, Real}} where G"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory-Union{Tuple{G}, Tuple{QuantumSystem, G, Real}} where G"><code>Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">UnitaryTrajectory(system, goal, T::Real; drive_name=:u, algorithm=MagnusGL4())</code></pre><p>Convenience constructor that creates a zero pulse of duration T.</p><p><strong>Arguments</strong></p><ul><li><code>system::QuantumSystem</code>: The quantum system</li><li><code>goal</code>: Target unitary (Matrix or AbstractPiccoloOperator)</li><li><code>T::Real</code>: Duration of the pulse</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>drive_name::Symbol</code>: Name of the drive variable (default: <code>:u</code>)</li><li><code>algorithm</code>: ODE solver algorithm (default: MagnusGL4())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/unitary_trajectory.jl#L63-L76">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.drive_name-Tuple{AbstractQuantumTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.drive_name-Tuple{AbstractQuantumTrajectory}"><code>Piccolo.Quantum.Pulses.drive_name</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">drive_name(traj::AbstractQuantumTrajectory)</code></pre><p>Get the drive/control variable name from the trajectory&#39;s pulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L74-L78">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.duration-Tuple{AbstractQuantumTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.duration-Tuple{AbstractQuantumTrajectory}"><code>Piccolo.Quantum.Pulses.duration</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">duration(traj)</code></pre><p>Get the duration of a trajectory (from its pulse).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L95-L99">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories._add_global_data_to_kwargs-Tuple{Any, Any}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories._add_global_data_to_kwargs-Tuple{Any, Any}"><code>Piccolo.Quantum.QuantumTrajectories._add_global_data_to_kwargs</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_global_data_to_kwargs(nt_kwargs, global_data)</code></pre><p>Helper function to process global variables and add them to NamedTrajectory kwargs. Converts Dict{Symbol, Vector} to flat vector and components NamedTuple.</p><p><strong>Arguments</strong></p><ul><li><code>nt_kwargs</code>: Existing NamedTuple of kwargs to merge with</li><li><code>global_data</code>: Dict mapping global variable names to vectors of values</li></ul><p><strong>Returns</strong></p><p>Merged NamedTuple with global<em>data and global</em>components added</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/named_trajectory_conversion.jl#L52-L65">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories._get_control_data-Tuple{CubicSplinePulse, AbstractVector, AbstractQuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories._get_control_data-Tuple{CubicSplinePulse, AbstractVector, AbstractQuantumSystem}"><code>Piccolo.Quantum.QuantumTrajectories._get_control_data</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_control_data(pulse::CubicSplinePulse, times, sys)</code></pre><p>For CubicSplinePulse: return <code>u</code> and <code>du</code> data with system bounds and boundary conditions. Uses the pulse&#39;s drive_name to determine variable naming.</p><p>When <code>times</code> matches the pulse&#39;s native knot times, extracts stored <code>u</code> and <code>du</code> directly. When resampling to different times, samples <code>u</code> via interpolation and computes <code>du</code> via ForwardDiff to get the true spline derivative.</p><p><strong>Returns</strong></p><ul><li><code>data</code>: NamedTuple with control data</li><li><code>control_names</code>: Tuple of control variable names</li><li><code>bounds</code>: NamedTuple with control bounds</li><li><code>initial_constraints</code>: NamedTuple with initial value constraints</li><li><code>final_constraints</code>: NamedTuple with final value constraints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/named_trajectory_conversion.jl#L136-L152">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories._get_control_data-Tuple{GaussianPulse, AbstractVector, AbstractQuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories._get_control_data-Tuple{GaussianPulse, AbstractVector, AbstractQuantumSystem}"><code>Piccolo.Quantum.QuantumTrajectories._get_control_data</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_control_data(pulse::GaussianPulse, times, sys)</code></pre><p>For GaussianPulse: sample as u values with system bounds and boundary conditions. Uses the pulse&#39;s drive_name to determine variable naming.</p><p><strong>Returns</strong></p><ul><li><code>data</code>: NamedTuple with control data</li><li><code>control_names</code>: Tuple of control variable names</li><li><code>bounds</code>: NamedTuple with control bounds</li><li><code>initial_constraints</code>: NamedTuple with initial value constraints (empty for parametric pulses)</li><li><code>final_constraints</code>: NamedTuple with final value constraints (empty for parametric pulses)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/named_trajectory_conversion.jl#L211-L223">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories._get_control_data-Tuple{Union{LinearSplinePulse, ZeroOrderPulse}, AbstractVector, AbstractQuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories._get_control_data-Tuple{Union{LinearSplinePulse, ZeroOrderPulse}, AbstractVector, AbstractQuantumSystem}"><code>Piccolo.Quantum.QuantumTrajectories._get_control_data</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_control_data(pulse::Union{ZeroOrderPulse, LinearSplinePulse}, times, sys)</code></pre><p>For ZeroOrderPulse and LinearSplinePulse: return <code>u</code> data with system bounds and boundary conditions. Uses the pulse&#39;s drive_name to determine variable naming.</p><p><strong>Returns</strong></p><ul><li><code>data</code>: NamedTuple with control data</li><li><code>control_names</code>: Tuple of control variable names</li><li><code>bounds</code>: NamedTuple with control bounds</li><li><code>initial_constraints</code>: NamedTuple with initial value constraints</li><li><code>final_constraints</code>: NamedTuple with final value constraints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/named_trajectory_conversion.jl#L100-L112">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories._get_drive_bounds-Tuple{AbstractQuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories._get_drive_bounds-Tuple{AbstractQuantumSystem}"><code>Piccolo.Quantum.QuantumTrajectories._get_drive_bounds</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_drive_bounds(sys::QuantumSystem)</code></pre><p>Extract drive bounds from system as tuple of (lower, upper) vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/named_trajectory_conversion.jl#L88-L92">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories._named_tuple-Tuple{Vararg{Pair{Symbol}}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories._named_tuple-Tuple{Vararg{Pair{Symbol}}}"><code>Piccolo.Quantum.QuantumTrajectories._named_tuple</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_named_tuple(pairs...)</code></pre><p>Create a NamedTuple from pairs of (Symbol, value). This is needed when keys are  dynamic (stored in variables).</p><p>Example:     name = :x     <em>named</em>tuple(name =&gt; 1, :y =&gt; 2)  # Returns (x = 1, y = 2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/named_trajectory_conversion.jl#L5-L14">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories._sample_times-Tuple{Any, AbstractVector{&lt;:Real}}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories._sample_times-Tuple{Any, AbstractVector{&lt;:Real}}"><code>Piccolo.Quantum.QuantumTrajectories._sample_times</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_sample_times(traj, times::AbstractVector)</code></pre><p>Return times as a Float64 vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/named_trajectory_conversion.jl#L28-L32">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories._sample_times-Tuple{Any, Int64}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories._sample_times-Tuple{Any, Int64}"><code>Piccolo.Quantum.QuantumTrajectories._sample_times</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_sample_times(traj, N::Int)</code></pre><p>Generate N uniformly spaced times for sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/named_trajectory_conversion.jl#L21-L25">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories._sample_times-Tuple{Any, Nothing}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories._sample_times-Tuple{Any, Nothing}"><code>Piccolo.Quantum.QuantumTrajectories._sample_times</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_sample_times(traj, ::Nothing)</code></pre><p>For spline pulses, extract native knot times. For other pulses, error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/named_trajectory_conversion.jl#L35-L39">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.extract_pulse"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.extract_pulse"><code>Piccolo.Quantum.QuantumTrajectories.extract_pulse</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">extract_pulse(qtraj::AbstractQuantumTrajectory, traj::NamedTrajectory)</code></pre><p>Extract an optimized pulse from a NamedTrajectory.</p><p>This function extracts the control values from the optimized trajectory and creates a new pulse object of the same type as the original pulse in <code>qtraj</code>.</p><p>The extraction process depends on the pulse type:</p><ul><li><code>ZeroOrderPulse</code>, <code>LinearSplinePulse</code>: Extracts <code>u</code> (drive variable)</li><li><code>CubicSplinePulse</code>: Extracts both <code>u</code> and <code>du</code> (derivative variable)</li></ul><p><strong>Arguments</strong></p><ul><li><code>qtraj</code>: Original quantum trajectory (provides pulse type and drive names)</li><li><code>traj</code>: Optimized NamedTrajectory with new control values</li></ul><p><strong>Returns</strong></p><p>A new pulse of the same type as <code>qtraj.pulse</code> with optimized control values.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># After optimization
solve!(prob)
new_pulse = extract_pulse(qtraj, prob.trajectory)
rollout!(qtraj, new_pulse)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/extract_pulse.jl#L7-L33">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.get_goal-Tuple{UnitaryTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.get_goal-Tuple{UnitaryTrajectory}"><code>Piccolo.Quantum.QuantumTrajectories.get_goal</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_goal(traj)</code></pre><p>Get the goal state/operator from a trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L29-L33">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.get_initial-Tuple{UnitaryTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.get_initial-Tuple{UnitaryTrajectory}"><code>Piccolo.Quantum.QuantumTrajectories.get_initial</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_initial(traj)</code></pre><p>Get the initial state/operator from a trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L19-L23">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.get_pulse-Tuple{AbstractQuantumTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.get_pulse-Tuple{AbstractQuantumTrajectory}"><code>Piccolo.Quantum.QuantumTrajectories.get_pulse</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_pulse(traj)</code></pre><p>Get the control pulse from a trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L12-L16">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.get_solution-Tuple{AbstractQuantumTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.get_solution-Tuple{AbstractQuantumTrajectory}"><code>Piccolo.Quantum.QuantumTrajectories.get_solution</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_solution(traj)</code></pre><p>Get the ODE solution from a trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L39-L43">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.get_system-Tuple{AbstractQuantumTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.get_system-Tuple{AbstractQuantumTrajectory}"><code>Piccolo.Quantum.QuantumTrajectories.get_system</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_system(traj)</code></pre><p>Get the quantum system from a trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L5-L9">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.get_systems-Tuple{SamplingTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.get_systems-Tuple{SamplingTrajectory}"><code>Piccolo.Quantum.QuantumTrajectories.get_systems</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_systems(sampling::SamplingTrajectory)</code></pre><p>Get all systems in the sampling trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/sampling_trajectory.jl#L91-L95">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.get_weights-Tuple{SamplingTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.get_weights-Tuple{SamplingTrajectory}"><code>Piccolo.Quantum.QuantumTrajectories.get_weights</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_weights(sampling::SamplingTrajectory)</code></pre><p>Get the weights for each system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/sampling_trajectory.jl#L98-L102">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.state_name-Tuple{UnitaryTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.state_name-Tuple{UnitaryTrajectory}"><code>Piccolo.Quantum.QuantumTrajectories.state_name</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">state_name(::AbstractQuantumTrajectory)</code></pre><p>Get the fixed state variable name for a trajectory type.</p><ul><li><code>UnitaryTrajectory</code> ‚Üí <code>:≈®‚Éó</code></li><li><code>KetTrajectory</code> ‚Üí <code>:œàÃÉ</code></li><li><code>MultiKetTrajectory</code> ‚Üí <code>:œàÃÉ</code> (with index appended: <code>:œàÃÉ1</code>, <code>:œàÃÉ2</code>, etc.)</li><li><code>DensityTrajectory</code> ‚Üí <code>:œÅ‚ÉóÃÉ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L50-L58">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.state_names-Tuple{MultiKetTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.state_names-Tuple{MultiKetTrajectory}"><code>Piccolo.Quantum.QuantumTrajectories.state_names</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">state_names(traj::MultiKetTrajectory)</code></pre><p>Get all state names for an ensemble trajectory (<code>:œàÃÉ1</code>, <code>:œàÃÉ2</code>, etc.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L64-L68">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.state_names-Tuple{SamplingTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.state_names-Tuple{SamplingTrajectory}"><code>Piccolo.Quantum.QuantumTrajectories.state_names</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">state_names(sampling::SamplingTrajectory)</code></pre><p>Get the state variable names for all systems (e.g., [:≈®‚Éó1, :≈®‚Éó2, :≈®‚Éó3]).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/sampling_trajectory.jl#L81-L85">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.time_name-Tuple{AbstractQuantumTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.time_name-Tuple{AbstractQuantumTrajectory}"><code>Piccolo.Quantum.QuantumTrajectories.time_name</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">time_name(::AbstractQuantumTrajectory)</code></pre><p>Get the time variable name (always <code>:t</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L81-L85">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.timestep_name-Tuple{AbstractQuantumTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.timestep_name-Tuple{AbstractQuantumTrajectory}"><code>Piccolo.Quantum.QuantumTrajectories.timestep_name</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">timestep_name(::AbstractQuantumTrajectory)</code></pre><p>Get the timestep variable name (always <code>:Œît</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L88-L92">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts._update_system!-Tuple{DensityTrajectory, OpenQuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts._update_system!-Tuple{DensityTrajectory, OpenQuantumSystem}"><code>Piccolo.Quantum.Rollouts._update_system!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Rollouts._update_system!(qtraj::DensityTrajectory, sys::OpenQuantumSystem)</code></pre><p>Update the system field in a DensityTrajectory with a new OpenQuantumSystem (typically with updated global parameters after optimization).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L876-L881">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts._update_system!-Tuple{KetTrajectory, QuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts._update_system!-Tuple{KetTrajectory, QuantumSystem}"><code>Piccolo.Quantum.Rollouts._update_system!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Rollouts._update_system!(qtraj::KetTrajectory, sys::QuantumSystem)</code></pre><p>Update the system field in a KetTrajectory with a new QuantumSystem (typically with updated global parameters after optimization).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L854-L859">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts._update_system!-Tuple{MultiKetTrajectory, QuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts._update_system!-Tuple{MultiKetTrajectory, QuantumSystem}"><code>Piccolo.Quantum.Rollouts._update_system!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Rollouts._update_system!(qtraj::MultiKetTrajectory, sys::QuantumSystem)</code></pre><p>Update the system field in a MultiKetTrajectory with a new QuantumSystem (typically with updated global parameters after optimization).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L865-L870">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts._update_system!-Tuple{SamplingTrajectory, QuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts._update_system!-Tuple{SamplingTrajectory, QuantumSystem}"><code>Piccolo.Quantum.Rollouts._update_system!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Rollouts._update_system!(qtraj::SamplingTrajectory, sys::QuantumSystem)</code></pre><p>Update the system in the base_trajectory of a SamplingTrajectory. Note: This only updates the base trajectory&#39;s system, not the systems array. For updating parameter variations in the systems array, that should be done through the SamplingTrajectory constructor or direct modification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L887-L894">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts._update_system!-Tuple{UnitaryTrajectory, QuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts._update_system!-Tuple{UnitaryTrajectory, QuantumSystem}"><code>Piccolo.Quantum.Rollouts._update_system!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Rollouts._update_system!(qtraj::UnitaryTrajectory, sys::QuantumSystem)</code></pre><p>Update the system field in a UnitaryTrajectory with a new QuantumSystem (typically with updated global parameters after optimization).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L843-L848">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.fidelity-Tuple{DensityTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.fidelity-Tuple{DensityTrajectory}"><code>Piccolo.Quantum.Rollouts.fidelity</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fidelity(traj::DensityTrajectory)</code></pre><p>Compute the fidelity between the final density matrix and the goal. Uses trace fidelity: F = tr(œÅ<em>final * œÅ</em>goal)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L629-L634">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.fidelity-Tuple{KetTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.fidelity-Tuple{KetTrajectory}"><code>Piccolo.Quantum.Rollouts.fidelity</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fidelity(traj::KetTrajectory)</code></pre><p>Compute the fidelity between the final state and the goal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L607-L611">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.fidelity-Tuple{MultiKetTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.fidelity-Tuple{MultiKetTrajectory}"><code>Piccolo.Quantum.Rollouts.fidelity</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fidelity(traj::MultiKetTrajectory)</code></pre><p>Compute the weighted average fidelity across all state transfers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L617-L621">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.fidelity-Tuple{SamplingTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.fidelity-Tuple{SamplingTrajectory}"><code>Piccolo.Quantum.Rollouts.fidelity</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fidelity(traj::SamplingTrajectory; kwargs...)</code></pre><p>Compute the fidelity for each system in the sampling trajectory.</p><p>Returns a vector of fidelities, one per system, by rolling out the current pulse with each system and computing the fidelity against the goal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L640-L647">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.fidelity-Tuple{UnitaryTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.fidelity-Tuple{UnitaryTrajectory}"><code>Piccolo.Quantum.Rollouts.fidelity</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fidelity(traj::UnitaryTrajectory; subspace=nothing)</code></pre><p>Compute the fidelity between the final unitary and the goal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L589-L593">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout!-Tuple{DensityTrajectory, AbstractPulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout!-Tuple{DensityTrajectory, AbstractPulse}"><code>Piccolo.Quantum.Rollouts.rollout!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout!(qtraj::DensityTrajectory, pulse::AbstractPulse; algorithm=Tsit5(), n_points=101)</code></pre><p>Update density trajectory in-place with a new pulse. Note: Default algorithm is <code>Tsit5()</code> since density evolution uses standard ODE solvers. See <code>rollout!(::UnitaryTrajectory, ::AbstractPulse)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L285-L291">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout!-Tuple{DensityTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout!-Tuple{DensityTrajectory}"><code>Piccolo.Quantum.Rollouts.rollout!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout!(qtraj::DensityTrajectory; algorithm=Tsit5(), n_points=101, kwargs...)</code></pre><p>Update density trajectory in-place with same pulse but different ODE parameters. Note: Default algorithm is <code>Tsit5()</code> since density evolution uses standard ODE solvers. See <code>rollout!(::UnitaryTrajectory; kwargs...)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L307-L313">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout!-Tuple{KetTrajectory, AbstractPulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout!-Tuple{KetTrajectory, AbstractPulse}"><code>Piccolo.Quantum.Rollouts.rollout!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout!(qtraj::KetTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)</code></pre><p>Update ket trajectory in-place with a new pulse. See <code>rollout!(::UnitaryTrajectory, ::AbstractPulse)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L182-L187">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout!-Tuple{KetTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout!-Tuple{KetTrajectory}"><code>Piccolo.Quantum.Rollouts.rollout!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout!(qtraj::KetTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)</code></pre><p>Update ket trajectory in-place with same pulse but different ODE parameters. See <code>rollout!(::UnitaryTrajectory; kwargs...)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L203-L208">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout!-Tuple{MultiKetTrajectory, AbstractPulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout!-Tuple{MultiKetTrajectory, AbstractPulse}"><code>Piccolo.Quantum.Rollouts.rollout!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout!(qtraj::MultiKetTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)</code></pre><p>Update multi-ket trajectory in-place with a new pulse. See <code>rollout!(::UnitaryTrajectory, ::AbstractPulse)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L223-L228">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout!-Tuple{MultiKetTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout!-Tuple{MultiKetTrajectory}"><code>Piccolo.Quantum.Rollouts.rollout!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout!(qtraj::MultiKetTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)</code></pre><p>Update multi-ket trajectory in-place with same pulse but different ODE parameters. See <code>rollout!(::UnitaryTrajectory; kwargs...)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L254-L259">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout!-Tuple{SamplingTrajectory, AbstractPulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout!-Tuple{SamplingTrajectory, AbstractPulse}"><code>Piccolo.Quantum.Rollouts.rollout!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout!(qtraj::SamplingTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)</code></pre><p>Update sampling trajectory&#39;s base trajectory in-place with a new pulse. Delegates to the base trajectory&#39;s rollout! method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L328-L333">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout!-Tuple{SamplingTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout!-Tuple{SamplingTrajectory}"><code>Piccolo.Quantum.Rollouts.rollout!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout!(qtraj::SamplingTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)</code></pre><p>Update sampling trajectory&#39;s base trajectory in-place with new ODE parameters. Delegates to the base trajectory&#39;s rollout! method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L344-L349">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout!-Tuple{UnitaryTrajectory, AbstractPulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout!-Tuple{UnitaryTrajectory, AbstractPulse}"><code>Piccolo.Quantum.Rollouts.rollout!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout!(qtraj::UnitaryTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)</code></pre><p>Update quantum trajectory in-place with a new pulse by re-solving the ODE. Mutates <code>qtraj.pulse</code> and <code>qtraj.solution</code>.</p><p><strong>Arguments</strong></p><ul><li><code>qtraj::UnitaryTrajectory</code>: The trajectory to update</li><li><code>pulse::AbstractPulse</code>: The new control pulse</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>algorithm</code>: ODE solver algorithm (default: <code>MagnusGL4()</code>)</li><li><code>n_points::Int</code>: Number of time points to sample (default: 101)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">qtraj = UnitaryTrajectory(sys, old_pulse, goal)
rollout!(qtraj, new_pulse)  # Updates qtraj in-place
fid = fidelity(qtraj)  # Uses new solution</code></pre><p>See also: <code>rollout</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L106-L128">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout!-Tuple{UnitaryTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout!-Tuple{UnitaryTrajectory}"><code>Piccolo.Quantum.Rollouts.rollout!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout!(qtraj::UnitaryTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)</code></pre><p>Update quantum trajectory in-place by re-solving with same pulse but different ODE parameters. Mutates <code>qtraj.solution</code>.</p><p>Useful for comparing different solvers or tolerances.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>algorithm</code>: ODE solver algorithm (default: <code>MagnusGL4()</code>)</li><li><code>n_points::Int</code>: Number of time points to sample (default: 101)</li><li>Additional kwargs passed to <code>solve</code> (e.g., <code>abstol</code>, <code>reltol</code>)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">qtraj = UnitaryTrajectory(sys, pulse, goal)

# Compare Magnus vs Runge-Kutta
rollout!(qtraj; algorithm=Tsit5(), abstol=1e-10)
fid_rk = fidelity(qtraj)</code></pre><p>See also: <code>rollout</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L144-L167">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout-Tuple{DensityTrajectory, AbstractPulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout-Tuple{DensityTrajectory, AbstractPulse}"><code>Piccolo.Quantum.Rollouts.rollout</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout(qtraj::DensityTrajectory, pulse::AbstractPulse; algorithm=Tsit5(), n_points=101)</code></pre><p>Create a new density trajectory by rolling out a new pulse. Note: Default algorithm is <code>Tsit5()</code> since density evolution uses standard ODE solvers. See <code>rollout(::UnitaryTrajectory, ::AbstractPulse)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L453-L459">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout-Tuple{DensityTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout-Tuple{DensityTrajectory}"><code>Piccolo.Quantum.Rollouts.rollout</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout(qtraj::DensityTrajectory; algorithm=Tsit5(), n_points=101, kwargs...)</code></pre><p>Re-solve density trajectory with same pulse but different ODE parameters. Note: Default algorithm is <code>Tsit5()</code> since density evolution uses standard ODE solvers. See <code>rollout(::UnitaryTrajectory; kwargs...)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L566-L572">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout-Tuple{KetTrajectory, AbstractPulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout-Tuple{KetTrajectory, AbstractPulse}"><code>Piccolo.Quantum.Rollouts.rollout</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout(qtraj::KetTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)</code></pre><p>Create a new ket trajectory by rolling out a new pulse. See <code>rollout(::UnitaryTrajectory, ::AbstractPulse)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L399-L404">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout-Tuple{KetTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout-Tuple{KetTrajectory}"><code>Piccolo.Quantum.Rollouts.rollout</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout(qtraj::KetTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)</code></pre><p>Re-solve ket trajectory with same pulse but different ODE parameters. See <code>rollout(::UnitaryTrajectory; kwargs...)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L511-L516">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout-Tuple{MultiKetTrajectory, AbstractPulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout-Tuple{MultiKetTrajectory, AbstractPulse}"><code>Piccolo.Quantum.Rollouts.rollout</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout(qtraj::MultiKetTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)</code></pre><p>Create a new multi-ket trajectory by rolling out a new pulse. See <code>rollout(::UnitaryTrajectory, ::AbstractPulse)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L417-L422">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout-Tuple{MultiKetTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout-Tuple{MultiKetTrajectory}"><code>Piccolo.Quantum.Rollouts.rollout</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout(qtraj::MultiKetTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)</code></pre><p>Re-solve multi-ket trajectory with same pulse but different ODE parameters. See <code>rollout(::UnitaryTrajectory; kwargs...)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L529-L534">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout-Tuple{UnitaryTrajectory, AbstractPulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout-Tuple{UnitaryTrajectory, AbstractPulse}"><code>Piccolo.Quantum.Rollouts.rollout</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout(qtraj::UnitaryTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)</code></pre><p>Create a new quantum trajectory by rolling out a new pulse through the system. Returns a new UnitaryTrajectory with the updated pulse and solution.</p><p><strong>Arguments</strong></p><ul><li><code>qtraj::UnitaryTrajectory</code>: The base trajectory (provides system, initial, goal)</li><li><code>pulse::AbstractPulse</code>: The new control pulse to roll out</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>algorithm</code>: ODE solver algorithm (default: <code>MagnusGL4()</code>)</li><li><code>n_points::Int</code>: Number of time points to sample (default: 101)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">qtraj = UnitaryTrajectory(sys, old_pulse, goal)

# Roll out a new pulse
qtraj_new = rollout(qtraj, new_pulse)

# Check fidelity
fid = fidelity(qtraj_new)</code></pre><p>See also: <code>extract_pulse</code>, <code>rollout!</code>, <code>fidelity</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L360-L386">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout-Tuple{UnitaryTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout-Tuple{UnitaryTrajectory}"><code>Piccolo.Quantum.Rollouts.rollout</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rollout(qtraj::UnitaryTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)</code></pre><p>Re-solve the trajectory with the same pulse but different ODE parameters. Returns a new UnitaryTrajectory with the updated solution.</p><p>Useful for comparing different solvers or tolerances.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>algorithm</code>: ODE solver algorithm (default: <code>MagnusGL4()</code>)</li><li><code>n_points::Int</code>: Number of time points to sample (default: 101)</li><li>Additional kwargs passed to <code>solve</code> (e.g., <code>abstol</code>, <code>reltol</code>)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">qtraj = UnitaryTrajectory(sys, pulse, goal)

# Compare Magnus vs Runge-Kutta
qtraj_rk = rollout(qtraj; algorithm=Tsit5(), abstol=1e-10)
fid_magnus = fidelity(qtraj)
fid_rk = fidelity(qtraj_rk)</code></pre><p>See also: <a href="#Piccolo.Quantum.Rollouts.rollout!"><code>rollout!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/trajectories/interface.jl#L474-L498">source</a></section></details></article><h2 id="lib-pulses"><a class="docs-heading-anchor" href="#lib-pulses">Pulses</a><a id="lib-pulses-1"></a><a class="docs-heading-anchor-permalink" href="#lib-pulses" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.AbstractPulse"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.AbstractPulse"><code>Piccolo.Quantum.Pulses.AbstractPulse</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractPulse</code></pre><p>Abstract type for all pulse types. All pulses are callable: <code>pulse(t)</code> returns the control vector at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L32-L37">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.AbstractSplinePulse"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.AbstractSplinePulse"><code>Piccolo.Quantum.Pulses.AbstractSplinePulse</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractSplinePulse &lt;: AbstractPulse</code></pre><p>Abstract type for spline-based pulses (linear and cubic interpolation). These pulses use the spline coefficients as optimization variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L40-L45">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.CompositePulse"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.CompositePulse"><code>Piccolo.Quantum.Pulses.CompositePulse</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CompositePulse(pulses::Vector{&lt;:AbstractPulse}, mode::Symbol=:interleave)</code></pre><p>Create a composite pulse from multiple component pulses.</p><p><strong>Arguments</strong></p><ul><li><code>pulses</code>: Vector of pulse objects to combine</li><li><code>mode</code>: How to combine the drives<ul><li><code>:interleave</code> - Interleave drives: [p1<em>d1, p2</em>d1, p1<em>d2, p2</em>d2, ...]</li><li><code>:concatenate</code> - Concatenate drives: [p1<em>d1, p1</em>d2, ..., p2<em>d1, p2</em>d2, ...]</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># For MS gate with 2 ions: [Œ©‚ÇÅ, œÜ‚ÇÅ, Œ©‚ÇÇ, œÜ‚ÇÇ]
Œ©_pulse = GaussianPulse([Œ©‚ÇÅ, Œ©‚ÇÇ], œÉ, T)  # 2 drives
œÜ_pulse = ErfPulse([œÜ‚ÇÅ, œÜ‚ÇÇ], œÉ, T)        # 2 drives
pulse = CompositePulse([Œ©_pulse, œÜ_pulse], :interleave)
# Result: pulse(t) = [Œ©‚ÇÅ(t), œÜ‚ÇÅ(t), Œ©‚ÇÇ(t), œÜ‚ÇÇ(t)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L708-L727">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.CompositePulse"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.CompositePulse"><code>Piccolo.Quantum.Pulses.CompositePulse</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CompositePulse{F&lt;:Function} &lt;: AbstractPulse</code></pre><p>Composite pulse that combines multiple pulse objects by interleaving their drives.</p><p>Useful for creating pulses with different shapes for different control types, such as Gaussian amplitude + erf phase for trapped ion gates.</p><p><strong>Fields</strong></p><ul><li><code>f::F</code>: Function that evaluates the composite pulse</li><li><code>pulses::Vector{&lt;:AbstractPulse}</code>: Component pulses</li><li><code>drive_mapping::Vector{Vector{Int}}</code>: Maps pulse i, drive j to composite drive index</li><li><code>duration::Float64</code>: Total pulse duration (must match for all components)</li><li><code>n_drives::Int</code>: Total number of drives across all pulses</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Amplitude: Gaussian (2 drives for 2 ions)
Œ©_pulse = GaussianPulse([Œ©_max, Œ©_max], œÉ, T)

# Phase: Error function (2 drives for 2 ions)
œÜ_pulse = ErfPulse([œÜ_max, œÜ_max], œÉ, T)

# Composite: [Œ©‚ÇÅ, œÜ‚ÇÅ, Œ©‚ÇÇ, œÜ‚ÇÇ] - interleaved
pulse = CompositePulse([Œ©_pulse, œÜ_pulse], :interleave)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L673-L699">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.CubicSplinePulse"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.CubicSplinePulse"><code>Piccolo.Quantum.Pulses.CubicSplinePulse</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CubicSplinePulse{I&lt;:CubicHermiteSpline} &lt;: AbstractPulse</code></pre><p>Pulse with cubic Hermite spline interpolation. Uses both control values AND  derivatives for exact reconstruction after optimization.</p><p><strong>Fields</strong></p><ul><li><code>controls::I</code>: CubicHermiteSpline from DataInterpolations</li><li><code>duration::Float64</code>: Total pulse duration</li><li><code>n_drives::Int</code>: Number of control drives</li><li><code>drive_name::Symbol</code>: Name of the drive variable (default <code>:u</code>)</li><li><code>initial_value::Vector{Float64}</code>: Initial boundary condition (default: zeros)</li><li><code>final_value::Vector{Float64}</code>: Final boundary condition (default: zeros)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L224-L237">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector}"><code>Piccolo.Quantum.Pulses.CubicSplinePulse</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CubicSplinePulse(controls::AbstractMatrix, derivatives::AbstractMatrix, times::AbstractVector; drive_name=:u, initial_value=nothing, final_value=nothing)</code></pre><p>Create a cubic Hermite spline pulse from control values, derivatives, and times.</p><p><strong>Arguments</strong></p><ul><li><code>controls</code>: Matrix of size <code>(n_drives, n_times)</code> with control values</li><li><code>derivatives</code>: Matrix of size <code>(n_drives, n_times)</code> with control derivatives</li><li><code>times</code>: Vector of sample times (must start at 0)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>drive_name</code>: Name of the drive variable (default <code>:u</code>)</li><li><code>initial_value</code>: Initial boundary condition (default: zeros(n_drives))</li><li><code>final_value</code>: Final boundary condition (default: zeros(n_drives))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L247-L261">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{AbstractMatrix, AbstractVector}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{AbstractMatrix, AbstractVector}"><code>Piccolo.Quantum.Pulses.CubicSplinePulse</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CubicSplinePulse(controls::AbstractMatrix, times::AbstractVector; drive_name=:u, initial_value=nothing, final_value=nothing)</code></pre><p>Create a cubic Hermite spline pulse with zero derivatives at all knot points. Useful for initial guesses where smoothness constraints will be enforced by optimizer.</p><p><strong>Arguments</strong></p><ul><li><code>controls</code>: Matrix of size <code>(n_drives, n_times)</code> with control values</li><li><code>times</code>: Vector of sample times (must start at 0)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>drive_name</code>: Name of the drive variable (default <code>:u</code>)</li><li><code>initial_value</code>: Initial boundary condition (default: zeros(n_drives))</li><li><code>final_value</code>: Final boundary condition (default: zeros(n_drives))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L285-L299">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{AbstractPulse, Int64}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{AbstractPulse, Int64}"><code>Piccolo.Quantum.Pulses.CubicSplinePulse</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CubicSplinePulse(pulse::AbstractPulse, n_samples::Int; kwargs...)
CubicSplinePulse(pulse::AbstractPulse, times::AbstractVector; kwargs...)</code></pre><p>Convert any pulse to a CubicSplinePulse by sampling at specified times. Derivatives are computed using ForwardDiff for automatic differentiation.</p><p>Useful for initializing optimization problems with smooth analytic pulse shapes.</p><p><strong>Arguments</strong></p><ul><li><code>pulse</code>: Source pulse (GaussianPulse, ErfPulse, CompositePulse, etc.)</li><li><code>n_samples</code>: Number of uniformly spaced samples (alternative to <code>times</code>)</li><li><code>times</code>: Specific sample times (alternative to <code>n_samples</code>)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>drive_name</code>: Name for the drive variable (default: <code>:du</code>)</li><li><code>initial_value</code>: Initial boundary condition (default: pulse(0.0))</li><li><code>final_value</code>: Final boundary condition (default: pulse(duration))</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">gaussian = GaussianPulse([1.0, 2.0], 0.1, 1.0)
cubic = CubicSplinePulse(gaussian, 50)  # 50 samples with ForwardDiff derivatives</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L415-L439">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{NamedTrajectory}"><code>Piccolo.Quantum.Pulses.CubicSplinePulse</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CubicSplinePulse(traj::NamedTrajectory; drive_name=:u, derivative_name=:du)</code></pre><p>Construct a CubicSplinePulse (Hermite) from a NamedTrajectory using both  control values and derivatives.</p><p><strong>Arguments</strong></p><ul><li><code>traj</code>: NamedTrajectory with control and derivative data</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>drive_name</code>: Name of the drive component (default: <code>:u</code>)</li><li><code>derivative_name</code>: Name of the derivative component (default: <code>:du</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L837-L849">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.ErfPulse"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.ErfPulse"><code>Piccolo.Quantum.Pulses.ErfPulse</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ErfPulse{F&lt;:Function} &lt;: AbstractPulse</code></pre><p>Analytic error function pulse for phase compensation in trapped ion gates.</p><p>The error function profile is commonly used to compensate AC Stark shifts in  M√∏lmer-S√∏rensen gates, where œÜ(t) ‚àù erf(‚àö2 (t - t‚ÇÄ)/œÉ) cancels time-varying phases from off-resonant spectator modes.</p><pre><code class="language-julia hljs">u_i(t) = amplitudes[i] * erf(‚àö2 * (t - centers[i]) / sigmas[i])</code></pre><p>Typically scaled to range [0, 1] or [-1, 1] by adjusting amplitude.</p><p><strong>Fields</strong></p><ul><li><code>f::F</code>: Function that evaluates the pulse</li><li><code>amplitudes::Vector{Float64}</code>: Peak amplitude for each drive</li><li><code>sigmas::Vector{Float64}</code>: Width parameter for each drive</li><li><code>centers::Vector{Float64}</code>: Center time for each drive</li><li><code>duration::Float64</code>: Total pulse duration</li><li><code>n_drives::Int</code>: Number of control drives</li></ul><p><strong>References</strong></p><ul><li>Mizrahi et al., &quot;Realization and Calibration of Continuously Parameterized  Two-Qubit Gates...&quot;, IEEE TQE (2024), Figure 7b</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L568-L592">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.ErfPulse-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Real}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.ErfPulse-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Real}"><code>Piccolo.Quantum.Pulses.ErfPulse</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ErfPulse(amplitudes, sigmas, centers, duration)</code></pre><p>Create an error function pulse with per-drive parameters.</p><p><strong>Arguments</strong></p><ul><li><code>amplitudes</code>: Peak amplitude for each drive</li><li><code>sigmas</code>: Width parameter for each drive (controls steepness)</li><li><code>centers</code>: Center time for each drive (inflection point)</li><li><code>duration</code>: Total pulse duration</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using SpecialFunctions: erf

# Phase compensation for MS gate
œÜ_max = œÄ/4  # Maximum phase shift
T = 50.0     # Gate duration
œÉ = T/4      # Width parameter

pulse = ErfPulse([œÜ_max], [œÉ], [T/2], T)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L602-L624">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.ErfPulse-Tuple{AbstractVector{&lt;:Real}, Real, Real}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.ErfPulse-Tuple{AbstractVector{&lt;:Real}, Real, Real}"><code>Piccolo.Quantum.Pulses.ErfPulse</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ErfPulse(amplitudes, sigma, duration; center=duration/2)</code></pre><p>Create an error function pulse with shared sigma and center across all drives.</p><p><strong>Arguments</strong></p><ul><li><code>amplitudes</code>: Peak amplitude for each drive</li><li><code>sigma</code>: Shared width parameter for all drives</li><li><code>duration</code>: Total pulse duration</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>center</code>: Shared center time (default: <code>duration/2</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L644-L656">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.GaussianPulse"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.GaussianPulse"><code>Piccolo.Quantum.Pulses.GaussianPulse</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GaussianPulse{F&lt;:Function} &lt;: AbstractPulse</code></pre><p>Analytic Gaussian pulse. Each drive has its own amplitude, width (sigma), and center.</p><pre><code class="language-julia hljs">u_i(t) = amplitudes[i] * exp(-(t - centers[i])¬≤ / (2 * sigmas[i]¬≤))</code></pre><p><strong>Fields</strong></p><ul><li><code>f::F</code>: Function that evaluates the pulse</li><li><code>amplitudes::Vector{Float64}</code>: Peak amplitude for each drive</li><li><code>sigmas::Vector{Float64}</code>: Gaussian width for each drive</li><li><code>centers::Vector{Float64}</code>: Center time for each drive</li><li><code>duration::Float64</code>: Total pulse duration</li><li><code>n_drives::Int</code>: Number of control drives</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L480-L494">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.GaussianPulse-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Real}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.GaussianPulse-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Real}"><code>Piccolo.Quantum.Pulses.GaussianPulse</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">GaussianPulse(amplitudes, sigmas, centers, duration)</code></pre><p>Create a Gaussian pulse with per-drive parameters.</p><p><strong>Arguments</strong></p><ul><li><code>amplitudes</code>: Peak amplitude for each drive</li><li><code>sigmas</code>: Gaussian width (standard deviation) for each drive</li><li><code>centers</code>: Center time for each drive</li><li><code>duration</code>: Total pulse duration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L504-L514">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.GaussianPulse-Tuple{AbstractVector{&lt;:Real}, Real, Real}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.GaussianPulse-Tuple{AbstractVector{&lt;:Real}, Real, Real}"><code>Piccolo.Quantum.Pulses.GaussianPulse</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">GaussianPulse(amplitudes, sigma, duration; center=duration/2)</code></pre><p>Create a Gaussian pulse with shared sigma and center across all drives.</p><p><strong>Arguments</strong></p><ul><li><code>amplitudes</code>: Peak amplitude for each drive</li><li><code>sigma</code>: Shared Gaussian width for all drives</li><li><code>duration</code>: Total pulse duration</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>center</code>: Shared center time (default: <code>duration/2</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L534-L546">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.LinearSplinePulse"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.LinearSplinePulse"><code>Piccolo.Quantum.Pulses.LinearSplinePulse</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearSplinePulse{I&lt;:LinearInterpolation} &lt;: AbstractSplinePulse</code></pre><p>Pulse with linear interpolation between sample points.</p><p><strong>Fields</strong></p><ul><li><code>controls::I</code>: LinearInterpolation from DataInterpolations</li><li><code>duration::Float64</code>: Total pulse duration</li><li><code>n_drives::Int</code>: Number of control drives</li><li><code>drive_name::Symbol</code>: Name of the drive variable (default <code>:u</code>)</li><li><code>initial_value::Vector{Float64}</code>: Initial boundary condition (default: zeros)</li><li><code>final_value::Vector{Float64}</code>: Final boundary condition (default: zeros)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L160-L172">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.LinearSplinePulse-Tuple{AbstractMatrix, AbstractVector}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.LinearSplinePulse-Tuple{AbstractMatrix, AbstractVector}"><code>Piccolo.Quantum.Pulses.LinearSplinePulse</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LinearSplinePulse(controls::AbstractMatrix, times::AbstractVector; drive_name=:u, initial_value=nothing, final_value=nothing)</code></pre><p>Create a linearly interpolated pulse from control samples and times.</p><p><strong>Arguments</strong></p><ul><li><code>controls</code>: Matrix of size <code>(n_drives, n_times)</code> with control values</li><li><code>times</code>: Vector of sample times (must start at 0)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>drive_name</code>: Name of the drive variable (default <code>:u</code>)</li><li><code>initial_value</code>: Initial boundary condition (default: zeros(n_drives))</li><li><code>final_value</code>: Final boundary condition (default: zeros(n_drives))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L182-L195">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.LinearSplinePulse-Tuple{AbstractPulse, Int64}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.LinearSplinePulse-Tuple{AbstractPulse, Int64}"><code>Piccolo.Quantum.Pulses.LinearSplinePulse</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LinearSplinePulse(pulse::AbstractPulse, n_samples::Int; kwargs...)
LinearSplinePulse(pulse::AbstractPulse, times::AbstractVector; kwargs...)</code></pre><p>Convert any pulse to a LinearSplinePulse by sampling at specified times.</p><p>Useful for initializing optimization problems with analytic pulse shapes.</p><p><strong>Arguments</strong></p><ul><li><code>pulse</code>: Source pulse (GaussianPulse, ErfPulse, CompositePulse, etc.)</li><li><code>n_samples</code>: Number of uniformly spaced samples (alternative to <code>times</code>)</li><li><code>times</code>: Specific sample times (alternative to <code>n_samples</code>)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>drive_name</code>: Name for the drive variable (default: <code>:u</code>)</li><li><code>initial_value</code>: Initial boundary condition (default: pulse(0.0))</li><li><code>final_value</code>: Final boundary condition (default: pulse(duration))</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">gaussian = GaussianPulse([1.0, 2.0], 0.1, 1.0)
linear = LinearSplinePulse(gaussian, 50)  # 50 samples</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L361-L384">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.LinearSplinePulse-Tuple{NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.LinearSplinePulse-Tuple{NamedTrajectory}"><code>Piccolo.Quantum.Pulses.LinearSplinePulse</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LinearSplinePulse(traj::NamedTrajectory; drive_name=:u)</code></pre><p>Construct a LinearSplinePulse from a NamedTrajectory.</p><p><strong>Arguments</strong></p><ul><li><code>traj</code>: NamedTrajectory with control data</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>drive_name</code>: Name of the drive component (default: <code>:u</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L820-L830">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.ZeroOrderPulse"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.ZeroOrderPulse"><code>Piccolo.Quantum.Pulses.ZeroOrderPulse</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ZeroOrderPulse{I&lt;:ConstantInterpolation} &lt;: AbstractPulse</code></pre><p>Piecewise constant pulse (zero-order hold). The control value at time <code>t</code> is the value at the most recent sample point.</p><p><strong>Fields</strong></p><ul><li><code>controls::I</code>: ConstantInterpolation from DataInterpolations</li><li><code>duration::Float64</code>: Total pulse duration</li><li><code>n_drives::Int</code>: Number of control drives</li><li><code>drive_name::Symbol</code>: Name of the drive variable (default <code>:u</code>)</li><li><code>initial_value::Vector{Float64}</code>: Initial boundary condition (default: zeros)</li><li><code>final_value::Vector{Float64}</code>: Final boundary condition (default: zeros)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L95-L108">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.ZeroOrderPulse-Tuple{AbstractMatrix, AbstractVector}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.ZeroOrderPulse-Tuple{AbstractMatrix, AbstractVector}"><code>Piccolo.Quantum.Pulses.ZeroOrderPulse</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ZeroOrderPulse(controls::AbstractMatrix, times::AbstractVector; drive_name=:u, initial_value=nothing, final_value=nothing)</code></pre><p>Create a zero-order hold pulse from control samples and times.</p><p><strong>Arguments</strong></p><ul><li><code>controls</code>: Matrix of size <code>(n_drives, n_times)</code> with control values</li><li><code>times</code>: Vector of sample times (must start at 0)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>drive_name</code>: Name of the drive variable (default <code>:u</code>)</li><li><code>initial_value</code>: Initial boundary condition (default: zeros(n_drives))</li><li><code>final_value</code>: Final boundary condition (default: zeros(n_drives))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L118-L131">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.ZeroOrderPulse-Tuple{NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.ZeroOrderPulse-Tuple{NamedTrajectory}"><code>Piccolo.Quantum.Pulses.ZeroOrderPulse</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ZeroOrderPulse(traj::NamedTrajectory; drive_name=:u)</code></pre><p>Construct a ZeroOrderPulse from a NamedTrajectory.</p><p><strong>Arguments</strong></p><ul><li><code>traj</code>: NamedTrajectory with control data</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>drive_name</code>: Name of the drive component (default: <code>:u</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L803-L813">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.drive_name-Tuple{AbstractPulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.drive_name-Tuple{AbstractPulse}"><code>Piccolo.Quantum.Pulses.drive_name</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">drive_name(pulse::AbstractPulse)</code></pre><p>Return the name of the drive variable for this pulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L65-L69">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.duration-Tuple{AbstractPulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.duration-Tuple{AbstractPulse}"><code>Piccolo.Quantum.Pulses.duration</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">duration(pulse::AbstractPulse)</code></pre><p>Return the duration of the pulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L51-L55">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.get_knot_count-Tuple{AbstractSplinePulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.get_knot_count-Tuple{AbstractSplinePulse}"><code>Piccolo.Quantum.Pulses.get_knot_count</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_knot_count(pulse::AbstractSplinePulse)</code></pre><p>Return the number of knots in the spline pulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L332-L336">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.get_knot_derivatives-Tuple{CubicSplinePulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.get_knot_derivatives-Tuple{CubicSplinePulse}"><code>Piccolo.Quantum.Pulses.get_knot_derivatives</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_knot_derivatives(pulse::CubicSplinePulse)</code></pre><p>Return the Hermite tangents at knot points (the <code>du</code> matrix). Only available for CubicSplinePulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L347-L352">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.get_knot_times-Tuple{LinearSplinePulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.get_knot_times-Tuple{LinearSplinePulse}"><code>Piccolo.Quantum.Pulses.get_knot_times</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_knot_times(pulse::AbstractSplinePulse)</code></pre><p>Return the knot times stored in the spline pulse interpolant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L324-L328">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.get_knot_values-Tuple{LinearSplinePulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.get_knot_values-Tuple{LinearSplinePulse}"><code>Piccolo.Quantum.Pulses.get_knot_values</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_knot_values(pulse::CubicSplinePulse)</code></pre><p>Return the control values at knot points (the <code>u</code> matrix).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L339-L343">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.n_drives-Tuple{AbstractPulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.n_drives-Tuple{AbstractPulse}"><code>Piccolo.Quantum.Pulses.n_drives</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">n_drives(pulse::AbstractPulse)</code></pre><p>Return the number of control drives in the pulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L58-L62">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.sample-Tuple{AbstractPulse, AbstractVector}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.sample-Tuple{AbstractPulse, AbstractVector}"><code>Piccolo.Quantum.Pulses.sample</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sample(pulse::AbstractPulse, times::AbstractVector)</code></pre><p>Sample the pulse at the given times. Returns a matrix of size <code>(n_drives, length(times))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L72-L76">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.sample-Tuple{AbstractPulse}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.sample-Tuple{AbstractPulse}"><code>Piccolo.Quantum.Pulses.sample</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sample(pulse::AbstractPulse; n_samples::Int=100)</code></pre><p>Sample the pulse uniformly with <code>n_samples</code> points. Returns <code>(controls, times)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/pulses.jl#L81-L85">source</a></section></details></article><h2 id="lib-rollouts"><a class="docs-heading-anchor" href="#lib-rollouts">Rollouts</a><a id="lib-rollouts-1"></a><a class="docs-heading-anchor-permalink" href="#lib-rollouts" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts._update_system!"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts._update_system!"><code>Piccolo.Quantum.Rollouts._update_system!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_update_system!(qtraj, sys::QuantumSystem)</code></pre><p>Internal method to update the system field in a quantum trajectory. Extended in quantum_trajectories module for specific trajectory types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/dynamics.jl#L191-L196">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.extract_globals"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.extract_globals"><code>Piccolo.Quantum.Rollouts.extract_globals</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">extract_globals(traj::NamedTrajectory, names::Vector{Symbol}=Symbol[])</code></pre><p>Extract global variables from trajectory as a NamedTuple for easy access. If names is empty, extracts all global variables.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">traj = NamedTrajectory(...; global_data=[0.5, 1.0], global_components=(Œ¥=1:1, Œ©=2:2))
g = extract_globals(traj)  # (Œ¥ = 0.5, Œ© = 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/dynamics.jl#L199-L210">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.fidelity-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.fidelity-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}"><code>Piccolo.Quantum.Rollouts.fidelity</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fidelity(œÅ::AbstractMatrix{&lt;:Number}, œÅ_goal::AbstractMatrix{&lt;:Number})</code></pre><p>Calculate the fidelity between two density matrices <code>œÅ</code> and <code>œÅ_goal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/dynamics.jl#L248-L252">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.fidelity-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.fidelity-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>Piccolo.Quantum.Rollouts.fidelity</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fidelity(œà::AbstractVector{&lt;:Number}, œà_goal::AbstractVector{&lt;:Number})</code></pre><p>Calculate the fidelity between two quantum states <code>œà</code> and <code>œà_goal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/dynamics.jl#L239-L243">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout"><code>Piccolo.Quantum.Rollouts.rollout</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rollout(qtraj, args...; kwargs...)</code></pre><p>Roll out a quantum trajectory with new pulse or ODE parameters. Extended in quantum_trajectories module for specific trajectory types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/dynamics.jl#L85-L90">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.rollout!"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.rollout!"><code>Piccolo.Quantum.Rollouts.rollout!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rollout!(qtraj, args...; kwargs...)</code></pre><p>In-place rollout of quantum trajectory with new pulse or ODE parameters. Extended in quantum_trajectories module for specific trajectory types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/dynamics.jl#L93-L98">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.unitary_fidelity-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.unitary_fidelity-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}"><code>Piccolo.Quantum.Rollouts.unitary_fidelity</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unitary_fidelity(U::AbstractMatrix{&lt;:Number}, U_goal::AbstractMatrix{&lt;:Number})</code></pre><p>Calculate the fidelity between unitary operators <code>U</code> and <code>U_goal</code> in the <code>subspace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/dynamics.jl#L257-L261">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.update_global_params!-Tuple{Any, Any}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.update_global_params!-Tuple{Any, Any}"><code>Piccolo.Quantum.Rollouts.update_global_params!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_global_params!(qtraj, traj::NamedTrajectory)</code></pre><p>Update the global parameters in the quantum trajectory&#39;s system with the optimized values from the NamedTrajectory after optimization. Handles immutable QuantumSystem by reconstructing with updated global_params NamedTuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/dynamics.jl#L101-L107">source</a></section></details></article><h2 id="lib-embedded-operators"><a class="docs-heading-anchor" href="#lib-embedded-operators">Embedded Operators</a><a id="lib-embedded-operators-1"></a><a class="docs-heading-anchor-permalink" href="#lib-embedded-operators" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.AbstractPiccoloOperator"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.AbstractPiccoloOperator"><code>Piccolo.Quantum.EmbeddedOperators.AbstractPiccoloOperator</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractPiccoloOperator</code></pre><p>Union type for operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L94-L98">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator"><code>Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EmbeddedOperator</code></pre><p>Embedded operator type to represent an operator embedded in a subspace of a larger quantum system.</p><p><strong>Fields</strong></p><ul><li><code>operator::Matrix{&lt;:Number}</code>: Embedded operator of size   <code>prod(subsystem_levels) x prod(subsystem_levels)</code>.</li><li><code>subspace::Vector{Int}</code>: Indices of the subspace the operator is embedded in.</li><li><code>subsystem_levels::Vector{Int}</code>: Levels of the subsystems in the composite system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L57-L68">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{&lt;:Number}, AbstractVector{Int64}, AbstractVector{&lt;:AbstractVector{Int64}}, AbstractVector{Int64}}"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{&lt;:Number}, AbstractVector{Int64}, AbstractVector{&lt;:AbstractVector{Int64}}, AbstractVector{Int64}}"><code>Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EmbeddedOperator(
    subspace_operator::AbstractMatrix{&lt;:Number},
    subsystem_indices::AbstractVector{Int},
    subspaces::AbstractVector{&lt;:AbstractVector{Int}},
    subsystem_levels::AbstractVector{Int}
)</code></pre><p>Embed the <code>subspace_operator</code> into the provided <code>subspaces</code> of a composite system, where the <code>subsystem_indices</code> list the subspaces at which the operator is defined, and the <code>subsystem_levels</code> list the levels of the subsystems in which the operator is embedded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L141-L152">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{&lt;:Number}, AbstractVector{Int64}, AbstractVector{&lt;:AbstractVector{Int64}}, CompositeQuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{&lt;:Number}, AbstractVector{Int64}, AbstractVector{&lt;:AbstractVector{Int64}}, CompositeQuantumSystem}"><code>Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EmbeddedOperator(
    subspace_operator::AbstractMatrix{&lt;:Number},
    subsystem_indices::AbstractVector{Int},
    subspaces::AbstractVector{&lt;:AbstractVector{Int}},
    composite_system::CompositeQuantumSystem
)</code></pre><p>Embed the <code>subspace_operator</code> into the provided <code>subspaces</code> of a composite system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L167-L176">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{&lt;:Number}, QuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{&lt;:Number}, QuantumSystem}"><code>Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EmbeddedOperator(subspace_operator::AbstractMatrix{&lt;:Number}, system::QuantumSystem; kwargs...)</code></pre><p>Embed the <code>subspace_operator</code> into a quantum <code>system</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L111-L115">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{Int64}}} where T&lt;:Number"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{Int64}}} where T&lt;:Number"><code>Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EmbeddedOperator(subspace_operator::Matrix{&lt;:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})</code></pre><p>Create an embedded operator. The <code>operator</code> is embedded at the <code>subspace</code> of the system spanned by the <code>subsystem_levels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L74-L79">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.embed-Tuple{AbstractMatrix{&lt;:Number}, EmbeddedOperator}"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.embed-Tuple{AbstractMatrix{&lt;:Number}, EmbeddedOperator}"><code>Piccolo.Quantum.EmbeddedOperators.embed</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">embed(subspace_operator::AbstractMatrix{&lt;:Number}, embedded_operator::EmbeddedOperator)</code></pre><p>Embed the <code>subspace_operator</code> in the subspace of a larger <code>embedded_operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L195-L199">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.embed-Union{Tuple{R}, Tuple{AbstractMatrix{R}, AbstractVector{Int64}, Int64}} where R&lt;:Number"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.embed-Union{Tuple{R}, Tuple{AbstractMatrix{R}, AbstractVector{Int64}, Int64}} where R&lt;:Number"><code>Piccolo.Quantum.EmbeddedOperators.embed</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">embed(operator::AbstractMatrix{&lt;:Number}, subspace::AbstractVector{Int}, levels::Int)</code></pre><p>Embed an <code>operator</code> in the <code>subspace</code> of a larger matrix of size <code>levels x levels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L27-L31">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.get_enr_subspace_indices-Tuple{Int64, AbstractVector{Int64}}"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.get_enr_subspace_indices-Tuple{Int64, AbstractVector{Int64}}"><code>Piccolo.Quantum.EmbeddedOperators.get_enr_subspace_indices</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_enr_subspace_indices(excitation_restriction::Int, subsystem_levels::AbstractVector{Int})</code></pre><p>Get the indices for the subspace of the quantum system with an excitation restriction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L291-L295">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.get_iso_vec_leakage_indices"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.get_iso_vec_leakage_indices"><code>Piccolo.Quantum.EmbeddedOperators.get_iso_vec_leakage_indices</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_iso_vec_leakage_indices(subspace::AbstractVector{Int}, levels::Int)
get_iso_vec_leakage_indices(subspaces::AbstractVector{&lt;:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})
get_iso_vec_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)
get_iso_vec_leakage_indices(op::EmbeddedOperator)</code></pre><p>Get the indices for the leakage in the isomorphic vector space for operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L381-L388">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.get_iso_vec_subspace_indices"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.get_iso_vec_subspace_indices"><code>Piccolo.Quantum.EmbeddedOperators.get_iso_vec_subspace_indices</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})
get_iso_vec_subspace_indices(op::EmbeddedOperator)</code></pre><p>Get the indices for the subspace in the isomorphic vector space for operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L344-L349">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.get_leakage_indices"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.get_leakage_indices"><code>Piccolo.Quantum.EmbeddedOperators.get_leakage_indices</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_leakage_indices(subspace::AbstractVector{Int}, levels::Int)
get_leakage_indices(subspaces::AbstractVector{&lt;:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})
get_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)
get_leakage_indices(op::EmbeddedOperator)</code></pre><p>Get the indices for the states that are outside of the provided subspace of the quantum system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L311-L319">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.get_subspace_indices"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.get_subspace_indices"><code>Piccolo.Quantum.EmbeddedOperators.get_subspace_indices</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)
get_subspace_indices(subspaces::Vector{&lt;:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})
get_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)
get_subspace_indices(op::EmbeddedOperator)</code></pre><p>Get the indices for the provided subspace of the quantum system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L257-L264">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.unembed-Tuple{AbstractMatrix{&lt;:Number}, AbstractVector{Int64}}"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.unembed-Tuple{AbstractMatrix{&lt;:Number}, AbstractVector{Int64}}"><code>Piccolo.Quantum.EmbeddedOperators.unembed</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unembed(matrix::AbstractMatrix{&lt;:Number}, subspace::AbstractVector{Int})</code></pre><p>Unembed a subspace operator from the <code>matrix</code>. This is equivalent to calling <code>matrix[subspace, subspace]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L43-L48">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.unembed-Tuple{AbstractMatrix{&lt;:Number}, EmbeddedOperator}"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.unembed-Tuple{AbstractMatrix{&lt;:Number}, EmbeddedOperator}"><code>Piccolo.Quantum.EmbeddedOperators.unembed</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unembed(op::AbstractMatrix, embedded_op::EmbeddedOperator)</code></pre><p>Unembed a sub-matrix from the <code>op</code> at the subspace defined by <code>embedded_op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L214-L218">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.EmbeddedOperators.unembed-Tuple{EmbeddedOperator}"><a class="docstring-binding" href="#Piccolo.Quantum.EmbeddedOperators.unembed-Tuple{EmbeddedOperator}"><code>Piccolo.Quantum.EmbeddedOperators.unembed</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unembed(embedded_op::EmbeddedOperator)</code></pre><p>Unembed an embedded operator, returning the original operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/embedded_operators.jl#L207-L211">source</a></section></details></article><h2 id="lib-lifted-operators"><a class="docs-heading-anchor" href="#lib-lifted-operators">Lifted Operators</a><a id="lib-lifted-operators-1"></a><a class="docs-heading-anchor-permalink" href="#lib-lifted-operators" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Quantum.LiftedOperators.lift_operator"><a class="docstring-binding" href="#Piccolo.Quantum.LiftedOperators.lift_operator"><code>Piccolo.Quantum.LiftedOperators.lift_operator</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">lift_operator(operator::AbstractMatrix{&lt;:Number}, i::Int, subsystem_levels::Vector{Int})
lift_operator(operator::AbstractMatrix{&lt;:Number}, i::Int, n_qubits::Int; kwargs...)
lift_operator(operators::AbstractVector{&lt;:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})
lift_operator(operators::AbstractVector{&lt;:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)
lift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})
lift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)</code></pre><p>Lift an <code>operator</code> acting on the <code>i</code>-th subsystem within <code>subsystem_levels</code> to an operator acting on the entire system spanning <code>subsystem_levels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/lifted_operators.jl#L9-L19">source</a></section></details></article><h2 id="lib-direct-sums"><a class="docs-heading-anchor" href="#lib-direct-sums">Direct Sums</a><a id="lib-direct-sums-1"></a><a class="docs-heading-anchor-permalink" href="#lib-direct-sums" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Quantum.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#Piccolo.Quantum.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}"><code>Piccolo.Quantum.DirectSums.direct_sum</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">direct_sum(A::AbstractMatrix, B::AbstractMatrix)</code></pre><p>Returns the direct sum of two matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/direct_sums.jl#L13-L17">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}"><a class="docstring-binding" href="#Piccolo.Quantum.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}"><code>Piccolo.Quantum.DirectSums.direct_sum</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">direct_sum(AÃÉ‚Éó::AbstractVector, BÃÉ‚Éó::AbstractVector)</code></pre><p>Returns the direct sum of two iso_vec operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/direct_sums.jl#L31-L35">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}"><a class="docstring-binding" href="#Piccolo.Quantum.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}"><code>Piccolo.Quantum.DirectSums.direct_sum</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">direct_sum(sys1::QuantumSystem, sys2::QuantumSystem)</code></pre><p>Returns the direct sum of two <code>QuantumSystem</code> objects.</p><p>Constructs a new system where the Hilbert space is the direct sum of the two input systems: H = H‚ÇÅ ‚äï H‚ÇÇ = [H‚ÇÅ  0 ]                [0   H‚ÇÇ]</p><p>Both systems must have the same number of drives. The resulting system uses sys1&#39;s drive_bounds.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">sys1 = QuantumSystem([PAULIS[:X]], [(-1.0, 1.0)])
sys2 = QuantumSystem([PAULIS[:Y]], [(-1.0, 1.0)])
sys_combined = direct_sum(sys1, sys2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/direct_sums.jl#L42-L59">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><a class="docstring-binding" href="#Piccolo.Quantum.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><code>Piccolo.Quantum.DirectSums.direct_sum</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC)</code></pre><p>Returns the direct sum of two sparse matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/operators/direct_sums.jl#L22-L26">source</a></section></details></article><h2 id="lib-isomorphisms"><a class="docs-heading-anchor" href="#lib-isomorphisms">Isomorphisms</a><a id="lib-isomorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#lib-isomorphisms" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.G-Tuple{AbstractMatrix{&lt;:Number}}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.G-Tuple{AbstractMatrix{&lt;:Number}}"><code>Piccolo.Quantum.Isomorphisms.G</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">G(H::AbstractMatrix)::Matrix{Float64}</code></pre><p>Returns the isomorphism of <span>$-iH$</span>, i.e. <span>$G(H) = \text{iso}(-iH)$</span>.</p><p>See also <a href="#Piccolo.Quantum.Isomorphisms.iso-Tuple{AbstractMatrix{&lt;:Number}}"><code>Isomorphisms.iso</code></a>, <a href="#Piccolo.Quantum.Isomorphisms.H-Tuple{AbstractMatrix{&lt;:Real}}"><code>Isomorphisms.H</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L353-L359">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.H-Tuple{AbstractMatrix{&lt;:Real}}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.H-Tuple{AbstractMatrix{&lt;:Real}}"><code>Piccolo.Quantum.Isomorphisms.H</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">H(G::AbstractMatrix{&lt;:Real})</code></pre><p>Returns the inverse of <span>$G(H) = iso(-iH)$</span>, i.e. returns H.</p><p>See also <a href="#Piccolo.Quantum.Isomorphisms.iso-Tuple{AbstractMatrix{&lt;:Number}}"><code>Isomorphisms.iso</code></a>, <a href="#Piccolo.Quantum.Isomorphisms.G-Tuple{AbstractMatrix{&lt;:Number}}"><code>Isomorphisms.G</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L362-L368">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.ad_vec-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ&lt;:Number"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.ad_vec-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ&lt;:Number"><code>Piccolo.Quantum.Isomorphisms.ad_vec</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ad_vec(H::AbstractMatrix{‚ÑÇ}; anti::Bool=false) where ‚ÑÇ &lt;: Number</code></pre><p>Returns the vectorized adjoint action of a matrix <code>H</code>:</p><p class="math-container">\[\text{ad_vec}(H) = \mqty(1 &amp; 0 \\ 0 &amp; 1) \otimes H - (-1)^{\text{anti}} \mqty(0 &amp; 1 \\ 1 &amp; 0) \otimes H^*\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L376-L384">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.bloch_to_ket-Union{Tuple{AbstractVector{R}}, Tuple{R}} where R&lt;:Real"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.bloch_to_ket-Union{Tuple{AbstractVector{R}}, Tuple{R}} where R&lt;:Real"><code>Piccolo.Quantum.Isomorphisms.bloch_to_ket</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bloch_to_ket(v::AbstractVector{&lt;:Real}; digits=6)</code></pre><p>Convert a Bloch vector to a ket (up to global phase).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L442-L447">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.compact_iso_to_density-Tuple{AbstractVector{&lt;:Real}}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.compact_iso_to_density-Tuple{AbstractVector{&lt;:Real}}"><code>Piccolo.Quantum.Isomorphisms.compact_iso_to_density</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compact_iso_to_density(x::AbstractVector{&lt;:Real})</code></pre><p>Reconstructs a Hermitian density matrix <span>$œÅ$</span> from its compact real isomorphism vector <span>$x$</span> of length <span>$n^2$</span>.</p><p>See also <a href="#Piccolo.Quantum.Isomorphisms.density_to_compact_iso-Tuple{AbstractMatrix{&lt;:Number}}"><code>density_to_compact_iso</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L194-L201">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.density_lift_matrix-Tuple{Int64}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.density_lift_matrix-Tuple{Int64}"><code>Piccolo.Quantum.Isomorphisms.density_lift_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">density_lift_matrix(n::Int)</code></pre><p>Returns the sparse lift matrix <span>$L \in \mathbb{R}^{2n^2 \times n^2}$</span> that maps the compact density isomorphism to the full <span>$\text{iso\_vec}$</span> representation.</p><p>Given a compact vector <span>$x = \text{density\_to\_compact\_iso}(œÅ)$</span>, the full representation is recovered as <span>$L x = \text{density\_to\_iso\_vec}(œÅ)$</span>.</p><p>The matrix has <span>$n(2n-1)$</span> nonzero entries.</p><p>See also <a href="#Piccolo.Quantum.Isomorphisms.density_projection_matrix-Tuple{Int64}"><code>density_projection_matrix</code></a>, <a href="#Piccolo.Quantum.Isomorphisms.density_to_compact_iso-Tuple{AbstractMatrix{&lt;:Number}}"><code>density_to_compact_iso</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L224-L236">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.density_projection_matrix-Tuple{Int64}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.density_projection_matrix-Tuple{Int64}"><code>Piccolo.Quantum.Isomorphisms.density_projection_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">density_projection_matrix(n::Int)</code></pre><p>Returns the sparse projection matrix <span>$P \in \mathbb{R}^{n^2 \times 2n^2}$</span> that maps the full <span>$\text{iso\_vec}$</span> representation to the compact density isomorphism.</p><p>Given a full vector <span>$v = \text{density\_to\_iso\_vec}(œÅ)$</span> for Hermitian <span>$œÅ$</span>, the compact representation is <span>$P v = \text{density\_to\_compact\_iso}(œÅ)$</span>.</p><p>Satisfies <span>$PL = I_{n^2}$</span> where <span>$L$</span> = <a href="#Piccolo.Quantum.Isomorphisms.density_lift_matrix-Tuple{Int64}"><code>density_lift_matrix</code></a>.</p><p>See also <a href="#Piccolo.Quantum.Isomorphisms.density_lift_matrix-Tuple{Int64}"><code>density_lift_matrix</code></a>, <a href="#Piccolo.Quantum.Isomorphisms.density_to_compact_iso-Tuple{AbstractMatrix{&lt;:Number}}"><code>density_to_compact_iso</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L280-L292">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.density_to_compact_iso-Tuple{AbstractMatrix{&lt;:Number}}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.density_to_compact_iso-Tuple{AbstractMatrix{&lt;:Number}}"><code>Piccolo.Quantum.Isomorphisms.density_to_compact_iso</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">density_to_compact_iso(œÅ::AbstractMatrix{&lt;:Number})</code></pre><p>Returns a compact real isomorphism vector of length <span>$n^2$</span> for a Hermitian density matrix <span>$œÅ$</span> of size <span>$n \times n$</span>. Exploits Hermiticity (<span>$œÅ = œÅ^\dagger$</span>) to halve the representation size compared to <a href="#Piccolo.Quantum.Isomorphisms.density_to_iso_vec-Tuple{AbstractMatrix{&lt;:Number}}"><code>density_to_iso_vec</code></a>.</p><p>The compact vector is ordered as:</p><ol><li><span>$\text{Re}(œÅ_{jk})$</span> for <span>$j \leq k$</span> (upper triangle, column-major): <span>$n(n+1)/2$</span> entries</li><li><span>$\text{Im}(œÅ_{jk})$</span> for <span>$j &lt; k$</span> (strict upper triangle, column-major): <span>$n(n-1)/2$</span> entries</li></ol><p>See also <a href="#Piccolo.Quantum.Isomorphisms.compact_iso_to_density-Tuple{AbstractVector{&lt;:Real}}"><code>compact_iso_to_density</code></a>, <a href="#Piccolo.Quantum.Isomorphisms.density_lift_matrix-Tuple{Int64}"><code>density_lift_matrix</code></a>, <a href="#Piccolo.Quantum.Isomorphisms.density_projection_matrix-Tuple{Int64}"><code>density_projection_matrix</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L163-L176">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.density_to_iso_vec-Tuple{AbstractMatrix{&lt;:Number}}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.density_to_iso_vec-Tuple{AbstractMatrix{&lt;:Number}}"><code>Piccolo.Quantum.Isomorphisms.density_to_iso_vec</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">density_to_iso_vec(œÅ::AbstractMatrix{&lt;:Number})</code></pre><p>Returns the isomorphism <code>œÅ‚ÉóÃÉ = ket_to_iso(vec(œÅ))</code> of a density matrix <code>œÅ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L149-L153">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.iso-Tuple{AbstractMatrix{&lt;:Number}}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.iso-Tuple{AbstractMatrix{&lt;:Number}}"><code>Piccolo.Quantum.Isomorphisms.iso</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iso(H::AbstractMatrix{&lt;:Number})</code></pre><p>Returns the isomorphism of <span>$H$</span>:</p><p class="math-container">\[iso(H) = \widetilde{H} = \mqty(1 &amp; 0 \\ 0 &amp; 1) \otimes \Re(H) + \mqty(0 &amp; -1 \\ 1 &amp; 0) \otimes \Im(H)\]</p><p>where <span>$\Im(H)$</span> and <span>$\Re(H)$</span> are the imaginary and real parts of <span>$H$</span> and the tilde  indicates the standard isomorphism of a complex valued matrix:</p><p class="math-container">\[\widetilde{H} = \mqty(1 &amp; 0 \\ 0 &amp; 1) \otimes \Re(H) + \mqty(0 &amp; -1 \\ 1 &amp; 0) \otimes \Im(H)\]</p><p>See also <a href="#Piccolo.Quantum.Isomorphisms.G-Tuple{AbstractMatrix{&lt;:Number}}"><code>Isomorphisms.G</code></a>, <a href="#Piccolo.Quantum.Isomorphisms.H-Tuple{AbstractMatrix{&lt;:Real}}"><code>Isomorphisms.H</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L333-L350">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.iso_D-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ&lt;:Number"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.iso_D-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ&lt;:Number"><code>Piccolo.Quantum.Isomorphisms.iso_D</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iso_D(L::AbstractMatrix{‚ÑÇ}) where ‚ÑÇ &lt;: Number</code></pre><p>Returns the isomorphic representation of the Lindblad dissipator <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L390-L394">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.iso_operator_to_iso_vec-Union{Tuple{AbstractMatrix{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù&lt;:Real"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.iso_operator_to_iso_vec-Union{Tuple{AbstractMatrix{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù&lt;:Real"><code>Piccolo.Quantum.Isomorphisms.iso_operator_to_iso_vec</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iso_operator_to_iso_vec(UÃÉ::AbstractMatrix{‚Ñù}) where ‚Ñù &lt;: Real</code></pre><p>Convert a real matrix <code>UÃÉ</code> representing an isomorphism operator into a real vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L121-L125">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.iso_operator_to_operator-Tuple{Any}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.iso_operator_to_operator-Tuple{Any}"><code>Piccolo.Quantum.Isomorphisms.iso_operator_to_operator</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iso_operator_to_operator(UÃÉ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L135-L137">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.iso_to_ket-Tuple{AbstractVector{&lt;:Real}}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.iso_to_ket-Tuple{AbstractVector{&lt;:Real}}"><code>Piccolo.Quantum.Isomorphisms.iso_to_ket</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iso_to_ket(œàÃÉ::AbstractVector{&lt;:Real})</code></pre><p>Convert a real isomorphism vector <code>œàÃÉ</code> into a ket vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L57-L61">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.iso_vec_to_density-Tuple{AbstractVector{&lt;:Real}}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.iso_vec_to_density-Tuple{AbstractVector{&lt;:Real}}"><code>Piccolo.Quantum.Isomorphisms.iso_vec_to_density</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iso_vec_to_density(œÅ‚ÉóÃÉ::AbstractVector{&lt;:Real})</code></pre><p>Returns the density matrix <code>œÅ</code> from its isomorphism <code>œÅ‚ÉóÃÉ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L156-L160">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.iso_vec_to_iso_operator-Union{Tuple{AbstractVector{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù&lt;:Real"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.iso_vec_to_iso_operator-Union{Tuple{AbstractVector{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù&lt;:Real"><code>Piccolo.Quantum.Isomorphisms.iso_vec_to_iso_operator</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iso_vec_to_iso_operator(UÃÉ‚Éó::AbstractVector{‚Ñù}) where ‚Ñù &lt;: Real</code></pre><p>Convert a real vector <code>UÃÉ‚Éó</code> into a real matrix representing an isomorphism operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L85-L89">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.iso_vec_to_operator-Union{Tuple{AbstractVector{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù&lt;:Real"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.iso_vec_to_operator-Union{Tuple{AbstractVector{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù&lt;:Real"><code>Piccolo.Quantum.Isomorphisms.iso_vec_to_operator</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iso_vec_to_operator(UÃÉ‚Éó::AbstractVector{‚Ñù}) where ‚Ñù &lt;: Real</code></pre><p>Convert a real vector <code>UÃÉ‚Éó</code> into a complex matrix representing an operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L69-L73">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.ket_to_bloch-Tuple{AbstractVector{&lt;:Number}}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.ket_to_bloch-Tuple{AbstractVector{&lt;:Number}}"><code>Piccolo.Quantum.Isomorphisms.ket_to_bloch</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ket_to_bloch(œà::AbstractVector{&lt;:Number})</code></pre><p>Convert a ket to a Bloch vector representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L429-L433">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.ket_to_iso-Tuple{AbstractVector{&lt;:Number}}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.ket_to_iso-Tuple{AbstractVector{&lt;:Number}}"><code>Piccolo.Quantum.Isomorphisms.ket_to_iso</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ket_to_iso(œà::AbstractVector{&lt;:Number})</code></pre><p>Convert a ket vector <code>œà</code> into a complex vector with real and imaginary parts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L50-L54">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.mat-Tuple{AbstractVector}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.mat-Tuple{AbstractVector}"><code>Piccolo.Quantum.Isomorphisms.mat</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mat(x::AbstractVector)</code></pre><p>Convert a vector <code>x</code> into a square matrix. The length of <code>x</code> must be a perfect square.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L34-L38">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.operator_to_iso_operator-Tuple{Any}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.operator_to_iso_operator-Tuple{Any}"><code>Piccolo.Quantum.Isomorphisms.operator_to_iso_operator</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">operator_to_iso_operator(U)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L140-L142">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.operator_to_iso_vec-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ&lt;:Number"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.operator_to_iso_vec-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ&lt;:Number"><code>Piccolo.Quantum.Isomorphisms.operator_to_iso_vec</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">operator_to_iso_vec(U::AbstractMatrix{‚ÑÇ}) where ‚ÑÇ &lt;: Number</code></pre><p>Convert a complex matrix <code>U</code> representing an operator into a real vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L106-L110">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Isomorphisms.var_G-Union{Tuple{‚Ñù2}, Tuple{‚Ñù1}, Tuple{AbstractMatrix{‚Ñù1}, AbstractVector{&lt;:AbstractMatrix{‚Ñù2}}}} where {‚Ñù1&lt;:Real, ‚Ñù2&lt;:Real}"><a class="docstring-binding" href="#Piccolo.Quantum.Isomorphisms.var_G-Union{Tuple{‚Ñù2}, Tuple{‚Ñù1}, Tuple{AbstractMatrix{‚Ñù1}, AbstractVector{&lt;:AbstractMatrix{‚Ñù2}}}} where {‚Ñù1&lt;:Real, ‚Ñù2&lt;:Real}"><code>Piccolo.Quantum.Isomorphisms.var_G</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">var_G(G::AbstractMatrix{&lt;:Real}, G_vars::AbstractVector{&lt;:AbstractMatrix{&lt;:Real}})</code></pre><p>Returns the variational generator of <code>G</code> with variational derivatives, <code>G_vars</code>.</p><p>The variational generator is </p><p class="math-container">\[\text{var}_G(G, [G_a, G_b]) = \mqty( G &amp; 0 &amp; 0 \\ G_a &amp; G &amp; 0 \\ G_b &amp; 0 &amp; G )\]</p><p>where <code>G</code> is the isomorphism of a Hamiltonian and <code>G_a</code> and <code>G_b</code> are the variational  derivatives of <code>G</code> for parameters <code>a</code> and <code>b</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/quantum/primitives/isomorphisms.jl#L399-L410">source</a></section></details></article><h2 id="lib-quantum-control-problems"><a class="docs-heading-anchor" href="#lib-quantum-control-problems">Quantum Control Problems</a><a id="lib-quantum-control-problems-1"></a><a class="docs-heading-anchor-permalink" href="#lib-quantum-control-problems" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Control.QuantumControlProblems.QuantumControlProblem"><a class="docstring-binding" href="#Piccolo.Control.QuantumControlProblems.QuantumControlProblem"><code>Piccolo.Control.QuantumControlProblems.QuantumControlProblem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">QuantumControlProblem{QT&lt;:AbstractQuantumTrajectory}</code></pre><p>Wrapper combining quantum trajectory information with trajectory optimization problem.</p><p>This type enables:</p><ul><li>Type-stable dispatch on quantum trajectory type (Unitary, Ket, Density)</li><li>Clean separation of quantum information (system, goal) from optimization details</li><li>Composable problem transformations (e.g., SmoothPulseProblem ‚Üí MinimumTimeProblem)</li></ul><p><strong>Fields</strong></p><ul><li><code>qtraj::QT</code>: Quantum trajectory containing system, goal, and quantum state information</li><li><code>prob::DirectTrajOptProblem</code>: Direct trajectory optimization problem with objective, dynamics, constraints</li></ul><p><strong>Construction</strong></p><p>Typically created via problem templates:</p><pre><code class="language-julia hljs">qtraj = UnitaryTrajectory(sys, U_goal, N)
qcp = SmoothPulseProblem(qtraj; Q=100.0, R=1e-2)</code></pre><p><strong>Accessors</strong></p><ul><li><code>get_trajectory(qcp)</code>: Get the NamedTrajectory</li><li><code>get_system(qcp)</code>: Get the QuantumSystem</li><li><code>get_goal(qcp)</code>: Get the goal state/unitary</li><li><code>state_name(qcp)</code>: Get the state variable name</li><li><code>drive_name(qcp)</code>: Get the control variable name</li></ul><p><strong>Solving</strong></p><pre><code class="language-julia hljs">solve!(qcp; max_iter=100, verbose=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/problems.jl#L17-L49">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Solvers.solve!-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#DirectTrajOpt.Solvers.solve!-Tuple{QuantumControlProblem}"><code>DirectTrajOpt.Solvers.solve!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve!(qcp::QuantumControlProblem; sync::Bool=true, kwargs...)</code></pre><p>Solve the quantum control problem by forwarding to the inner DirectTrajOptProblem.</p><p><strong>Arguments</strong></p><ul><li><code>sync::Bool=true</code>: If true, call <code>sync_trajectory!</code> after solving to update <code>qtraj.trajectory</code> with physical control values. Set to false to skip synchronization (e.g., for debugging).</li></ul><p>All other keyword arguments are passed to the DirectTrajOpt solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/problems.jl#L153-L163">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.QuantumControlProblems.get_trajectory-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#Piccolo.Control.QuantumControlProblems.get_trajectory-Tuple{QuantumControlProblem}"><code>Piccolo.Control.QuantumControlProblems.get_trajectory</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_trajectory(qcp::QuantumControlProblem)</code></pre><p>Get the NamedTrajectory from the optimization problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/problems.jl#L59-L63">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.QuantumControlProblems.sync_trajectory!-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#Piccolo.Control.QuantumControlProblems.sync_trajectory!-Tuple{QuantumControlProblem}"><code>Piccolo.Control.QuantumControlProblems.sync_trajectory!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sync_trajectory!(qcp::QuantumControlProblem)</code></pre><p>Update the quantum trajectory in-place from the optimized control values.</p><p>After optimization, this function:</p><ol><li>Extracts the optimized controls from <code>prob.trajectory</code> (unadapting if needed)</li><li>Creates a new pulse with those controls via <code>extract_pulse</code></li><li>Re-solves the ODE to get the updated quantum evolution</li><li>Replaces <code>qtraj</code> with the new quantum trajectory</li></ol><p>This gives you access to the continuous-time ODE solution with the optimized controls, allowing you to:</p><ul><li>Evaluate the fidelity via <code>fidelity(qcp.qtraj)</code></li><li>Sample the quantum state at any time via <code>qcp.qtraj(t)</code></li><li>Get the optimized pulse via <code>get_pulse(qcp.qtraj)</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">solve!(qcp; max_iter=100)  # Automatically calls sync_trajectory!
fid = fidelity(qcp.qtraj)  # Evaluate fidelity with continuous-time solution
pulse = get_pulse(qcp.qtraj)  # Get the optimized pulse</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/problems.jl#L113-L136">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Pulses.drive_name-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#Piccolo.Quantum.Pulses.drive_name-Tuple{QuantumControlProblem}"><code>Piccolo.Quantum.Pulses.drive_name</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">drive_name(qcp::QuantumControlProblem)</code></pre><p>Get the control variable name from the quantum trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/problems.jl#L87-L91">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.get_goal-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.get_goal-Tuple{QuantumControlProblem}"><code>Piccolo.Quantum.QuantumTrajectories.get_goal</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_goal(qcp::QuantumControlProblem)</code></pre><p>Get the goal state/operator from the quantum trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/problems.jl#L73-L77">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.get_system-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.get_system-Tuple{QuantumControlProblem}"><code>Piccolo.Quantum.QuantumTrajectories.get_system</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_system(qcp::QuantumControlProblem)</code></pre><p>Get the QuantumSystem from the quantum trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/problems.jl#L66-L70">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.QuantumTrajectories.state_name-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#Piccolo.Quantum.QuantumTrajectories.state_name-Tuple{QuantumControlProblem}"><code>Piccolo.Quantum.QuantumTrajectories.state_name</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">state_name(qcp::QuantumControlProblem)</code></pre><p>Get the state variable name from the quantum trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/problems.jl#L80-L84">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Quantum.Rollouts.fidelity-Tuple{QuantumControlProblem}"><a class="docstring-binding" href="#Piccolo.Quantum.Rollouts.fidelity-Tuple{QuantumControlProblem}"><code>Piccolo.Quantum.Rollouts.fidelity</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fidelity(qcp::QuantumControlProblem; kwargs...)</code></pre><p>Compute the fidelity of the quantum trajectory.</p><p>This is a convenience wrapper that forwards to <code>fidelity(qcp.qtraj; kwargs...)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">solve!(qcp)
fid = fidelity(qcp)  # Equivalent to fidelity(qcp.qtraj)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/problems.jl#L94-L106">source</a></section></details></article><h2 id="lib-problem-templates"><a class="docs-heading-anchor" href="#lib-problem-templates">Problem Templates</a><a id="lib-problem-templates-1"></a><a class="docs-heading-anchor-permalink" href="#lib-problem-templates" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Control.ProblemTemplates.MinimumTimeProblem-Union{Tuple{QuantumControlProblem{QT}}, Tuple{QT}} where QT&lt;:AbstractQuantumTrajectory"><a class="docstring-binding" href="#Piccolo.Control.ProblemTemplates.MinimumTimeProblem-Union{Tuple{QuantumControlProblem{QT}}, Tuple{QT}} where QT&lt;:AbstractQuantumTrajectory"><code>Piccolo.Control.ProblemTemplates.MinimumTimeProblem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MinimumTimeProblem(qcp::QuantumControlProblem; kwargs...)</code></pre><p>Convert an existing quantum control problem to minimum-time optimization.</p><p><strong>IMPORTANT</strong>: This function requires an existing <code>QuantumControlProblem</code> (e.g., from <code>SmoothPulseProblem</code>). It cannot be created directly from a quantum trajectory. The workflow is:</p><ol><li>Create base problem with <code>SmoothPulseProblem</code> (or similar)</li><li>Solve base problem to get feasible solution</li><li>Convert to minimum-time with <code>MinimumTimeProblem</code></li></ol><p>This ensures the problem starts from a good initialization and maintains solution quality through the final fidelity constraint.</p><p><strong>Type Dispatch</strong></p><p>Automatically handles different quantum trajectory types through the type parameter:</p><ul><li><code>QuantumControlProblem{UnitaryTrajectory}</code> ‚Üí Uses <code>FinalUnitaryFidelityConstraint</code></li><li><code>QuantumControlProblem{KetTrajectory}</code> ‚Üí Uses <code>FinalKetFidelityConstraint</code></li><li><code>QuantumControlProblem{DensityTrajectory}</code> ‚Üí Not yet implemented</li></ul><p>The optimization problem is:</p><p class="math-container">\[\begin{aligned}
\underset{\vec{\tilde{q}}, u, \Delta t}{\text{minimize}} &amp; \quad
J_{\text{original}}(\vec{\tilde{q}}, u) + D \sum_t \Delta t_t \\
\text{ subject to } &amp; \quad \text{original dynamics \&amp; constraints} \\
&amp; F_{\text{final}} \geq F_{\text{threshold}} \\
&amp; \quad \Delta t_{\text{min}} \leq \Delta t_t \leq \Delta t_{\text{max}} \\
\end{aligned}\]</p><p>where q represents the quantum state (unitary, ket, or density matrix).</p><p><strong>Arguments</strong></p><ul><li><code>qcp::QuantumControlProblem</code>: Existing quantum control problem to convert</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>final_fidelity::Float64=0.99</code>: Minimum fidelity constraint at final time</li><li><code>D::Float64=100.0</code>: Weight on minimum-time objective ‚àëŒît</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: Piccolo solver options</li></ul><p><strong>Returns</strong></p><ul><li><code>QuantumControlProblem</code>: New problem with minimum-time objective and fidelity constraint</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Standard workflow
sys = QuantumSystem(H_drift, H_drives, drive_bounds)
pulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))
qtraj = UnitaryTrajectory(sys, pulse, U_goal)

# Step 1: Create and solve base smooth pulse problem (with Œît_bounds for free time)
qcp_smooth = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2, Œît_bounds=(0.01, 0.5))
solve!(qcp_smooth; max_iter=100)

# Step 2: Convert to minimum-time
qcp_mintime = MinimumTimeProblem(qcp_smooth; final_fidelity=0.99, D=100.0)
solve!(qcp_mintime; max_iter=100)

# Compare durations
duration_before = sum(get_timesteps(get_trajectory(qcp_smooth)))
duration_after = sum(get_timesteps(get_trajectory(qcp_mintime)))
@assert duration_after &lt;= duration_before

# Nested transformations also work
qcp_final = MinimumTimeProblem(
    RobustnessProblem(qcp_smooth);  # Future feature
    final_fidelity=0.95
)</code></pre><p><strong>Convenience Constructors</strong></p><p>You can also update the goal when creating minimum-time problem:</p><pre><code class="language-julia hljs"># Different goal for minimum-time optimization
qcp_mintime = MinimumTimeProblem(qcp_smooth; goal=U_goal_new, final_fidelity=0.98)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/templates/minimum_time_problem.jl#L3-L83">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.ProblemTemplates.SamplingProblem-Tuple{QuantumControlProblem, Vector{&lt;:AbstractQuantumSystem}}"><a class="docstring-binding" href="#Piccolo.Control.ProblemTemplates.SamplingProblem-Tuple{QuantumControlProblem, Vector{&lt;:AbstractQuantumSystem}}"><code>Piccolo.Control.ProblemTemplates.SamplingProblem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SamplingProblem(qcp::QuantumControlProblem, systems::Vector{&lt;:AbstractQuantumSystem}; kwargs...)</code></pre><p>Construct a <code>SamplingProblem</code> from an existing <code>QuantumControlProblem</code> and a list of systems.</p><p>This creates a robust optimization problem where the controls are shared across all systems, but each system evolves according to its own dynamics. The objective is the weighted sum of fidelity objectives for each system.</p><p><strong>Arguments</strong></p><ul><li><code>qcp::QuantumControlProblem</code>: The base problem (defines nominal trajectory, objective, etc.)</li><li><code>systems::Vector{&lt;:AbstractQuantumSystem}</code>: List of systems to optimize over</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>weights::Vector{Float64}=fill(1.0, length(systems))</code>: Weights for each system</li><li><code>Q::Float64=100.0</code>: Weight on infidelity objective (explicit, not extracted from base problem)</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: Options for the solver</li></ul><p><strong>Returns</strong></p><ul><li><code>QuantumControlProblem{SamplingTrajectory}</code>: A new problem with the sampling trajectory</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/templates/sampling_problem.jl#L87-L107">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.ProblemTemplates.SmoothPulseProblem-Tuple{AbstractQuantumTrajectory{&lt;:ZeroOrderPulse}, Int64}"><a class="docstring-binding" href="#Piccolo.Control.ProblemTemplates.SmoothPulseProblem-Tuple{AbstractQuantumTrajectory{&lt;:ZeroOrderPulse}, Int64}"><code>Piccolo.Control.ProblemTemplates.SmoothPulseProblem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SmoothPulseProblem(qtraj::AbstractQuantumTrajectory{&lt;:ZeroOrderPulse}, N::Int; kwargs...)</code></pre><p>Construct a <code>QuantumControlProblem</code> for smooth pulse optimization with piecewise constant controls.</p><p><strong>Note</strong>: This problem template is for <code>ZeroOrderPulse</code> only. For spline-based pulses (<code>LinearSplinePulse</code>, <code>CubicSplinePulse</code>), use <code>SplinePulseProblem</code> instead.</p><p>The problem adds discrete derivative variables (du, ddu) that:</p><ul><li>Regularize control changes between timesteps</li><li>Enforce smoothness via <code>DerivativeIntegrator</code> constraints</li></ul><p><strong>Arguments</strong></p><ul><li><code>qtraj::AbstractQuantumTrajectory{&lt;:ZeroOrderPulse}</code>: Quantum trajectory with piecewise constant pulse</li><li><code>N::Int</code>: Number of timesteps for discretization</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>integrator::Union{Nothing, AbstractIntegrator, Vector{&lt;:AbstractIntegrator}}=nothing</code>: Optional custom integrator(s). If not provided, uses BilinearIntegrator (which does not support global variables). A custom integrator is required when <code>global_names</code> is specified.</li><li><code>global_names::Union{Nothing, Vector{Symbol}}=nothing</code>: Names of global variables to optimize. Requires a custom integrator (e.g., HermitianExponentialIntegrator from Piccolissimo) that supports global variables.</li><li><code>global_bounds::Union{Nothing, Dict{Symbol, Union{Float64, Tuple{Float64, Float64}}}}=nothing</code>: Bounds for global variables. Keys are variable names, values are either a scalar (symmetric bounds ¬±value) or a tuple (lower, upper).</li><li><code>du_bound::Float64=Inf</code>: Bound on discrete first derivative (controls jump rate)</li><li><code>ddu_bound::Float64=1.0</code>: Bound on discrete second derivative (controls acceleration)</li><li><code>Q::Float64=100.0</code>: Weight on infidelity/objective</li><li><code>R::Float64=1e-2</code>: Weight on regularization terms (u, uÃá, √º)</li><li><code>R_u::Union{Float64, Vector{Float64}}=R</code>: Weight on control regularization</li><li><code>R_du::Union{Float64, Vector{Float64}}=R</code>: Weight on first derivative regularization</li><li><code>R_ddu::Union{Float64, Vector{Float64}}=R</code>: Weight on second derivative regularization</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: Additional constraints</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: Piccolo solver options</li></ul><p><strong>Returns</strong></p><ul><li><code>QuantumControlProblem</code>: Wrapper containing quantum trajectory and optimization problem</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Unitary gate synthesis with piecewise constant pulse
sys = QuantumSystem(H_drift, H_drives, drive_bounds)
pulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))
qtraj = UnitaryTrajectory(sys, pulse, U_goal)
qcp = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2)
solve!(qcp; max_iter=100)

# Quantum state transfer
pulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))
qtraj = KetTrajectory(sys, pulse, œà_init, œà_goal)
qcp = SmoothPulseProblem(qtraj, N; Q=50.0, R=1e-3)
solve!(qcp)</code></pre><p>See also: <a href="#Piccolo.Control.ProblemTemplates.SplinePulseProblem"><code>SplinePulseProblem</code></a> for spline-based pulses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/templates/smooth_pulse_problem.jl#L3-L53">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.ProblemTemplates.SmoothPulseProblem-Tuple{MultiKetTrajectory{&lt;:ZeroOrderPulse}, Int64}"><a class="docstring-binding" href="#Piccolo.Control.ProblemTemplates.SmoothPulseProblem-Tuple{MultiKetTrajectory{&lt;:ZeroOrderPulse}, Int64}"><code>Piccolo.Control.ProblemTemplates.SmoothPulseProblem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SmoothPulseProblem(qtraj::MultiKetTrajectory{&lt;:ZeroOrderPulse}, N::Int; kwargs...)</code></pre><p>Construct a <code>QuantumControlProblem</code> for smooth pulse optimization over an ensemble of ket state transfers with piecewise constant controls.</p><p>This handles the case where you want to optimize a single pulse that achieves multiple  state transfers simultaneously (e.g., |0‚ü©‚Üí|1‚ü© and |1‚ü©‚Üí|0‚ü© for an X gate via state transfer).</p><p><strong>Note</strong>: This problem template is for <code>ZeroOrderPulse</code> only. For spline-based pulses, use <code>SplinePulseProblem</code> instead.</p><p><strong>Arguments</strong></p><ul><li><code>qtraj::MultiKetTrajectory{&lt;:ZeroOrderPulse}</code>: Ensemble of ket state transfers with piecewise constant pulse</li><li><code>N::Int</code>: Number of timesteps for the discretization</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>integrator::Union{Nothing, AbstractIntegrator, Vector{&lt;:AbstractIntegrator}}=nothing</code>: Optional custom integrator(s). If not provided, the default <code>BilinearIntegrator</code> is used. When <code>global_names</code> is specified, you must supply a custom integrator here (i.e., do not rely on the default <code>BilinearIntegrator</code>) that supports global variables.</li><li><code>global_names::Union{Nothing, Vector{Symbol}}=nothing</code>: Names of global variables to optimize. Requires a custom integrator provided via <code>integrator</code> (e.g., <code>HermitianExponentialIntegrator</code> from Piccolissimo) that supports global variables.</li><li><code>global_bounds::Union{Nothing, Dict{Symbol, Union{Float64, Tuple{Float64, Float64}}}}=nothing</code>: Bounds for global variables. Keys are variable names, values are either a scalar (symmetric bounds ¬±value) or a tuple (lower, upper).</li><li><code>du_bound::Float64=Inf</code>: Bound on discrete first derivative</li><li><code>ddu_bound::Float64=1.0</code>: Bound on discrete second derivative</li><li><code>Q::Float64=100.0</code>: Weight on infidelity/objective</li><li><code>R::Float64=1e-2</code>: Weight on regularization terms (u, uÃá, √º)</li><li><code>R_u::Union{Float64, Vector{Float64}}=R</code>: Weight on control regularization</li><li><code>R_du::Union{Float64, Vector{Float64}}=R</code>: Weight on first derivative regularization</li><li><code>R_ddu::Union{Float64, Vector{Float64}}=R</code>: Weight on second derivative regularization</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: Additional constraints</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: Piccolo solver options</li></ul><p><strong>Returns</strong></p><ul><li><code>QuantumControlProblem{MultiKetTrajectory}</code>: Wrapper containing ensemble trajectory and optimization problem</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create ensemble for X gate via state transfer
sys = QuantumSystem(H_drift, H_drives, drive_bounds)
pulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))

œà0 = ComplexF64[1.0, 0.0]
œà1 = ComplexF64[0.0, 1.0]

ensemble_qtraj = MultiKetTrajectory(sys, pulse, [œà0, œà1], [œà1, œà0])
qcp = SmoothPulseProblem(ensemble_qtraj, N; Q=100.0, R=1e-2)
solve!(qcp; max_iter=100)</code></pre><p>See also: <a href="#Piccolo.Control.ProblemTemplates.SplinePulseProblem"><code>SplinePulseProblem</code></a> for spline-based pulses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/templates/smooth_pulse_problem.jl#L182-L230">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.ProblemTemplates.SmoothPulseProblem-Union{Tuple{P}, Tuple{AbstractQuantumTrajectory{P}, Int64}} where P&lt;:AbstractPulse"><a class="docstring-binding" href="#Piccolo.Control.ProblemTemplates.SmoothPulseProblem-Union{Tuple{P}, Tuple{AbstractQuantumTrajectory{P}, Int64}} where P&lt;:AbstractPulse"><code>Piccolo.Control.ProblemTemplates.SmoothPulseProblem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SmoothPulseProblem(qtraj::AbstractQuantumTrajectory, N::Int; kwargs...)</code></pre><p>Fallback method that provides helpful error for non-ZeroOrderPulse types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/templates/smooth_pulse_problem.jl#L480-L484">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.ProblemTemplates.SplinePulseProblem"><a class="docstring-binding" href="#Piccolo.Control.ProblemTemplates.SplinePulseProblem"><code>Piccolo.Control.ProblemTemplates.SplinePulseProblem</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">SplinePulseProblem(qtraj::MultiKetTrajectory{&lt;:AbstractSplinePulse}; kwargs...)
SplinePulseProblem(qtraj::MultiKetTrajectory{&lt;:AbstractSplinePulse}, N::Int; kwargs...)
SplinePulseProblem(qtraj::MultiKetTrajectory{&lt;:AbstractSplinePulse}, times::AbstractVector; kwargs...)</code></pre><p>Create a spline-based trajectory optimization problem for ensemble ket state transfers.</p><p>Uses coherent fidelity objective (phases must align) for gate implementation.</p><p><strong>Arguments</strong></p><ul><li><code>qtraj::MultiKetTrajectory{&lt;:AbstractSplinePulse}</code>: Ensemble trajectory with spline pulse</li><li><code>N_or_times</code>: One of:<ul><li><code>nothing</code> (default): Use native knot times from spline pulse</li><li><code>N::Int</code>: Number of uniformly spaced timesteps</li><li><code>times::AbstractVector</code>: Specific sample times</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><p>Same as the base <code>SplinePulseProblem</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/templates/spline_pulse_problem.jl#L212-L230">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.ProblemTemplates.SplinePulseProblem"><a class="docstring-binding" href="#Piccolo.Control.ProblemTemplates.SplinePulseProblem"><code>Piccolo.Control.ProblemTemplates.SplinePulseProblem</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">SplinePulseProblem(qtraj::AbstractQuantumTrajectory{&lt;:AbstractSplinePulse}; kwargs...)
SplinePulseProblem(qtraj::AbstractQuantumTrajectory{&lt;:AbstractSplinePulse}, N::Int; kwargs...)
SplinePulseProblem(qtraj::AbstractQuantumTrajectory{&lt;:AbstractSplinePulse}, times::AbstractVector; kwargs...)</code></pre><p>Construct a <code>QuantumControlProblem</code> for spline-based pulse optimization.</p><p>Unlike <code>SmoothPulseProblem</code> (which uses piecewise constant controls with discrete smoothing  variables), this problem template is designed for spline-based pulses where the derivative  variables (<code>du</code>) are the actual spline coefficients or slopes.</p><p><strong>Pulse Type Semantics</strong></p><p><strong>LinearSplinePulse</strong>: The <code>du</code> variable represents the slope between knots. A <code>DerivativeIntegrator</code> constraint enforces <code>du[k] = (u[k+1] - u[k]) / Œît</code>, making the slopes consistent with the linear interpolation. This constraint ensures mathematical rigor while allowing slope regularization/bounds.</p><p><strong>CubicSplinePulse</strong> (Hermite spline): The <code>du</code> variable is the tangent/derivative at each  knot point, which is a true independent degree of freedom in Hermite interpolation. No  <code>DerivativeIntegrator</code> is added - the optimizer can adjust both <code>:u</code> and <code>:du</code> independently.</p><p><strong>Mathematical Notes</strong></p><ul><li><strong>LinearSplinePulse</strong>: Always adds <code>:du</code> and <code>DerivativeIntegrator</code> to enforce slope consistency</li><li><strong>CubicSplinePulse</strong>: <code>:du</code> values are Hermite tangents (unconstrained, only regularized)</li></ul><p>Both pulse types always have <code>:du</code> components in the trajectory, simplifying integrator implementations.</p><p><strong>Arguments</strong></p><ul><li><code>qtraj::AbstractQuantumTrajectory{&lt;:AbstractSplinePulse}</code>: Quantum trajectory with spline pulse</li><li><code>N_or_times</code>: One of:<ul><li><code>nothing</code> (default): Use native knot times from spline pulse (ideal for warm-starting)</li><li><code>N::Int</code>: Number of uniformly spaced timesteps</li><li><code>times::AbstractVector</code>: Specific sample times</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>integrator::Union{Nothing, AbstractIntegrator, Vector{&lt;:AbstractIntegrator}}=nothing</code>: Optional custom integrator(s). If not provided, uses <code>BilinearIntegrator</code> (which does not support global variables). A custom integrator is required when <code>global_names</code> is specified.</li><li><code>global_names::Union{Nothing, Vector{Symbol}}=nothing</code>: Names of global variables to optimize. Requires a custom integrator (e.g., <code>SplineIntegrator</code> from Piccolissimo) that supports global variables.</li><li><code>global_bounds::Union{Nothing, Dict{Symbol, Union{Float64, Tuple{Float64, Float64}}}}=nothing</code>: Bounds for global variables. Keys are variable names, values are either a scalar (symmetric bounds ¬±value) or a tuple (lower, upper).</li><li><code>du_bound::Float64=Inf</code>: Bound on derivative (slope) magnitude</li><li><code>Q::Float64=100.0</code>: Weight on infidelity/objective</li><li><code>R::Float64=1e-2</code>: Weight on regularization terms</li><li><code>R_u::Union{Float64, Vector{Float64}}=R</code>: Weight on control regularization</li><li><code>R_du::Union{Float64, Vector{Float64}}=R</code>: Weight on derivative regularization  </li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: Additional constraints</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: Piccolo solver options</li></ul><p><strong>Returns</strong></p><ul><li><code>QuantumControlProblem{&lt;:AbstractQuantumTrajectory}</code>: Wrapper containing trajectory and optimization problem</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create system and initial pulse
sys = QuantumSystem(H_drift, H_drives, drive_bounds)
pulse = CubicSplinePulse(u_init, du_init, times)
qtraj = UnitaryTrajectory(sys, pulse, U_goal)

# Use native knot structure (best for warm-starting from saved pulse)
qcp = SplinePulseProblem(qtraj; Q=100.0, du_bound=10.0)

# Or resample to different number of knots
qcp = SplinePulseProblem(qtraj, 50; Q=100.0, du_bound=10.0)

solve!(qcp; max_iter=100)</code></pre><p>See also: <a href="#Piccolo.Control.ProblemTemplates.SmoothPulseProblem-Tuple{AbstractQuantumTrajectory{&lt;:ZeroOrderPulse}, Int64}"><code>SmoothPulseProblem</code></a> for piecewise constant pulses with discrete smoothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/templates/spline_pulse_problem.jl#L7-L74">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.ProblemTemplates.SplinePulseProblem-Union{Tuple{AbstractQuantumTrajectory{P}}, Tuple{P}, Tuple{AbstractQuantumTrajectory{P}, Union{Nothing, Int64, AbstractVector{&lt;:Real}}}} where P&lt;:AbstractPulse"><a class="docstring-binding" href="#Piccolo.Control.ProblemTemplates.SplinePulseProblem-Union{Tuple{AbstractQuantumTrajectory{P}}, Tuple{P}, Tuple{AbstractQuantumTrajectory{P}, Union{Nothing, Int64, AbstractVector{&lt;:Real}}}} where P&lt;:AbstractPulse"><code>Piccolo.Control.ProblemTemplates.SplinePulseProblem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SplinePulseProblem(qtraj::AbstractQuantumTrajectory, N_or_times; kwargs...)</code></pre><p>Fallback method that provides helpful error for non-spline pulse types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/templates/spline_pulse_problem.jl#L385-L389">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.ProblemTemplates._ensemble_ket_objective-Tuple{MultiKetTrajectory, NamedTrajectory, Vector{Symbol}, Vector{Float64}, Vector, Float64}"><a class="docstring-binding" href="#Piccolo.Control.ProblemTemplates._ensemble_ket_objective-Tuple{MultiKetTrajectory, NamedTrajectory, Vector{Symbol}, Vector{Float64}, Vector, Float64}"><code>Piccolo.Control.ProblemTemplates._ensemble_ket_objective</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_ensemble_ket_objective(qtraj::MultiKetTrajectory, traj, state_names, weights, goals, Q)</code></pre><p>Create a coherent fidelity objective for ensemble state transfers.</p><p>For ensemble trajectories (implementing a gate via multiple state transfers), we use coherent fidelity:     F<em>coherent = |1/n ‚àë·µ¢ ‚ü®œà·µ¢</em>goal|œà·µ¢‚ü©|¬≤</p><p>This requires all state overlaps to have aligned phases, which is essential for gate implementation (the gate should have a single global phase).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/templates/smooth_pulse_problem.jl#L437-L448">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.ProblemTemplates._final_fidelity_constraint-Tuple{MultiKetTrajectory, Float64, NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Control.ProblemTemplates._final_fidelity_constraint-Tuple{MultiKetTrajectory, Float64, NamedTrajectory}"><code>Piccolo.Control.ProblemTemplates._final_fidelity_constraint</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_final_fidelity_constraint(qtraj::MultiKetTrajectory, final_fidelity, traj)</code></pre><p>Create a coherent fidelity constraint for an MultiKetTrajectory.</p><p>Uses coherent fidelity: F = |1/n ‚àë·µ¢ ‚ü®œà·µ¢_goal|œà·µ¢‚ü©|¬≤</p><p>This enforces that all state transfers have aligned global phases, which is  essential when implementing a gate via state transfer (e.g., X gate via  |0‚ü©‚Üí|1‚ü© and |1‚ü©‚Üí|0‚ü©).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/templates/minimum_time_problem.jl#L189-L199">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.ProblemTemplates.add_global_bounds_constraints!-Tuple{AbstractVector{&lt;:AbstractConstraint}, Any, NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Control.ProblemTemplates.add_global_bounds_constraints!-Tuple{AbstractVector{&lt;:AbstractConstraint}, Any, NamedTrajectory}"><code>Piccolo.Control.ProblemTemplates.add_global_bounds_constraints!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_global_bounds_constraints!(constraints, global_bounds, traj; verbose=false)</code></pre><p>Add GlobalBoundsConstraint entries for each global variable specified in <code>global_bounds</code>.</p><p>Converts bounds from user-friendly formats to the format expected by GlobalBoundsConstraint:</p><ul><li><code>Float64</code>: Symmetric scalar bounds (applied symmetrically to all dimensions)</li><li><code>Tuple{Float64, Float64}</code>: Asymmetric scalar bounds (expanded to vectors)</li><li><code>Vector</code> or <code>Tuple{Vector, Vector}</code>: Already in correct format (passed through)</li></ul><p>Modifies <code>constraints</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/templates/_problem_templates.jl#L100-L111">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.ProblemTemplates.extract_regularization-Tuple{Any, Symbol, NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Control.ProblemTemplates.extract_regularization-Tuple{Any, Symbol, NamedTrajectory}"><code>Piccolo.Control.ProblemTemplates.extract_regularization</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_regularization(objective, state_sym::Symbol, new_traj::NamedTrajectory) -&gt; AbstractObjective</code></pre><p>Extract regularization terms (non-state-dependent objectives) from a composite objective, filtering to only include terms for variables that exist in the new trajectory.</p><p>Used by <code>SamplingProblem</code> to extract shared regularizers (e.g., control penalty) from the base problem while excluding regularizers for variables that don&#39;t exist in the sampling trajectory (e.g., <code>:du</code>, <code>:ddu</code> which are added by <code>SmoothPulseProblem</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/templates/sampling_problem.jl#L9-L18">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.ProblemTemplates.sampling_state_objective-Tuple{UnitaryTrajectory, NamedTrajectory, Symbol, Float64}"><a class="docstring-binding" href="#Piccolo.Control.ProblemTemplates.sampling_state_objective-Tuple{UnitaryTrajectory, NamedTrajectory, Symbol, Float64}"><code>Piccolo.Control.ProblemTemplates.sampling_state_objective</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sampling_state_objective(qtraj, traj, state_sym, Q)</code></pre><p>Create the state-dependent objective for a sampling member. Dispatches on quantum trajectory type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/templates/sampling_problem.jl#L47-L52">source</a></section></details></article><h2 id="lib-objectives"><a class="docs-heading-anchor" href="#lib-objectives">Objectives</a><a id="lib-objectives-1"></a><a class="docs-heading-anchor-permalink" href="#lib-objectives" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Control.QuantumObjectives.CoherentKetInfidelityObjective-Tuple{Vector{&lt;:AbstractVector{&lt;:Complex}}, Vector{Symbol}, NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Control.QuantumObjectives.CoherentKetInfidelityObjective-Tuple{Vector{&lt;:AbstractVector{&lt;:Complex}}, Vector{Symbol}, NamedTrajectory}"><code>Piccolo.Control.QuantumObjectives.CoherentKetInfidelityObjective</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CoherentKetInfidelityObjective(œà_goals, œàÃÉ_names, traj; Q=100.0)</code></pre><p>Create a terminal objective for coherent ket state infidelity across multiple states.</p><p>Coherent fidelity is defined as:     F<em>coherent = |1/n ‚àë·µ¢ ‚ü®œà·µ¢</em>goal|œà·µ¢‚ü©|¬≤</p><p>Unlike incoherent fidelity (average of individual |‚ü®œà·µ¢_goal|œà·µ¢‚ü©|¬≤), coherent fidelity  requires all state overlaps to have aligned phases. This is essential when implementing a gate via multiple state transfers - the gate should have a single global phase, not independent phases per state.</p><p><strong>Arguments</strong></p><ul><li><code>œà_goals::Vector{&lt;:AbstractVector{&lt;:Complex}}</code>: Target ket states</li><li><code>œàÃÉ_names::Vector{Symbol}</code>: Names of isomorphic state variables in trajectory</li><li><code>traj::NamedTrajectory</code>: The trajectory</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Q::Float64=100.0</code>: Weight on the infidelity objective</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># For implementing X gate via |0‚ü©‚Üí|1‚ü© and |1‚ü©‚Üí|0‚ü©
goals = [ComplexF64[0, 1], ComplexF64[1, 0]]
names = [:œàÃÉ1, :œàÃÉ2]
obj = CoherentKetInfidelityObjective(goals, names, traj; Q=100.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/objectives.jl#L93-L121">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.QuantumObjectives.DensityMatrixInfidelityObjective-Tuple{Symbol, AbstractMatrix{&lt;:ComplexF64}, NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Control.QuantumObjectives.DensityMatrixInfidelityObjective-Tuple{Symbol, AbstractMatrix{&lt;:ComplexF64}, NamedTrajectory}"><code>Piccolo.Control.QuantumObjectives.DensityMatrixInfidelityObjective</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DensityMatrixInfidelityObjective(œÅÃÉ_name, œÅ_goal, traj; Q=100.0)</code></pre><p>Terminal objective for density matrix fidelity using the compact isomorphism.</p><p>Minimizes <code>|1 - tr(œÅ * œÅ_goal)|</code> where <code>œÅ</code> is reconstructed from the compact iso vector via <code>compact_iso_to_density</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/objectives.jl#L226-L233">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.QuantumObjectives.KetInfidelityObjective-Tuple{AbstractVector{&lt;:Complex}, Symbol, NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Control.QuantumObjectives.KetInfidelityObjective-Tuple{AbstractVector{&lt;:Complex}, Symbol, NamedTrajectory}"><code>Piccolo.Control.QuantumObjectives.KetInfidelityObjective</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KetInfidelityObjective(œà_goal, œàÃÉ_name, traj; Q=100.0)</code></pre><p>Create a terminal objective for ket state infidelity with an explicit goal state.</p><p>This variant is useful for SamplingProblem and EnsembleTrajectory where the goal is shared across multiple state variables that don&#39;t have individual goals in <code>traj.goal</code>.</p><p><strong>Arguments</strong></p><ul><li><code>œà_goal::AbstractVector{&lt;:Complex}</code>: The target ket state (complex vector)</li><li><code>œàÃÉ_name::Symbol</code>: Name of the isomorphic state variable in the trajectory</li><li><code>traj::NamedTrajectory</code>: The trajectory</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Q::Float64=100.0</code>: Weight on the infidelity objective</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/objectives.jl#L38-L53">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.QuantumObjectives.KetInfidelityObjective-Tuple{Symbol, NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Control.QuantumObjectives.KetInfidelityObjective-Tuple{Symbol, NamedTrajectory}"><code>Piccolo.Control.QuantumObjectives.KetInfidelityObjective</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KetInfidelityObjective(œàÃÉ_name, traj; Q=100.0)</code></pre><p>Create a terminal objective for ket state infidelity, using the goal from <code>traj.goal[œàÃÉ_name]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/objectives.jl#L27-L31">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.QuantumObjectives.LeakageObjective-Tuple{AbstractVector{Int64}, Symbol, NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Control.QuantumObjectives.LeakageObjective-Tuple{AbstractVector{Int64}, Symbol, NamedTrajectory}"><code>Piccolo.Control.QuantumObjectives.LeakageObjective</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LeakageObjective(indices, name, traj::NamedTrajectory)</code></pre><p>Construct a <code>KnotPointObjective</code> that penalizes leakage of <code>name</code> at the knot points specified by <code>times</code> at any <code>indices</code> that are outside the computational subspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/objectives.jl#L289-L294">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.QuantumObjectives.coherent_ket_fidelity-Tuple{Any, Vector{&lt;:AbstractVector{&lt;:ComplexF64}}}"><a class="docstring-binding" href="#Piccolo.Control.QuantumObjectives.coherent_ket_fidelity-Tuple{Any, Vector{&lt;:AbstractVector{&lt;:ComplexF64}}}"><code>Piccolo.Control.QuantumObjectives.coherent_ket_fidelity</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coherent_ket_fidelity(œàÃÉs, œà_goals)</code></pre><p>Compute coherent fidelity across multiple ket states:</p><pre><code class="language-julia hljs">F_coherent = |1/n ‚àë·µ¢ ‚ü®œà·µ¢_goal|œà·µ¢‚ü©|¬≤</code></pre><p>This requires all overlaps to have consistent phases (global phase alignment), which is necessary for implementing gates via state transfer.</p><p><strong>Arguments</strong></p><ul><li><code>œàÃÉs::Vector{&lt;:AbstractVector}</code>: List of isomorphic state vectors</li><li><code>œà_goals::Vector{&lt;:AbstractVector{&lt;:Complex}}</code>: List of goal states</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/objectives.jl#L68-L81">source</a></section></details></article><h2 id="lib-constraints"><a class="docs-heading-anchor" href="#lib-constraints">Constraints</a><a id="lib-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#lib-constraints" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Control.QuantumConstraints.FinalCoherentKetFidelityConstraint-Tuple{Vector{&lt;:AbstractVector{&lt;:Complex}}, Vector{Symbol}, Float64, NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Control.QuantumConstraints.FinalCoherentKetFidelityConstraint-Tuple{Vector{&lt;:AbstractVector{&lt;:Complex}}, Vector{Symbol}, Float64, NamedTrajectory}"><code>Piccolo.Control.QuantumConstraints.FinalCoherentKetFidelityConstraint</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FinalCoherentKetFidelityConstraint(œà_goals, œàÃÉ_names, final_fidelity, traj)</code></pre><p>Create a final fidelity constraint using coherent ket fidelity across multiple states.</p><p>Coherent fidelity: F = |1/n ‚àë·µ¢ ‚ü®œà·µ¢_goal|œà·µ¢‚ü©|¬≤</p><p>This constraint enforces that all state overlaps have aligned phases, which is  essential when implementing a gate via multiple state transfers (e.g., MultiKetTrajectory).</p><p><strong>Arguments</strong></p><ul><li><code>œà_goals::Vector{&lt;:AbstractVector{&lt;:Complex}}</code>: Target ket states</li><li><code>œàÃÉ_names::Vector{Symbol}</code>: Names of isomorphic state variables in trajectory</li><li><code>final_fidelity::Float64</code>: Minimum fidelity threshold (constraint: F ‚â• final_fidelity)</li><li><code>traj::NamedTrajectory</code>: The trajectory</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># For implementing X gate via |0‚ü©‚Üí|1‚ü© and |1‚ü©‚Üí|0‚ü©
goals = [ComplexF64[0, 1], ComplexF64[1, 0]]
names = [:œàÃÉ1, :œàÃÉ2]
constraint = FinalCoherentKetFidelityConstraint(goals, names, 0.99, traj)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/constraints.jl#L41-L64">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Control.QuantumConstraints.LeakageConstraint-Tuple{Float64, AbstractVector{Int64}, Symbol, NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Control.QuantumConstraints.LeakageConstraint-Tuple{Float64, AbstractVector{Int64}, Symbol, NamedTrajectory}"><code>Piccolo.Control.QuantumConstraints.LeakageConstraint</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LeakageConstraint(value, indices, name, traj::NamedTrajectory)</code></pre><p>Construct a <code>KnotPointConstraint</code> that bounds leakage of <code>name</code> at the knot points specified by <code>times</code> at any <code>indices</code> that are outside the computational subspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/constraints.jl#L150-L155">source</a></section></details></article><h2 id="lib-options"><a class="docs-heading-anchor" href="#lib-options">Options</a><a id="lib-options-1"></a><a class="docs-heading-anchor-permalink" href="#lib-options" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Control.Options.PiccoloOptions"><a class="docstring-binding" href="#Piccolo.Control.Options.PiccoloOptions"><code>Piccolo.Control.Options.PiccoloOptions</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PiccoloOptions</code></pre><p>Options for the Piccolo quantum optimal control library.</p><p><strong>Fields</strong></p><ul><li><code>verbose::Bool = true</code>: Print verbose output</li><li><code>timesteps_all_equal::Bool = true</code>: Use equal timesteps</li><li><code>rollout_integrator::Function = expv</code>: Integrator to use for rollout</li><li><code>geodesic = true</code>: Use the geodesic to initialize the optimization.</li><li><code>zero_initial_and_final_derivative::Bool=false</code>: Zero the initial and final control pulse derivatives.</li><li><code>complex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing</code>: Name of the complex control norm constraint.</li><li><code>complex_control_norm_constraint_radius::Float64 = 1.0</code>: Radius of the complex control norm constraint.</li><li><code>bound_state::Bool = false</code>: Bound the state variables &lt;= 1.0.</li><li><code>leakage_constraint::Bool = false</code>: Suppress leakage with constraint and cost.</li><li><code>leakage_constraint_value::Float64 = 1e-2</code>: Value for the leakage constraint.</li><li><code>leakage_cost::Float64 = 1e-2</code>: Leakage suppression parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/control/options.jl#L10-L27">source</a></section></details></article><h2 id="lib-visualizations"><a class="docs-heading-anchor" href="#lib-visualizations">Visualizations</a><a id="lib-visualizations-1"></a><a class="docs-heading-anchor-permalink" href="#lib-visualizations" title="Permalink"></a></h2><article><details class="docstring"><summary id="Piccolo.Visualizations.QuantumObjectPlots.plot_state_populations-Tuple{NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Visualizations.QuantumObjectPlots.plot_state_populations-Tuple{NamedTrajectory}"><code>Piccolo.Visualizations.QuantumObjectPlots.plot_state_populations</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_state_populations(
    traj::NamedTrajectory;
    state_name::Symbol=:œàÃÉ,
    state_indices::Union{Nothing, AbstractVector{Int}}=nothing,
    control_name::Symbol=:u,
    subspace::Union{Nothing, AbstractVector{Int}}=nothing,
    kwargs...
)</code></pre><p>Plot populations for multiple quantum states stored in a trajectory.</p><p>This function visualizes the time evolution of quantum state populations for trajectories containing multiple state trajectories (e.g., from sampling problems where multiple initial states are evolved). States are identified by a common prefix and numeric suffix pattern (e.g., <code>:œàÃÉ1_system_1</code>, <code>:œàÃÉ2_system_1</code>, etc.).</p><p><strong>Mathematical Background</strong></p><p>For a quantum state <span>$|\psi(t)\rangle \in \mathcal{H}$</span> evolving under the Schr√∂dinger equation, the population in computational basis state <span>$|i\rangle$</span> is given by</p><p class="math-container">\[P_i(t) = |\langle i|\psi(t)\rangle|^2 = |\psi_i(t)|^2\]</p><p>where <span>$\psi_i(t)$</span> is the <span>$i$</span>-th component of the state vector in the computational basis.</p><p>For a normalized state, we have the conservation property:</p><p class="math-container">\[\sum_{i=1}^{n} P_i(t) = \langle\psi(t)|\psi(t)\rangle = 1\]</p><p>When multiple states are being optimized simultaneously (as in sampling problems), this function plots the populations for each state, allowing comparison of how different initial conditions evolve under the same control protocol.</p><p><strong>Key Properties:</strong></p><ul><li>Populations are real and bounded: <span>$P_i(t) \in [0,1]$</span></li><li>Total probability is conserved: <span>$\sum_i P_i(t) = 1$</span></li><li>Can optionally restrict to a subspace (e.g., computational subspace excluding leakage states)</li></ul><p><strong>Arguments</strong></p><ul><li><code>traj::NamedTrajectory</code>: A trajectory containing one or more quantum states in isomorphism representation.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>state_name::Symbol</code>: The base name for state components. The function will find all trajectory components matching this prefix (e.g., <code>:œàÃÉ</code> matches <code>:œàÃÉ1_system_1</code>, <code>:œàÃÉ2_system_1</code>, etc.). Default is <code>:œàÃÉ</code>.</li><li><code>state_indices::Union{Nothing, AbstractVector{Int}}</code>: If provided, only plot states with these indices (e.g., <code>[1, 3]</code> plots only the 1st and 3rd states). If <code>nothing</code>, plots all states matching the prefix. Default is <code>nothing</code>.</li><li><code>control_name::Symbol</code>: The name of the control signal component to include in the plot. Default is <code>:u</code>.</li><li><code>subspace::Union{Nothing, AbstractVector{Int}}</code>: If provided, only plot populations for these basis states (e.g., <code>1:2</code> for a qubit subspace). Useful for excluding leakage levels. Default is <code>nothing</code> (plot all levels).</li><li><code>kwargs...</code>: Additional keyword arguments passed to <a href="https://docs.harmoniqs.co/NamedTrajectories/dev/generated/plotting/"><code>NamedTrajectories.plot</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li>A Makie <code>Figure</code> object containing the population plots for all selected states.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using NamedTrajectories
using Piccolo
using Piccolo

# Example: Two initial states evolving under the same controls
N = 100
Œît = 0.1

# Initial states
œà1_init = ComplexF64[1, 0, 0]  # |0‚ü©
œà2_init = ComplexF64[0, 1, 0]  # |1‚ü©

# Create trajectory with multiple states
traj = NamedTrajectory(
    (
        œàÃÉ1_system_1 = hcat([ket_to_iso(œà1_init) for _ in 1:N]...),
        œàÃÉ2_system_1 = hcat([ket_to_iso(œà2_init) for _ in 1:N]...),
        u = randn(2, N),
        Œît = fill(Œît, N),
    );
    controls = :u,
    timestep = :Œît,
)

# Plot populations for all states
plot_state_populations(traj)

# Plot only computational subspace (excluding 3rd level)
plot_state_populations(traj; subspace=1:2)

# Plot only first state
plot_state_populations(traj; state_indices=[1])</code></pre><p>See also: <a href="#Piccolo.Visualizations.QuantumObjectPlots.plot_unitary_populations-Tuple{NamedTrajectory}"><code>plot_unitary_populations</code></a>, <a href="https://docs.harmoniqs.co/NamedTrajectories/dev/generated/plotting/"><code>NamedTrajectories.plot</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/visualizations/quantum_objects/state_populations.jl#L1-L101">source</a></section></details></article><article><details class="docstring"><summary id="Piccolo.Visualizations.QuantumObjectPlots.plot_unitary_populations-Tuple{NamedTrajectory}"><a class="docstring-binding" href="#Piccolo.Visualizations.QuantumObjectPlots.plot_unitary_populations-Tuple{NamedTrajectory}"><code>Piccolo.Visualizations.QuantumObjectPlots.plot_unitary_populations</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_unitary_populations(
    traj::NamedTrajectory;
    unitary_columns::AbstractVector{Int}=1:2,
    unitary_name::Symbol=:≈®‚Éó,
    control_name::Symbol=:u,
    kwargs...
)</code></pre><p>Plot the state populations for specified columns of a unitary operator trajectory.</p><p>This function visualizes how the populations (squared magnitudes) of quantum states evolve over time for selected columns of a unitary matrix stored in a <code>NamedTrajectory</code>.</p><p><strong>Mathematical Background</strong></p><p>For a unitary operator <span>$U(t) \in \mathcal{U}(n)$</span> evolving under a time-dependent Hamiltonian, this function plots the populations</p><p class="math-container">\[P_{i,j}(t) = |U_{i,j}(t)|^2\]</p><p>where <span>$U_{i,j}(t)$</span> is the <span>$(i,j)$</span>-th element of the unitary matrix at time <span>$t$</span>.</p><p>For a quantum system evolving according to the Schr√∂dinger equation</p><p class="math-container">\[\frac{d}{dt}U(t) = -iH(t)U(t), \quad U(0) = I\]</p><p>each column <span>$j$</span> of <span>$U(t)$</span> represents the time evolution of the initial basis state <span>$|j\rangle$</span>:</p><p class="math-container">\[|\psi_j(t)\rangle = U(t)|j\rangle = \sum_{i=1}^{n} U_{i,j}(t)|i\rangle\]</p><p>The population <span>$P_{i,j}(t) = |U_{i,j}(t)|^2$</span> gives the probability of finding the system in state <span>$|i\rangle$</span> at time <span>$t$</span> given that it started in state <span>$|j\rangle$</span>.</p><p><strong>Key Properties:</strong></p><ul><li>Unitarity ensures <span>$\sum_{i=1}^{n} P_{i,j}(t) = 1$</span> for all <span>$j$</span> and <span>$t$</span> (probability conservation)</li><li><span>$P_{i,j}(0) = \delta_{ij}$</span> (initially in definite state)</li><li>Populations are real and bounded: <span>$P_{i,j}(t) \in [0,1]$</span></li></ul><p>The trajectory stores <span>$U(t)$</span> in isomorphism representation <span>$\tilde{U}(t)$</span>, a vectorized form that preserves the operator structure while enabling efficient optimization algorithms.</p><p><strong>Arguments</strong></p><ul><li><code>traj::NamedTrajectory</code>: A trajectory containing a unitary operator in isomorphism representation.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>unitary_columns::AbstractVector{Int}</code>: Indices of unitary matrix columns to plot. Each column <span>$j$</span> corresponds to the evolution of basis state <span>$|j\rangle$</span>. Default is <code>1:2</code>.</li><li><code>unitary_name::Symbol</code>: The name of the unitary operator component in the trajectory, stored as an isomorphism vector (<span>$\tilde{U}$</span>). Default is <code>:≈®‚Éó</code>.</li><li><code>control_name::Symbol</code>: The name of the control signal component to include in the plot, typically the time-dependent control parameters <span>$u(t)$</span> in <span>$H(t) = H_0 + \sum_k u_k(t) H_k$</span>. Default is <code>:u</code>.</li><li><code>kwargs...</code>: Additional keyword arguments passed to <a href="https://docs.harmoniqs.co/NamedTrajectories/dev/generated/plotting/"><code>NamedTrajectories.plot</code></a>, such as <code>xlims</code>, <code>ylims</code>, or Makie-specific plotting options.</li></ul><p><strong>Returns</strong></p><ul><li>A Makie <code>Figure</code> object containing the population plots.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using NamedTrajectories
using Piccolo
using Piccolo

# Define Hamiltonian: H = X + a‚ÇÅ(t)Z + a‚ÇÇ(t)Y
H_drift = PAULIS[:X]
H_drives = [PAULIS[:Z], PAULIS[:Y]]

# Generate control trajectory
N = 100
Œît = 0.1
ts = collect(0:Œît:Œît*(N-1))
u = 0.1 * randn(2, length(ts))

# Generate unitaries
Us = exp.(-im * [(H_drift + sum(u[:, k] .* H_drives)) * ts[k] for k = 1:N])

# Create trajectory
traj = NamedTrajectory(
    (
        ≈®‚Éó = hcat(operator_to_iso_vec.(Us)...),
        u = u,
        Œît = ts,
    );
    controls = :u,
    timestep = :Œît,
)

# Plot populations for first two columns
plot_unitary_populations(traj)

# Plot only the first column
plot_unitary_populations(traj; unitary_columns=[1])</code></pre><p>See also: <a href="https://docs.harmoniqs.co/NamedTrajectories/dev/generated/plotting/"><code>NamedTrajectories.plot</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/Piccolo.jl/blob/35f4606df9b89a8010ec9f0d654d294114995b95/src/visualizations/quantum_objects/unitary_populations.jl#L1-L104">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reference/">¬´ Overview</a><a class="docs-footer-nextpage" href="../development/contributing/">Contributing ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Wednesday 25 February 2026 17:00">Wednesday 25 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
