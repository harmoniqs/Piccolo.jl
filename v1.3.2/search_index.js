var documenterSearchIndex = {"docs":
[{"location":"generated/multilevel_transmon/#multilevel-transmon-tutorial","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"In this example we will look at a multilevel transmon qubit with a Hamiltonian given by\n\nhatH(t) = -fracdelta2 hatn(hatn - 1) + u_1(t) (hata + hata^dagger) + u_2(t) i (hata - hata^dagger)\n\nwhere hatn = hata^dagger hata is the number operator, hata is the annihilation operator, delta is the anharmonicity, and u_1(t) and u_2(t) are control fields.\n\nWe will use the following parameter values:\n\nbeginaligned\ndelta = 02 text GHz\nabsu_i(t) leq 02 text GHz\nT_0 = 10 text ns\nendaligned\n\nFor convenience, we have defined the TransmonSystem function in the QuantumSystemTemplates module, which returns a QuantumSystem object for a transmon qubit. We will use this function to define the system.","category":"section"},{"location":"generated/multilevel_transmon/#Setting-up-the-problem","page":"Multilevel Transmon","title":"Setting up the problem","text":"To begin, let's load the necessary packages, define the system parameters, and create a QuantumSystem object using the TransmonSystem function.\n\nusing Piccolo\nusing SparseArrays\nusing Random;\nRandom.seed!(123);\n\nusing CairoMakie\n\n# define the time parameters\n\nT‚ÇÄ = 10     # total time in ns\nN = 50      # number of time steps\nŒît = T‚ÇÄ / N # time step\ntimes = collect(range(0, T‚ÇÄ, length = N))\n\n# define the system parameters\nlevels = 5\nŒ¥ = 0.2\n\n# add a bound to the controls\nu_bound = [0.2, 0.2]\nddu_bound = 1.0\n\n# create the system\nsys = TransmonSystem(drive_bounds = u_bound, levels = levels, Œ¥ = Œ¥)\n\n# let's look at the drives of the system\nget_drives(sys)[1] |> sparse\n\nSince this is a multilevel transmon and we want to implement an, let's say, X gate on the qubit subspace, i.e., the first two levels we can utilize the EmbeddedOperator type to define the target operator.\n\n# define the target operator\nop = EmbeddedOperator(:X, sys)\n\n# show the full operator\nop.operator |> sparse\n\nWe can then create a pulse, trajectory, and optimization problem using the new API:\n\n# create a random initial pulse\ninitial_controls = 0.1 * randn(2, N)\npulse = ZeroOrderPulse(initial_controls, times)\n\n# create a unitary trajectory with the embedded operator as goal\nqtraj = UnitaryTrajectory(sys, pulse, op)\n\n# create the optimization problem\nqcp = SmoothPulseProblem(qtraj, N; ddu_bound = ddu_bound, Q = 100.0, R = 1e-2)","category":"section"},{"location":"generated/multilevel_transmon/#Solving-the-problem","page":"Multilevel Transmon","title":"Solving the problem","text":"# We solve the problem using `cached_solve!`, which transparently caches the\n# optimized trajectory and solver output for docs purposes. In practice, you can use `solve!` directly.\n\ncached_solve!(qcp, \"multilevel_transmon\"; max_iter = 50)\n\nAfter optimization, we can check the fidelity in the subspace:\n\nfid = fidelity(qcp)\nprintln(\"Fidelity: \", fid)","category":"section"},{"location":"generated/multilevel_transmon/#Leakage-suppression","page":"Multilevel Transmon","title":"Leakage suppression","text":"As can be seen from multilevel systems, there can be substantial leakage into higher energy levels during the evolution. To mitigate this, Piccolo provides options to add leakage suppression via the PiccoloOptions type.\n\nTo implement leakage suppression, pass leakage_constraint=true and configure the leakage parameters:\n\n# create a leakage suppression problem\nqcp_leakage = SmoothPulseProblem(\n    qtraj,\n    N;\n    ddu_bound = ddu_bound,\n    Q = 100.0,\n    R = 1e-2,\n    piccolo_options = PiccoloOptions(\n        leakage_constraint = true,\n        leakage_constraint_value = 1e-2,\n        leakage_cost = 1e-2,\n    ),\n)\n\n# solve the problem\ncached_solve!(qcp_leakage, \"multilevel_transmon_leakage\"; max_iter = 50)\n\nThe leakage suppression adds:\n\nAn L1-norm cost on populating leakage levels (drives populations toward zero)\nA constraint that keeps leakage below the specified threshold\n\nfid_leakage = fidelity(qcp_leakage)\nprintln(\"Fidelity with leakage suppression: \", fid_leakage)","category":"section"},{"location":"generated/multilevel_transmon/#Visualizing-Results","page":"Multilevel Transmon","title":"Visualizing Results","text":"Piccolo provides plotting utilities to visualize the unitary evolution. First, without leakage suppression:\n\nplot_unitary_populations(get_trajectory(qcp); fig_size = (900, 700))\n\nAnd with leakage suppression ‚Äî you should see the population staying mostly within the computational subspace (first two levels):\n\nplot_unitary_populations(get_trajectory(qcp_leakage); fig_size = (900, 700))","category":"section"},{"location":"generated/multilevel_transmon/#Summary","page":"Multilevel Transmon","title":"Summary","text":"This tutorial demonstrated:\n\nUsing TransmonSystem to create a realistic multilevel transmon system\nUsing EmbeddedOperator to define gates on a subspace\nCreating UnitaryTrajectory with ZeroOrderPulse\nUsing SmoothPulseProblem to set up the optimization\nAdding leakage suppression via PiccoloOptions\n\nFor more details on:\n\nProblem templates: See SmoothPulseProblem\nLeakage suppression: See Leakage Suppression\nQuantum systems: See Transmon Qubits\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"lib/#Library-Reference","page":"Library","title":"Library Reference","text":"Full docstring reference for all public types and functions in Piccolo.jl.","category":"section"},{"location":"lib/#lib-quantum-systems","page":"Library","title":"Quantum Systems","text":"","category":"section"},{"location":"lib/#lib-quantum-system-templates","page":"Library","title":"Quantum System Templates","text":"","category":"section"},{"location":"lib/#lib-quantum-system-utils","page":"Library","title":"Quantum System Utilities","text":"","category":"section"},{"location":"lib/#lib-gates","page":"Library","title":"Gates and Pauli Matrices","text":"","category":"section"},{"location":"lib/#lib-quantum-object-utils","page":"Library","title":"Quantum Object Utilities","text":"","category":"section"},{"location":"lib/#lib-trajectories","page":"Library","title":"Trajectories","text":"","category":"section"},{"location":"lib/#lib-pulses","page":"Library","title":"Pulses","text":"","category":"section"},{"location":"lib/#lib-rollouts","page":"Library","title":"Rollouts","text":"","category":"section"},{"location":"lib/#lib-embedded-operators","page":"Library","title":"Embedded Operators","text":"","category":"section"},{"location":"lib/#lib-lifted-operators","page":"Library","title":"Lifted Operators","text":"","category":"section"},{"location":"lib/#lib-direct-sums","page":"Library","title":"Direct Sums","text":"","category":"section"},{"location":"lib/#lib-isomorphisms","page":"Library","title":"Isomorphisms","text":"","category":"section"},{"location":"lib/#lib-quantum-control-problems","page":"Library","title":"Quantum Control Problems","text":"","category":"section"},{"location":"lib/#lib-problem-templates","page":"Library","title":"Problem Templates","text":"","category":"section"},{"location":"lib/#lib-objectives","page":"Library","title":"Objectives","text":"","category":"section"},{"location":"lib/#lib-constraints","page":"Library","title":"Constraints","text":"","category":"section"},{"location":"lib/#lib-options","page":"Library","title":"Options","text":"","category":"section"},{"location":"lib/#lib-visualizations","page":"Library","title":"Visualizations","text":"","category":"section"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.AbstractDrive","page":"Library","title":"Piccolo.Quantum.QuantumSystems.AbstractDrive","text":"AbstractDrive\n\nAbstract supertype for Hamiltonian drive terms.\n\nA drive pairs a Hermitian matrix H with a scalar coefficient that depends on the control vector u. The full Hamiltonian is:\n\nH(u, t) = H_drift + Œ£_d drive_coeff(d, u) * d.H\n\nSubtypes must implement:\n\ndrive_coeff(d, u) ‚Äî compute the scalar coefficient\ndrive_coeff_jac(d, u, j) ‚Äî compute ‚àÇcoeff/‚àÇu_j\nactive_controls(d) ‚Äî return indices where ‚àÇcoeff/‚àÇu_j can be nonzero\n\nSee LinearDrive and NonlinearDrive.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.AbstractQuantumSystem","page":"Library","title":"Piccolo.Quantum.QuantumSystems.AbstractQuantumSystem","text":"AbstractQuantumSystem\n\nAbstract type for defining systems.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem","page":"Library","title":"Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem <: AbstractQuantumSystem\n\nA composite quantum system consisting of multiple subsystems with optional coupling terms.\n\nComposite systems represent multiple quantum subsystems (e.g., multiple qubits or oscillators) that may be coupled together. Each subsystem's Hamiltonians are automatically lifted to the  full tensor product space, and subsystem drives are appended to any coupling drives.\n\nFields\n\nH::Function: The total Hamiltonian function: (u, t) -> H(u, t)\nG::Function: The isomorphic generator function: (u, t) -> G(u, t)\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The total drift Hamiltonian including subsystem drifts and couplings\nH_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}: All drive Hamiltonians (coupling drives + subsystem drives)\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds for each control\nn_drives::Int: Total number of control drives\nlevels::Int: Total dimension of the composite system (product of subsystem dimensions)\nsubsystem_levels::Vector{Int}: Dimensions of each subsystem\nsubsystems::Vector{QuantumSystem}: The individual quantum subsystems\n\nSee also Lifted Operators, lift_operator.\n\nExample\n\n# Two qubits with ZZ coupling\nsys1 = QuantumSystem([PAULIS[:X]], [(-1.0, 1.0)])\nsys2 = QuantumSystem([PAULIS[:Y]], [(-1.0, 1.0)])\nH_coupling = 0.1 * kron(PAULIS[:Z], PAULIS[:Z])\ncsys = CompositeQuantumSystem(H_coupling, [sys1, sys2], Float64[])\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}, AbstractVector{<:QuantumSystem}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    H_drift::AbstractMatrix,\n    H_drives::AbstractVector{<:AbstractMatrix},\n    subsystems::AbstractVector{<:QuantumSystem},\n    drive_bounds::DriveBounds\n)\n\nConstruct a CompositeQuantumSystem with coupling drift and drive terms.\n\nArguments\n\nH_drift::AbstractMatrix: Coupling drift Hamiltonian (in full tensor product space)\nH_drives::AbstractVector{<:AbstractMatrix}: Coupling drive Hamiltonians\nsubsystems::AbstractVector{<:QuantumSystem}: Vector of subsystems to compose\ndrive_bounds::DriveBounds: Drive bounds for the coupling drives (subsystem bounds are inherited). Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nThe total drift includes both the coupling drift and all subsystem drifts (automatically lifted). The total drives include coupling drives followed by all subsystem drives (automatically lifted).\n\nExample\n\nsys1 = QuantumSystem(PAULIS[:Z], [PAULIS[:X]], [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], [1.0])\ng12 = 0.1 * kron(PAULIS[:X], PAULIS[:X])  # coupling drift\ncsys = CompositeQuantumSystem(g12, Matrix{ComplexF64}[], [sys1, sys2], Float64[])\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Tuple{AbstractVector{<:QuantumSystem}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    subsystems::AbstractVector{<:QuantumSystem},\n    drive_bounds::DriveBounds\n)\n\nConvenience constructor for a composite system with no coupling terms (neither drift nor drives).\n\nUse this when you have independent subsystems that you want to represent in a single composite space, but without any direct coupling between them.\n\nArguments\n\nsubsystems::AbstractVector{<:QuantumSystem}: Vector of subsystems to compose\ndrive_bounds::DriveBounds: Drive bounds for the coupling drives (typically empty). Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], [1.0])\ncsys = CompositeQuantumSystem([sys1, sys2], Float64[])\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{<:QuantumSystem}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where T<:Number","page":"Library","title":"Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    H_drift::AbstractMatrix,\n    subsystems::AbstractVector{<:QuantumSystem},\n    drive_bounds::DriveBounds\n)\n\nConvenience constructor for a composite system with coupling drift but no coupling drives.\n\nArguments\n\nH_drift::AbstractMatrix: Coupling drift Hamiltonian\nsubsystems::AbstractVector{<:QuantumSystem}: Vector of subsystems to compose\ndrive_bounds::DriveBounds: Drive bounds for the coupling drives (typically empty). Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], [1.0])\nH_coupling = 0.1 * kron(PAULIS[:Z], PAULIS[:Z])  # coupling drift\ncsys = CompositeQuantumSystem(H_coupling, [sys1, sys2], Float64[])\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Union{Tuple{T}, Tuple{AbstractVector{<:AbstractMatrix{T}}, AbstractVector{<:QuantumSystem}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where T<:Number","page":"Library","title":"Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    H_drives::AbstractVector{<:AbstractMatrix},\n    subsystems::AbstractVector{<:QuantumSystem},\n    drive_bounds::DriveBounds\n)\n\nConvenience constructor for a composite system with coupling drives but no coupling drift.\n\nArguments\n\nH_drives::AbstractVector{<:AbstractMatrix}: Coupling drive Hamiltonians\nsubsystems::AbstractVector{<:QuantumSystem}: Vector of subsystems to compose\ndrive_bounds::DriveBounds: Drive bounds for the coupling drives. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], [1.0])\ng12 = 0.1 * kron(PAULIS[:X], PAULIS[:X])  # coupling drive\ncsys = CompositeQuantumSystem([g12], [sys1, sys2], [1.0])  # symmetric bound\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.DriveBounds","page":"Library","title":"Piccolo.Quantum.QuantumSystems.DriveBounds","text":"DriveBounds\n\nType alias for drive amplitude bounds input. Bounds can be specified as:\n\nA tuple (lower, upper) for asymmetric bounds\nA scalar value which is interpreted as symmetric bounds (-value, value)\n\nExamples\n\ndrive_bounds = [(-1.0, 1.0), 0.5, (-0.3, 0.7)]\n# Interpreted as: [(-1.0, 1.0), (-0.5, 0.5), (-0.3, 0.7)]\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.LinearDrive","page":"Library","title":"Piccolo.Quantum.QuantumSystems.LinearDrive","text":"LinearDrive <: AbstractDrive\n\nStandard linear drive: coefficient is u[index].\n\nThis is the default representation when constructing QuantumSystem(H_drift, H_drives, bounds).\n\nFields\n\nH::SparseMatrixCSC{ComplexF64,Int}: The Hermitian drive operator\nindex::Int: Index into the control vector u\n\nExample\n\nLinearDrive(sparse(PAULIS.X), 1)  # u[1] * œÉx\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.NonlinearDrive","page":"Library","title":"Piccolo.Quantum.QuantumSystems.NonlinearDrive","text":"NonlinearDrive{F,DF} <: AbstractDrive\n\nDrive term with a nonlinear scalar coefficient: f(u) * H.\n\nThe user provides either:\n\nBoth the coefficient function and its Jacobian (3-arg form), or\nJust the coefficient function (2-arg form) ‚Äî the Jacobian is computed automatically via ForwardDiff.\n\nFields\n\nH::SparseMatrixCSC{ComplexF64,Int}: The Hermitian drive operator\ncoeff::F: (u::AbstractVector) -> scalar ‚Äî coefficient function\ncoeff_jac::DF: (u::AbstractVector, j::Int) -> scalar ‚Äî ‚àÇcoeff/‚àÇu_j\nactive_controls::Vector{Int}: Control indices where ‚àÇcoeff/‚àÇu_j can be nonzero. Empty means \"all controls\" (no structural sparsity info).\n\nExample: Auto-Jacobian (recommended)\n\nNonlinearDrive(œÉz / 2, u -> u[3]^2 + u[4]^2)\n\nExample: Manual Jacobian with active controls\n\nNonlinearDrive(\n    œÉz / 2,\n    u -> u[3]^2 + u[4]^2,\n    (u, j) -> j == 3 ? 2u[3] : j == 4 ? 2u[4] : 0.0;\n    active_controls = [3, 4]\n)\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.NonlinearDrive-Union{Tuple{DF}, Tuple{F}, Tuple{AbstractMatrix, F, DF}} where {F, DF}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.NonlinearDrive","text":"NonlinearDrive(H::AbstractMatrix, coeff, coeff_jac; active_controls=Int[])\n\nConstruct a NonlinearDrive with an explicit Jacobian function. active_controls lists which control indices have nonzero ‚àÇcoeff/‚àÇu_j (empty = all).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.NonlinearDrive-Union{Tuple{F}, Tuple{AbstractMatrix, F}} where F","page":"Library","title":"Piccolo.Quantum.QuantumSystems.NonlinearDrive","text":"NonlinearDrive(H::AbstractMatrix, coeff; active_controls=Int[])\n\nConstruct a NonlinearDrive with an auto-generated Jacobian via ForwardDiff.\n\nThis is the recommended constructor ‚Äî the Jacobian is computed automatically from the coefficient function, eliminating the risk of hand-written Jacobian errors.\n\nExample\n\n# Displaced-frame Stark shift: coefficient = u‚ÇÉ¬≤ + u‚ÇÑ¬≤\ndrive = NonlinearDrive(œÉz / 2, u -> u[3]^2 + u[4]^2; active_controls = [3, 4])\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","page":"Library","title":"Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem <: AbstractQuantumSystem\n\nA struct for storing open quantum dynamics.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t)\nùí¢::Function: The Lindbladian generator function: u -> ùí¢(u)\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The drift Hamiltonian\nH_drives::Vector{AbstractDrive}: The canonical drive terms, each pairing an operator with a coefficient function. Matrix-based constructors auto-populate this with LinearDrive objects; function-based systems leave it empty.\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds\nn_drives::Int: The number of control drives\nlevels::Int: The number of levels in the system\ndissipation_operators::Vector{SparseMatrixCSC{ComplexF64, Int}}: The dissipation operators\ntime_dependent::Bool: Whether the Hamiltonian has explicit time dependence\nglobal_params::NamedTuple: Global parameters stored with the system (e.g., physical constants)\n\nSee also QuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Tuple{AbstractMatrix{<:Number}, Vector{<:AbstractDrive}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(\n    H_drift::AbstractMatrix,\n    drives::Vector{<:AbstractDrive},\n    drive_bounds::DriveBounds;\n    dissipation_operators=Matrix{ComplexF64}[],\n    time_dependent::Bool=false,\n    global_params::NamedTuple=NamedTuple()\n)\n\nConstruct an OpenQuantumSystem from a drift Hamiltonian and typed drive terms.\n\nThis constructor supports both linear and nonlinear drives. The control dimension is determined by length(drive_bounds), which may differ from length(drives) when nonlinear drives combine multiple controls.\n\nExample\n\nL_ops = [sqrt(Œ≥) * annihilate(levels)]\ndrives = [\n    LinearDrive(sparse(œÉx), 1),\n    NonlinearDrive(œÉz, u -> u[1]^2 + u[2]^2),\n]\nsys = OpenQuantumSystem(H_drift, drives, [1.0, 1.0]; dissipation_operators=L_ops)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Tuple{AbstractMatrix{<:Number}, Vector{<:AbstractMatrix{<:Number}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::AbstractVector{<:AbstractMatrix{<:Number}},\n    drive_bounds::DriveBounds;\n    dissipation_operators=Matrix{ComplexF64}[],\n    time_dependent::Bool=false,\n    global_params::NamedTuple=NamedTuple()\n)\nOpenQuantumSystem(\n    H_drift::AbstractMatrix{<:Number};\n    dissipation_operators=Matrix{ComplexF64}[],\n    time_dependent::Bool=false,\n    global_params::NamedTuple=NamedTuple()\n)\nOpenQuantumSystem(\n    H_drives::Vector{<:AbstractMatrix{<:Number}},\n    drive_bounds::DriveBounds;\n    dissipation_operators=Matrix{ComplexF64}[],\n    time_dependent::Bool=false,\n    global_params::NamedTuple=NamedTuple()\n)\nOpenQuantumSystem(\n    H::Function,\n    drive_bounds::DriveBounds;\n    dissipation_operators=Matrix{ComplexF64}[],\n    time_dependent::Bool=false,\n    global_params::NamedTuple=NamedTuple()\n)\nOpenQuantumSystem(\n    system::QuantumSystem;\n    dissipation_operators=Matrix{ComplexF64}[]\n)\n\nConstructs an OpenQuantumSystem object from the drift and drive Hamiltonian terms and dissipation operators.\n\nDrive Bounds\n\nThe drive_bounds parameter can be:\n\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Tuple{QuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(system::QuantumSystem; dissipation_operators=[])\n\nConstruct an OpenQuantumSystem from a QuantumSystem by adding dissipation operators.\n\nWhen the QuantumSystem has typed drives (including nonlinear), they are preserved in the resulting OpenQuantumSystem.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(H_drift; dissipation_operators=[], time_dependent=false)\n\nConstruct an OpenQuantumSystem with only drift (no drives).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{F}, Tuple{F, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where {F<:Function, ‚ÑÇ<:Number}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(H::Function, drive_bounds; dissipation_operators=[], time_dependent=false)\n\nConstruct an OpenQuantumSystem from a Hamiltonian function.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{Vector{<:AbstractMatrix{‚ÑÇ}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where ‚ÑÇ<:Number","page":"Library","title":"Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(H_drives, drive_bounds; dissipation_operators=[], time_dependent=false)\n\nConstruct an OpenQuantumSystem with no drift.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.QuantumSystem","page":"Library","title":"Piccolo.Quantum.QuantumSystems.QuantumSystem","text":"QuantumSystem <: AbstractQuantumSystem\n\nA struct for storing quantum dynamics.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t), where u is the control vector and t is time\nG::Function: The isomorphic generator function: (u, t) -> G(u, t), including the Hamiltonian mapped to superoperator space\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The drift Hamiltonian (time-independent component)\nH_drives::Vector{AbstractDrive}: The canonical drive terms, each pairing an operator with a coefficient function. Matrix-based constructors auto-populate this with LinearDrive objects; function-based systems leave it empty.\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds for each control (lower, upper)\nn_drives::Int: The number of control channels (length of the control vector u)\nlevels::Int: The number of levels (dimension) in the system\ntime_dependent::Bool: Whether the Hamiltonian has explicit time dependence beyond control modulation\nglobal_params::NamedTuple: Global parameters that the Hamiltonian may depend on (e.g., (Œ¥=0.5, Œ©=1.0))\n\nSee also OpenQuantumSystem, VariationalQuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.QuantumSystem-Tuple{AbstractMatrix{<:Number}, Vector{<:AbstractDrive}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.QuantumSystem","text":"QuantumSystem(\n    H_drift::AbstractMatrix,\n    drives::Vector{<:AbstractDrive},\n    drive_bounds::Vector;\n    time_dependent::Bool=false,\n    global_params::NamedTuple=NamedTuple()\n)\n\nConstruct a QuantumSystem from a drift Hamiltonian and typed drive terms.\n\nThis constructor supports both linear and nonlinear drives. The control dimension is determined by length(drive_bounds), which may differ from length(drives) when nonlinear drives combine multiple controls.\n\nThe resulting Hamiltonian is: H(u, t) = Hdrift + Œ£d drive_coeff(d, u) * d.H\n\nArguments\n\nH_drift::AbstractMatrix: The drift (time-independent) Hamiltonian\ndrives::Vector{<:AbstractDrive}: Vector of drive terms (LinearDrive or NonlinearDrive)\ndrive_bounds::DriveBounds: Bounds for each physical control. Length = control dimension.\n\nExample: Displaced frame with nonlinear |Œ±|¬≤ term\n\nsys = QuantumSystem(\n    H_drift,\n    [\n        LinearDrive(sparse(œÉx), 1),                    # u[1] * œÉx (qubit I)\n        LinearDrive(sparse(œÉy), 2),                    # u[2] * œÉy (qubit Q)\n        LinearDrive(sparse(œá * Xa * œÉz), 3),           # u[3] * œá¬∑Xa¬∑œÉz (displacement I)\n        LinearDrive(sparse(œá * Pa * œÉz), 4),           # u[4] * œá¬∑Pa¬∑œÉz (displacement Q)\n        NonlinearDrive(                                 # (u[3]¬≤+u[4]¬≤) * œá¬∑œÉz/2\n            sparse(œá * œÉz / 2),\n            u -> u[3]^2 + u[4]^2,\n            (u, j) -> j == 3 ? 2u[3] : j == 4 ? 2u[4] : 0.0\n        ),\n    ],\n    [Œ©_bound, Œ©_bound, Œ±_bound, Œ±_bound]  # 4 physical controls\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.QuantumSystem-Tuple{AbstractMatrix{<:Number}, Vector{<:AbstractMatrix{<:Number}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.QuantumSystem","text":"QuantumSystem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::Vector{<:AbstractMatrix{<:Number}},\n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}};\n    time_dependent::Bool=false\n)\n\nConstruct a QuantumSystem from drift and drive Hamiltonian terms.\n\nArguments\n\nH_drift::AbstractMatrix: The drift (time-independent) Hamiltonian\nH_drives::Vector{<:AbstractMatrix}: Vector of drive Hamiltonians, one for each control\ndrive_bounds::DriveBounds: Drive amplitude bounds for each control. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nKeyword Arguments\n\ntime_dependent::Bool=false: Set to true if using time-dependent modulation (typically handled at a higher level)\nglobal_params::NamedTuple=NamedTuple(): Global parameters stored with the system. Note: for matrix-based systems, matrices are fixed at construction, so globalparams are mainly for storage/bookkeeping and later updates via `updateglobal_params!`\n\nThe resulting Hamiltonian is: H(u, t) = Hdrift + Œ£·µ¢ u·µ¢ * Hdrives[i]\n\nExample\n\nsys = QuantumSystem(\n    PAULIS[:Z],                    # drift\n    [PAULIS[:X], PAULIS[:Y]],      # drives\n    [1.0, 1.0]                     # symmetric bounds: [(-1.0, 1.0), (-1.0, 1.0)]\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.QuantumSystem-Tuple{Function, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.QuantumSystem","text":"QuantumSystem(H::Function, drive_bounds::Vector; time_dependent::Bool=false)\n\nConstruct a QuantumSystem from a Hamiltonian function.\n\nArguments\n\nH::Function: Hamiltonian function with signature (u, t) -> H(u, t) where:\nu is a vector containing [controls..., globals...] (if system has global parameters)\nFor matrix-based systems, only the first n_drives elements are used for controls\nFor function-based systems, handle globals via closure or by accessing u beyond control indices\nt is time\ndrive_bounds::DriveBounds: Drive amplitude bounds for each control. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nKeyword Arguments\n\ntime_dependent::Bool=false: Set to true if the Hamiltonian has explicit time dependence (e.g., cos(œât) modulation)\nglobal_params::NamedTuple=NamedTuple(): Global parameters stored with the system for bookkeeping\n\nExample\n\n# Define a time-dependent Hamiltonian\nH = (u, t) -> PAULIS[:Z] + u[1] * cos(œâ * t) * PAULIS[:X]\nsys = QuantumSystem(H, [(-1.0, 1.0)]; time_dependent=true)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.QuantumSystem-Tuple{Vector{<:AbstractDrive}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.QuantumSystem","text":"QuantumSystem(drives::Vector{<:AbstractDrive}, drive_bounds::Vector; time_dependent::Bool=false)\n\nConvenience constructor for a typed-drive system with no drift Hamiltonian (H_drift = 0).\n\nExample\n\nsys = QuantumSystem([LinearDrive(sparse(PAULIS[:X]), 1)], [1.0])\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.QuantumSystem-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"Piccolo.Quantum.QuantumSystems.QuantumSystem","text":"QuantumSystem(H_drift::AbstractMatrix; time_dependent::Bool=false)\n\nConvenience constructor for a system with only a drift Hamiltonian (no drives).\n\nExample\n\nsys = QuantumSystem(PAULIS[:Z])\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.QuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{Vector{<:AbstractMatrix{‚ÑÇ}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where ‚ÑÇ<:Number","page":"Library","title":"Piccolo.Quantum.QuantumSystems.QuantumSystem","text":"QuantumSystem(H_drives::Vector{<:AbstractMatrix}, drive_bounds::Vector; time_dependent::Bool=false)\n\nConvenience constructor for a system with no drift Hamiltonian (H_drift = 0).\n\nArguments\n\nH_drives::Vector{<:AbstractMatrix}: Vector of drive Hamiltonians\ndrive_bounds::DriveBounds: Drive amplitude bounds for each control. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nExample\n\n# Using scalars for symmetric bounds\nsys = QuantumSystem([PAULIS[:X], PAULIS[:Y]], [1.0, 1.0])\n# Equivalent to: drive_bounds = [(-1.0, 1.0), (-1.0, 1.0)]\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem","page":"Library","title":"Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem","text":"VariationalQuantumSystem <: AbstractQuantumSystem\n\nA struct for storing variational quantum dynamics, used for sensitivity and robustness analysis.\n\nVariational systems allow exploring how the dynamics change under perturbations to the Hamiltonian. The variational operators represent directions of uncertainty or perturbation in the system.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t)\nG::Function: The isomorphic generator function: (u, t) -> G(u, t)\nG_vars::AbstractVector{<:Function}: Variational generator functions, one for each perturbation direction\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds\nn_drives::Int: The number of control drives in the system\nlevels::Int: The number of levels (dimension) in the system\n\nSee also QuantumSystem, OpenQuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}, AbstractVector{<:AbstractMatrix{<:Number}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem","text":"VariationalQuantumSystem(\n    H_drift::AbstractMatrix,\n    H_drives::AbstractVector{<:AbstractMatrix},\n    H_vars::AbstractVector{<:AbstractMatrix},\n    drive_bounds::DriveBounds\n)\n\nConstruct a VariationalQuantumSystem from drift, drive, and variational Hamiltonian terms.\n\nArguments\n\nH_drift::AbstractMatrix: The drift (time-independent) Hamiltonian\nH_drives::AbstractVector{<:AbstractMatrix}: Vector of drive Hamiltonians for control\nH_vars::AbstractVector{<:AbstractMatrix}: Vector of variational Hamiltonians representing perturbation directions\ndrive_bounds::DriveBounds: Drive amplitude bounds for each control. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nThe variational operators allow sensitivity analysis by exploring how dynamics change under perturbations: Hperturbed = H + Œ£·µ¢ Œµ·µ¢ * Hvars[i]\n\nExample\n\nvarsys = VariationalQuantumSystem(\n    PAULIS[:Z],                    # drift\n    [PAULIS[:X], PAULIS[:Y]],      # drives\n    [PAULIS[:X]],                  # variational perturbations\n    [1.0, 1.0]                     # symmetric bounds: [(-1.0, 1.0), (-1.0, 1.0)]\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems._float_params-Union{Tuple{NamedTuple{K}}, Tuple{K}} where K","page":"Library","title":"Piccolo.Quantum.QuantumSystems._float_params","text":"_float_params(nt::NamedTuple)\n\nConvert all values in a NamedTuple to their floating-point equivalents. Ensures type-stable ODE solutions when global parameters are updated during optimization.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems._forwarddiff_jacobian-Tuple{F} where F","page":"Library","title":"Piccolo.Quantum.QuantumSystems._forwarddiff_jacobian","text":"_forwarddiff_jacobian(f) -> (u, j) -> ‚àÇf/‚àÇu_j\n\nCreate a Jacobian function from a scalar-valued function f(u) using ForwardDiff.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.active_controls-Tuple{LinearDrive}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.active_controls","text":"active_controls(d::AbstractDrive) -> Vector{Int}\n\nReturn the control indices where drive_coeff_jac(d, u, j) can be nonzero. An empty vector means \"all controls\" (no structural sparsity information available).\n\nFor LinearDrive, returns [d.index]. For NonlinearDrive, returns d.active_controls (user-specified or empty).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.compact_lindbladian_generators-Tuple{OpenQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.compact_lindbladian_generators","text":"compact_lindbladian_generators(sys::OpenQuantumSystem)\n\nCompute the compact Lindbladian generators for use with the compact density isomorphism. Returns (ùí¢c_drift, ùí¢c_drives) where:\n\nùí¢c_drift = P * (ùí¢_drift + ùíü) * L ‚Äî compact drift + dissipation generator (n¬≤ √ó n¬≤)\nùí¢c_drives[i] ‚Äî compact generator for each drive term (each n¬≤ √ó n¬≤)\n\nFor linear-only systems, ùí¢c_drives[i] corresponds to control u[i]. For systems with nonlinear drives, ùí¢c_drives[i] corresponds to drive term i, and must be weighted by drive_coeff(sys.H_drives[i], u) instead of u[i].\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.drive_coeff-Tuple{LinearDrive, AbstractVector}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.drive_coeff","text":"drive_coeff(d::AbstractDrive, u::AbstractVector) -> Number\n\nCompute the scalar coefficient of this drive at controls u.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.drive_coeff_jac-Tuple{LinearDrive, AbstractVector, Int64}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.drive_coeff_jac","text":"drive_coeff_jac(d::AbstractDrive, u::AbstractVector, j::Int) -> Number\n\nCompute ‚àÇcoeff/‚àÇu_j at controls u.\n\nFor LinearDrive: returns 1.0 if j == d.index, 0.0 otherwise (Kronecker delta). For NonlinearDrive: evaluates the Jacobian function (user-provided or auto-generated).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.get_drift-Tuple{AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.get_drift","text":"get_drift(sys::AbstractQuantumSystem)\n\nReturns the drift Hamiltonian of the system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.get_drive_terms-Tuple{AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.get_drive_terms","text":"get_drive_terms(sys::AbstractQuantumSystem) -> Vector{AbstractDrive}\n\nReturn the typed drive terms from the system. Each AbstractDrive pairs a Hamiltonian operator with a scalar coefficient function and Jacobian.\n\nReturns sys.H_drives directly when available, or an empty vector for function-based systems that don't use typed drives.\n\nSee also get_drives for just the Hamiltonian matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.get_drives-Tuple{AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.get_drives","text":"get_drives(sys::AbstractQuantumSystem)\n\nReturns the drive Hamiltonian matrices of the system.\n\nFor systems with typed drives (sys.H_drives), returns the H matrix from each drive term. For function-based systems without drives, extracts operators via basis vector evaluation.\n\nnote: Note\nWhen nonlinear drives are present, the number of returned matrices may differ from sys.n_drives (the control dimension). For example, a system with 2 controls and 3 drive terms (2 linear + 1 nonlinear) returns 3 matrices. Use get_drive_terms to access the full AbstractDrive objects with coefficient functions, Jacobians, and active control indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.has_nonlinear_drives-Tuple{AbstractVector{<:AbstractDrive}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.has_nonlinear_drives","text":"has_nonlinear_drives(drives::Vector{<:AbstractDrive}) -> Bool\n\nCheck if any drive terms are nonlinear.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.is_hermitian-Tuple{AbstractMatrix}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.is_hermitian","text":"is_hermitian(H::AbstractMatrix; tol=1e-10)\n\nCheck if a matrix is Hermitian within a tolerance.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.normalize_drive_bounds-Tuple{Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.normalize_drive_bounds","text":"normalize_drive_bounds(bounds::DriveBounds)\n\nConvert drive bounds to a consistent tuple format. Scalar values are converted to  symmetric bounds around zero: b becomes (-b, b).\n\nArguments\n\nbounds::DriveBounds: Input bounds, can be tuples or scalars\n\nReturns\n\nVector{Tuple{Float64, Float64}}: Normalized bounds as tuples\n\nExamples\n\n# All scalars (symmetric bounds)\nnormalize_drive_bounds([1.0, 1.5, 0.5])\n# Returns: [(-1.0, 1.0), (-1.5, 1.5), (-0.5, 0.5)]\n\n# All tuples (asymmetric bounds)\nnormalize_drive_bounds([(-2.0, 3.0), (-1.0, 1.0)])\n# Returns: [(-2.0, 3.0), (-1.0, 1.0)]\n\n# Mixed types (requires explicit type annotation)\nnormalize_drive_bounds(Union{Float64, Tuple{Float64,Float64}}[1.0, (-2.0, 3.0)])\n# Returns: [(-1.0, 1.0), (-2.0, 3.0)]\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.validate_drive_jacobian-Tuple{NonlinearDrive, Int64}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.validate_drive_jacobian","text":"validate_drive_jacobian(d::NonlinearDrive, n_controls::Int; atol=1e-6, n_samples=3)\n\nSpot-check the Jacobian of a NonlinearDrive against ForwardDiff at random control vectors. Throws an AssertionError if the user-provided Jacobian disagrees with the AD Jacobian.\n\nThis is called automatically during QuantumSystem construction for all NonlinearDrive terms, catching sign errors or off-by-one bugs early.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.CatSystem-Tuple{}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.CatSystem","text":"CatSystem(;\n    g2=0.36, œá_aa=-7e-3, œá_bb=-32, œá_ab=0.79,\n    Œ∫a=53e-3, Œ∫b=13,\n    cat_levels=13, buffer_levels=3,\n    prefactor=1, drive_bounds=[1.0, 1.0],\n)::OpenQuantumSystem\n\nConstruct an OpenQuantumSystem for a two-mode cat qubit (cat ‚äó buffer).\n\nHamiltonian\n\nThe drift Hamiltonian includes Kerr, cross-Kerr, and two-photon exchange terms:\n\nH = -fracchi_aa2 a^dagger 2 a^2\n    -fracchi_bb2 b^dagger 2 b^2\n    -chi_ab a^dagger a b^dagger b\n    + g_2 a^dagger 2 b\n    + g_2^* a^2 b^dagger\n\nThe two drives are the buffer displacement b + b^dagger and a Kerr correction a^dagger a.\n\nKeyword Arguments\n\ng2: Two-photon exchange coupling (MHz ¬∑ 2œÄ)\nœá_aa: Cat self-Kerr (MHz ¬∑ 2œÄ)\nœá_bb: Buffer self-Kerr (MHz ¬∑ 2œÄ)\nœá_ab: Cross-Kerr between cat and buffer (MHz ¬∑ 2œÄ)\nŒ∫a: Cat decay rate (MHz ¬∑ 2œÄ)\nŒ∫b: Buffer decay rate (MHz ¬∑ 2œÄ)\ncat_levels: Truncation of cat mode Fock space\nbuffer_levels: Truncation of buffer mode Fock space\nprefactor: Global scaling applied to all couplings and rates\ndrive_bounds: Bounds on the two drive amplitudes\n\nAll parameters are scaled by 2œÄ (Hamiltonian) or sqrt2œÄ (dissipators) internally.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.IonChainSystem-Tuple{}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.IonChainSystem","text":"IonChainSystem(;\n    N_ions::Int=2,\n    ion_levels::Int=2,\n    N_modes::Int=1,\n    mode_levels::Int=10,\n    œâq::Union{Float64, Vector{Float64}}=1.0,\n    œâm::Union{Float64, Vector{Float64}}=0.1,\n    Œ∑::Union{Float64, Matrix{Float64}}=0.1,\n    lab_frame::Bool=false,\n    frame_œâ::Float64=lab_frame ? 0.0 : (œâq isa Vector ? œâq[1] : œâq),\n    multiply_by_2œÄ::Bool=true,\n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}}=fill(1.0, 2*N_ions),\n) -> QuantumSystem\n\nReturns a QuantumSystem object for a chain of trapped ions coupled via motional modes.\n\nThe system consists of N_ions ions, each with ion_levels internal states, coupled to  N_modes shared motional modes with mode_levels Fock states each.\n\nHamiltonian\n\nIn the lab frame:\n\nH = sum_i=1^N_textions omega_qi sigma_i^+ sigma_i^- \n    + sum_m=1^N_textmodes omega_m a_m^dagger a_m\n    + sum_im eta_im (sigma_i^+ + sigma_i^-)(a_m + a_m^dagger)\n    + sum_i Omega_xi(t) sigma_i^x + sum_i Omega_yi(t) sigma_i^y\n\nIn the rotating frame at frequency frame_œâ:\n\nH = sum_i=1^N_textions (omega_qi - omega_textframe) sigma_i^+ sigma_i^- \n    + sum_m=1^N_textmodes omega_m a_m^dagger a_m\n    + sum_im eta_im (sigma_i^+ + sigma_i^-)(a_m + a_m^dagger)\n    + sum_i Omega_xi(t) sigma_i^x + sum_i Omega_yi(t) sigma_i^y\n\nwhere:\n\nsigma_i^+ sigma_i^- are raising/lowering operators for ion i\nsigma_i^x sigma_i^y are Pauli operators for ion i\na_m a_m^dagger are annihilation/creation operators for mode m\nomega_qi is the transition frequency of ion i\nomega_m is the frequency of motional mode m\neta_im is the Lamb-Dicke parameter coupling ion i to mode m\n\nKeyword Arguments\n\nN_ions: Number of ions in the chain\nion_levels: Number of internal levels per ion (typically 2 for qubit)\nN_modes: Number of motional modes to include\nmode_levels: Number of Fock states per motional mode\nœâq: Ion transition frequency (or frequencies). Scalar or vector of length N_ions. In GHz.\nœâm: Motional mode frequency (or frequencies). Scalar or vector of length N_modes. In GHz.\nŒ∑: Lamb-Dicke parameter(s). Scalar (uniform coupling), or N_ions √ó N_modes matrix.\nlab_frame: If true, use lab frame Hamiltonian. If false, use rotating frame.\nframe_œâ: Rotating frame frequency in GHz. Defaults to first ion frequency.\nmultiply_by_2œÄ: Whether to multiply Hamiltonian by 2œÄ (default true, since frequencies are in GHz).\ndrive_bounds: Control bounds. Vector of length 2*N_ions for [Œ©x‚ÇÅ, Œ©y‚ÇÅ, Œ©x‚ÇÇ, Œ©y‚ÇÇ, ...].\n\nExample\n\n# Two ions, one motional mode, M√∏lmer-S√∏rensen setup\nsys = IonChainSystem(\n    N_ions=2,\n    N_modes=1,\n    œâq=1.0,      # 1 GHz qubit frequency\n    œâm=0.1,      # 100 MHz mode frequency  \n    Œ∑=0.1,       # Lamb-Dicke parameter\n    mode_levels=5,\n)\n\nReferences\n\nS√∏rensen, A. & M√∏lmer, K. \"Quantum computation with ions in thermal motion.\"  Phys. Rev. Lett. 82, 1971 (1999).\nS√∏rensen, A. & M√∏lmer, K. \"Entanglement and quantum computation with ions in thermal motion.\" Phys. Rev. A 62, 022311 (2000).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.MolmerSorensenCoupling-Tuple{Int64, Int64, Int64, Int64, Union{Float64, Matrix{Float64}}, Union{Float64, Vector{Float64}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.MolmerSorensenCoupling","text":"MolmerSorensenCoupling(\n    N_ions::Int,\n    N_modes::Int,\n    ion_levels::Int,\n    mode_levels::Int,\n    Œ∑::Union{Float64, Matrix{Float64}},\n    œâm::Union{Float64, Vector{Float64}},\n) -> Matrix{ComplexF64}\n\nReturns the M√∏lmer-S√∏rensen coupling term for an ion chain, which mediates  effective ion-ion interactions via the motional modes.\n\nIn the Lamb-Dicke regime with appropriate drive detunings, the effective Hamiltonian is:\n\nH_textMS = sum_ij J_ij sigma_i^x sigma_j^x\n\nwhere the coupling strength is:\n\nJ_ij = sum_m fraceta_im eta_jm Omega_i Omega_j4 Delta_m\n\nwith Delta_m being the detuning from mode m.\n\nArguments\n\nN_ions: Number of ions\nN_modes: Number of motional modes\nion_levels: Internal levels per ion\nmode_levels: Fock states per mode\nŒ∑: Lamb-Dicke parameters (scalar or Nions √ó Nmodes matrix)\nœâm: Mode frequencies (scalar or vector)\n\nReturns\n\nMatrix representing the œÉÀ£·µ¢ œÉÀ£‚±º interaction for use in building MS gates.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.MultiTransmonSystem-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.MultiTransmonSystem","text":"MultiTransmonSystem(\n    œâs::AbstractVector{Float64},\n    Œ¥s::AbstractVector{Float64},\n    gs::AbstractMatrix{Float64};\n    drive_bounds::Union{Float64, Vector{<:Union{Tuple{Float64, Float64}, Float64}}}=1.0,\n    levels_per_transmon::Int = 3,\n    subsystem_levels::AbstractVector{Int} = fill(levels_per_transmon, length(œâs)),\n    lab_frame=false,\n    subsystems::AbstractVector{Int} = 1:length(œâs),\n    subsystem_drive_indices::AbstractVector{Int} = 1:length(œâs),\n    kwargs...\n) -> CompositeQuantumSystem\n\nReturns a CompositeQuantumSystem object for a multi-transmon system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.RadialMSGateSystem-Tuple{}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.RadialMSGateSystem","text":"RadialMSGateSystem(;\n    N_ions::Int=2,\n    mode_levels::Int=5,\n    œâm_radial::Vector{Float64}=[5.0, 5.0, 5.1, 5.1],  # 4 radial modes for 2 ions\n    Œ¥::Union{Float64, Vector{Float64}}=0.2,           # Detuning(s) from mode(s)\n    Œ∑::Union{Float64, Matrix{Float64}}=0.1,           # Lamb-Dicke parameters\n    multiply_by_2œÄ::Bool=true,\n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}}=fill(1.0, N_ions),\n) -> QuantumSystem\n\nReturns a time-dependent QuantumSystem for the radial-mode M√∏lmer-S√∏rensen gate  as described in the paper:\n\n\"Realization and Calibration of Continuously Parameterized Two-Qubit Gates on a  Trapped-Ion Quantum Processor\" (IEEE TQE 2024)\n\nThis implements the MS gate using only radial motional modes (not axial modes), which provides 2N modes for N ions (N modes along each of two transverse axes).\n\nHamiltonian (Equation 2 from paper)\n\nIn the interaction picture:\n\nH(t) = -fracihbar2 sum_ik sigma_xi eta_ki Omega_i a_k e^-idelta_k t + texthc\n\nExpanding the Hermitian conjugate:\n\nH(t) = -fraci2 sum_ik eta_ki Omega_i sigma_xi left(a_k e^-idelta_k t - a_k^dagger e^idelta_k tright)\n\nwhere:\n\nk\nindexes the 2N radial modes (N along x, N along y)\nsigma_xi\nis Pauli-X on ion i \neta_ki\nis the Lamb-Dicke parameter for ion i, mode k\nOmega_i(t)\nis the control amplitude (Rabi frequency) for ion i\ndelta_k\nis the detuning from motional sideband of mode k\na_k a_k^dagger\nare phonon operators for radial mode k\n\nRadial Mode Structure\n\nFor N ions in a linear trap with radial confinement:\n\nAxial modes (along trap axis): Not used for this gate\nRadial modes: 2N modes total\nN modes along transverse x-direction  \nN modes along transverse y-direction\n\nFor N=2 ions: 4 radial modes participate in the gate dynamics.\n\nTypical Parameters (Q-SCOUT platform at Sandia, ¬π‚Å∑¬πYb‚Å∫)\n\nRadial frequencies: omega_r  2pi sim 5 MHz (higher than axial ~2 MHz)\nLamb-Dicke: eta sim 005 - 015\nDetuning: delta  2pi sim 100 - 500 kHz\nGate time: 50 - 200 Œºs\nPhonon states: n_max = 3-5 typically sufficient\n\nKeyword Arguments\n\nN_ions: Number of ions (default: 2)\nmode_levels: Fock states per radial mode (default: 5)\nœâm_radial: Radial mode frequencies in GHz. Vector of length 2N.  Example for 2 ions: [5.0, 5.0, 5.1, 5.1] (nearly degenerate pairs)\nŒ¥: Detuning(s) from sideband in GHz. Scalar (uniform) or vector per mode.\nŒ∑: Lamb-Dicke parameter(s). Scalar (uniform) or N_ions √ó 2N matrix.\nmultiply_by_2œÄ: Multiply by 2œÄ (default true, since frequencies in GHz)\ndrive_bounds: Control amplitude bounds for each ion (length N_ions)\n\nExample: Two-Ion Radial MS Gate\n\nsys = RadialMSGateSystem(\n    N_ions=2,\n    mode_levels=5,\n    œâm_radial=[5.0, 5.0, 5.1, 5.1],  # Two nearly-degenerate pairs\n    Œ¥=0.2,                            # 200 kHz detuning\n    Œ∑=0.1,                            # Lamb-Dicke parameter\n    drive_bounds=[1.0, 1.0]           # Amplitude bounds (GHz)\n)\n\n# Create trajectory for XX gate\nU_goal = exp(-im * œÄ/4 * kron([0 1; 1 0], [0 1; 1 0]))  # XX(œÄ/2)\nqtraj = UnitaryTrajectory(sys, U_goal, 100e-6)  # 100 Œºs gate\n\nOptimization Considerations\n\nMotional closure: All 2N modes must satisfy alpha_k(tau) approx 0\nTarget mode: Choose one mode (e.g., k=1) as primary entangling mode\nSpectator modes: Other modes should remain minimally excited\nControl strategy: Individual ion addressing via Omega_i(t)\n\nReferences\n\nS√∏rensen & M√∏lmer, \"Quantum computation with ions in thermal motion,\" PRL 82, 1971 (1999)\nMizrahi et al., \"Realization and Calibration of Continuously Parameterized Two-Qubit  Gates...,\" IEEE TQE (2024)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.RadialMSGateSystemWithPhase-Tuple{}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.RadialMSGateSystemWithPhase","text":"RadialMSGateSystemWithPhase(;\n    N_ions::Int=2,\n    mode_levels::Int=5,\n    œâm_radial::Vector{Float64}=[5.0, 5.0, 5.1, 5.1],\n    Œ¥::Union{Float64, Vector{Float64}}=0.2,\n    Œ∑::Union{Float64, Matrix{Float64}}=0.1,\n    multiply_by_2œÄ::Bool=true,\n    amplitude_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}}=fill(1.0, N_ions),\n    phase_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}}=fill((-œÄ, œÄ), N_ions),\n) -> QuantumSystem\n\nReturns a time-dependent QuantumSystem for the radial-mode MS gate with phase controls to enable AC Stark shift compensation.\n\nHamiltonian (with phase modulation)\n\nInstead of sigma_x = sigma^+ + sigma^-, we use phase-modulated drives:\n\nH(t) = frac12 sum_ik eta_ki Omega_i(t) left(sigma^+_i e^iphi_i(t) + sigma^-_i e^-iphi_i(t)right) \n       left(a_k e^-idelta_k t + a_k^dagger e^idelta_k tright)\n\nwhere Omega_i(t) and phi_i(t) are independent controls.\n\nWhy Phase Controls?\n\nOff-resonant coupling to spectator modes creates AC Stark shifts:\n\nDelta E_textStark sim fraceta^2 Omega^2(t)delta_textspectator\n\nThis causes time-varying phase accumulation that sigma_x control alone cannot compensate. The solution: actively modulate phi_i(t) to cancel the Stark-induced phase, typically using:\n\nphi(t) sim int_0^t fraceta^2 Omega^2(t)delta dt sim texterf(sqrt2t) text for Gaussian pulses\n\nThis enables loop closure in phase space and high-fidelity gates (F  099).\n\nControl Structure\n\nControls: Omega_1 phi_1 Omega_2 phi_2 ldots for N_textions ions.\n\nEven indices (1, 3, 5, ...): Amplitudes Omega_i(t) (Rabi frequency)\nOdd indices (2, 4, 6, ...): Phases phi_i(t) (laser phase)\n\nExample\n\nsys = RadialMSGateSystemWithPhase(\n    N_ions=2,\n    mode_levels=3,\n    œâm_radial=[5.0, 5.0, 5.1, 5.1],\n    Œ¥=0.2,\n    Œ∑=0.1,\n    amplitude_bounds=[1.0, 1.0],\n    phase_bounds=[(-Float64(œÄ), Float64(œÄ)), (-Float64(œÄ), Float64(œÄ))]\n)\n\n# sys.n_drives == 4 (Œ©‚ÇÅ, œÜ‚ÇÅ, Œ©‚ÇÇ, œÜ‚ÇÇ)\n\nSee Also\n\nRadialMSGateSystem: Amplitude-only version (simpler but limited fidelity)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.RydbergChainSystem-Tuple{}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.RydbergChainSystem","text":"RydbergChainSystem(;\n    N::Int=3, # number of atoms\n    C::Float64=862690*2œÄ,\n    distance::Float64=10.0, # Œºm\n    cutoff_order::Int=2, # 1 is nearest neighbor, 2 is next-nearest neighbor, etc.\n    local_detune::Bool=false, # If true, include one local detuning pattern.\n    all2all::Bool=true, # If true, include all-to-all interactions.\n    ignore_Y_drive::Bool=false, # If true, ignore the Y drive. (In the experiments, X&Y drives are implemented by Rabi amplitude and its phase.)\n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}}=[1.0, 1.0, 1.0], # Bounds for [Œ©x, Œ©y, Œî] or [Œ©x, Œî] if ignore_Y_drive\n) -> QuantumSystem\n\nReturns a QuantumSystem object for the Rydberg atom chain in the spin basis     |g‚ü© = |0‚ü© = [1, 0], |r‚ü© = |1‚ü© = [0, 1].\n\nH = sum_i 05*Omega_i(t)cos(phi_i(t)) sigma_i^x - 05*Omega_i(t)sin(phi_i(t)) sigma_i^y - sum_i Delta_i(t)n_i + sum_ij fracCi-j^6 n_i n_j\n\nKeyword Arguments\n\nN: Number of atoms.\nC: The Rydberg interaction strength in MHz*Œºm^6.\ndistance: The distance between atoms in Œºm.\ncutoff_order: Interaction range cutoff, 1 is nearest neighbor, 2 is next nearest neighbor.\nlocal_detune: If true, include one local detuning pattern.\nall2all: If true, include all-to-all interactions.\nignore_Y_drive: If true, ignore the Y drive. (In the experiments, X&Y drives are implemented by Rabi amplitude and its phase.)\ndrive_bounds: Bounds for drive amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.TransmonCavitySystem-Tuple{}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.TransmonCavitySystem","text":"TransmonCavitySystem(;\n    qubit_levels::Int=4,\n    cavity_levels::Int=12,\n    œá::Float64=2œÄ * 32.8e-6,    # Dispersive shift (GHz)\n    œá‚Ä≤::Float64=2œÄ * 1.5e-9,    # Higher-order dispersive shift (GHz)\n    K_c::Float64=2œÄ * 1e-9 / 2, # Cavity self-Kerr (GHz)\n    K_q::Float64=2œÄ * 193e-3 / 2, # Qubit self-Kerr (GHz)\n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}}=fill(1.0, 4),\n    multiply_by_2œÄ::Bool=false, # Already in GHz with 2œÄ factors\n) -> QuantumSystem\n\nReturns a QuantumSystem for a transmon qubit dispersively coupled to a cavity mode.\n\nThis system models circuit QED architectures where a transmon (artificial atom) is coupled  to a microwave resonator in the dispersive regime, enabling quantum state manipulation and  readout.\n\nHamiltonian\n\nH = tildeDelta hatb^dagger hatb \n    - chi hata^dagger hata hatb^dagger hatb\n    - chi hatb^dagger 2 hatb^2 hata^dagger hata\n    - K_q hata^dagger 2 hata^2\n    - K_c hatb^dagger 2 hatb^2\n\nwhere:\n\nhata, hata^dagger are the transmon annihilation/creation operators\nhatb, hatb^dagger are the cavity annihilation/creation operators  \ntildeDelta = chi2 is the shifted cavity frequency\nchi is the dispersive shift (qubit-cavity coupling)\nchi is a higher-order dispersive correction\nK_q, K_c are self-Kerr nonlinearities\n\nThe drives are:\n\nhata^dagger + hata - Real transmon drive\ni(hata^dagger - hata) - Imaginary transmon drive\nhatb^dagger + hatb - Real cavity drive\ni(hatb^dagger - hatb) - Imaginary cavity drive\n\nKeyword Arguments\n\nqubit_levels: Number of transmon Fock states (typically 3-5)\ncavity_levels: Number of cavity Fock states (typically 10-20)\nœá: Dispersive shift in GHz (with 2œÄ). Typical: ~2œÄ √ó 30-50 kHz\nœá‚Ä≤: Higher-order dispersive shift in GHz. Typically small (~2œÄ √ó 1-2 Hz)\nK_c: Cavity self-Kerr in GHz. Typically ~2œÄ √ó 1 Hz\nK_q: Qubit self-Kerr (anharmonicity/2) in GHz. Typical: ~2œÄ √ó 100-200 MHz\ndrive_bounds: Control bounds for [Œ©·µ£(qubit), Œ©·µ¢(qubit), Œ±·µ£(cavity), Œ±·µ¢(cavity)]\nmultiply_by_2œÄ: Whether to multiply by 2œÄ (default false, assuming parameters already include it)\n\nExample\n\n# Standard cQED parameters\nsys = TransmonCavitySystem(\n    qubit_levels=4,\n    cavity_levels=15,\n    œá=2œÄ * 32.8e-6,   # 32.8 kHz dispersive shift\n    K_q=2œÄ * 193e-3/2, # ~193 MHz anharmonicity\n)\n\nReferences\n\nBlais et al., \"Circuit quantum electrodynamics,\" Rev. Mod. Phys. 93, 025005 (2021)\nKoch et al., \"Charge-insensitive qubit design derived from Cooper pair box,\"  Phys. Rev. A 76, 042319 (2007)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.TransmonDipoleCoupling","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.TransmonDipoleCoupling","text":"TransmonDipoleCoupling(\n    g_ij::Float64,\n    pair::Tuple{Int, Int},\n    subsystem_levels::Vector{Int};\n    lab_frame::Bool=false,\n) -> QuantumSystemCoupling\n\nTransmonDipoleCoupling(\n    g_ij::Float64,\n    pair::Tuple{Int, Int},\n    sub_systems::Vector{QuantumSystem};\n    kwargs...\n) -> QuantumSystemCoupling\n\nReturns a QuantumSystemCoupling object for a transmon qubit. In the lab frame, the Hamiltonian coupling term is\n\nH = g_ij (a_i + a_i^dagger) (a_j + a_j^dagger)\n\nIn the rotating frame, the Hamiltonian coupling term is\n\nH = g_ij (a_i a_j^dagger + a_i^dagger a_j)\n\nwhere a_i is the annihilation operator for the ith transmon.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.TransmonSystem-Tuple{}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.TransmonSystem","text":"TransmonSystem(;\n    œâ::Float64=4.4153,  # GHz\n    Œ¥::Float64=0.17215, # GHz\n    levels::Int=3,\n    lab_frame::Bool=false,\n    frame_œâ::Float64=œâ,\n) -> QuantumSystem\n\nReturns a QuantumSystem object for a transmon qubit, with the Hamiltonian\n\nH = omega a^dagger a - fracdelta2 a^dagger a^dagger a a\n\nwhere a is the annihilation operator.\n\nKeyword Arguments\n\nœâ: The frequency of the transmon, in GHz.\nŒ¥: The anharmonicity of the transmon, in GHz.\nlevels: The number of levels in the transmon.\nlab_frame: Whether to use the lab frame Hamiltonian, or an œâ-rotating frame.\nframe_œâ: The frequency of the rotating frame, in GHz.\nmutiply_by_2œÄ: Whether to multiply the Hamiltonian by 2œÄ, set to true by default because the frequency is in GHz.\nlab_frame_type: The type of lab frame Hamiltonian to use, one of (:duffing, :quartic, :cosine).\ndrives: Whether to include drives in the Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.coherent_ket-Tuple{Union{Real, Complex}, Int64}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.coherent_ket","text":"coherent_ket(Œ±, levels)\n\nConstruct a coherent state Œ± in the Fock basis truncated to levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.get_cat_controls-Tuple{AbstractQuantumSystem, Real, Int64}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.get_cat_controls","text":"get_cat_controls(sys::AbstractQuantumSystem, Œ±, N)\n\nCompute static cat qubit controls for N time steps at coherent amplitude Œ±, reading g2 and œá_aa from sys.global_params.\n\nReturns a 2 √ó N matrix where row 1 is the buffer drive and row 2 is the Kerr correction drive. These are the steady-state controls that maintain a coherent state Œ± in the cat mode.\n\nArguments\n\nsys: A quantum system with g2 and œá_aa in its global_params\nŒ±: Coherent state amplitude\nN: Number of time steps\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.lift-Tuple{Char, Int64, Int64}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.lift","text":"lift(x::Char, i::Int, N::Int)::String\n\nEmbed a character into a string of the form 'I' * N at a specific position (meant for use with Piccolo.QuantumObjectUtils.operator_from_string).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemUtils.is_linearly_dependent-Tuple{AbstractMatrix}","page":"Library","title":"Piccolo.Quantum.QuantumSystemUtils.is_linearly_dependent","text":"is_linearly_dependent(M::AbstractMatrix; eps=eps(Float32), verbose=true)\n\nCheck if the columns of the matrix M are linearly dependent.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumSystemUtils.is_reachable","text":"is_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...)\n\nCheck if the gate is reachable using the given system.\n\nKeyword Arguments\n\nuse_drift::Bool=true: include drift Hamiltonian in the generators\nkwargs...: keyword arguments for is_reachable\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystemUtils.is_reachable","text":"is_reachable(gate, hamiltonians; kwargs...)\n\nCheck if the gate is reachable using the given hamiltonians.\n\nArguments\n\ngate::AbstractMatrix: target gate\nhamiltonians::AbstractVector{<:AbstractMatrix}: generators of the Lie algebra\n\nKeyword Arguments\n\nsubspace::AbstractVector{<:Int}=1:size(gate, 1): subspace indices\ncompute_basis::Bool=true: compute the basis or use the Hamiltonians directly\nremove_trace::Bool=true: remove trace from generators\nverbose::Bool=true: print information about the operator algebra\natol::Float32=eps(Float32): absolute tolerance\n\nSee also QuantumSystemUtils.operator_algebra.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemUtils.operator_algebra-Union{Tuple{Vector{<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","page":"Library","title":"Piccolo.Quantum.QuantumSystemUtils.operator_algebra","text":"operator_algebra(generators; kwargs...)\n\nCompute the Lie algebra basis for the given generators.\n\nArguments\n\ngenerators::Vector{<:AbstractMatrix}: generators of the Lie algebra\n\nKeyword Arguments\n\nreturn_layers::Bool=false: return the Lie tree layers\nnormalize::Bool=false: normalize the basis\nverbose::Bool=false: print information\nremove_trace::Bool=true: remove trace from generators\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Gates.GATES","page":"Library","title":"Piccolo.Quantum.Gates.GATES","text":"A constant dictionary GATES containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix.\n\nGATES[:I] - Identity: Leaves the state unchanged.\nGATES[:X] - Pauli-X (NOT): Flips the qubit state.\nGATES[:Y] - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere.\nGATES[:Z] - Pauli-Z: Flips the phase of the qubit state.\nGATES[:H] - Hadamard: Creates superposition by transforming basis states.\nGATES[:CX] - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1‚ü©.\nGATES[:CZ] - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1‚ü©.\nGATES[:XI] - Complex: A gate for complex operations.\nGATES[:sqrtiSWAP] - Square root of iSWAP: Partially swaps two qubits with a phase.\n\n\n\n\n\n","category":"constant"},{"location":"lib/#Piccolo.Quantum.Gates.PAULIS","page":"Library","title":"Piccolo.Quantum.Gates.PAULIS","text":"The 2√ó2 Pauli matrics and identity.\n\n\n\n\n\n","category":"constant"},{"location":"lib/#Piccolo.Quantum.QuantumObjectUtils.annihilate-Tuple{Int64}","page":"Library","title":"Piccolo.Quantum.QuantumObjectUtils.annihilate","text":"annihilate(levels::Int)\n\nGet the annihilation operator for a system with levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumObjectUtils.create-Tuple{Int64}","page":"Library","title":"Piccolo.Quantum.QuantumObjectUtils.create","text":"create(levels::Int)\n\nGet the creation operator for a system with levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumObjectUtils.haar_identity-Tuple{Int64, Number}","page":"Library","title":"Piccolo.Quantum.QuantumObjectUtils.haar_identity","text":"haar_identity(n::Int, radius::Number)\n\nGenerate a random unitary matrix close to the identity matrix using the Haar measure for an n-dimensional system with a given radius. The smaller the radius, the closer the matrix will be to the identity.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumObjectUtils.haar_random-Tuple{Int64}","page":"Library","title":"Piccolo.Quantum.QuantumObjectUtils.haar_random","text":"haar_random(n::Int)\n\nGenerate a random unitary matrix using the Haar measure for an n-dimensional system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumObjectUtils.ket_from_bitstring-Tuple{String}","page":"Library","title":"Piccolo.Quantum.QuantumObjectUtils.ket_from_bitstring","text":"ket_from_bitstring(ket::String)\n\nGet the state vector for a qubit system given a ket string ket of 0s and 1s.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumObjectUtils.ket_from_string-Tuple{String, Vector{Int64}}","page":"Library","title":"Piccolo.Quantum.QuantumObjectUtils.ket_from_string","text":"ket_from_string(\n    ket::String,\n    levels::Vector{Int};\n    level_dict=Dict(:g => 0, :e => 1, :f => 2, :h => 3, :i => 4, :j => 5, :k => 6, :l => 7),\n    return_states=false\n)\n\nConstruct a quantum state from a string ket representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumObjectUtils.operator_from_string-Tuple{String}","page":"Library","title":"Piccolo.Quantum.QuantumObjectUtils.operator_from_string","text":"operator_from_string(operator::String; lookup=PAULIS)\n\nReduce the string (each character is one key) via operators from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(qtraj::KetTrajectory; kwargs...)\nNamedTrajectory(qtraj::KetTrajectory, N::Int; kwargs...)\nNamedTrajectory(qtraj::KetTrajectory, times::AbstractVector; kwargs...)\n\nConvert a KetTrajectory to a NamedTrajectory for optimization.\n\nStored Variables\n\nœàÃÉ: Isomorphism of ket state (real representation)\nu (or custom drive_name): Control values sampled at times\ndu: Control derivatives (only for CubicSplinePulse)\nt: Times\n\nArguments\n\nN_or_times: One of:\nnothing (default): Use native knot times from spline pulse\nN::Int: Number of uniformly spaced time points\ntimes::AbstractVector: Specific times to sample at\n\nKeyword Arguments\n\nŒît_bounds: Optional tuple (lower, upper) for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: nothing (no bounds).\nglobal_data: Optional Dict mapping global variable names to initial values (as vectors). Note: global variables are optimization variables without explicit box constraints.\n\n\n\n\n\n","category":"type"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-2","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(qtraj::UnitaryTrajectory; kwargs...)\nNamedTrajectory(qtraj::UnitaryTrajectory, N::Int; kwargs...)\nNamedTrajectory(qtraj::UnitaryTrajectory, times::AbstractVector; kwargs...)\n\nConvert a UnitaryTrajectory to a NamedTrajectory for optimization.\n\nThe trajectory stores actual times :t (not timesteps :Œît), which is required for time-dependent integrators used with SplinePulseProblem.\n\nStored Variables\n\n≈®‚Éó: Isomorphism of unitary (vectorized real representation)\nu (or custom drive_name): Control values sampled at times\ndu: Control derivatives (only for CubicSplinePulse)\nt: Times\n\nArguments\n\nqtraj: The quantum trajectory to convert\nN_or_times: One of:\nnothing (default): Use native knot times from spline pulse (error for non-spline pulses)\nN::Int: Number of uniformly spaced time points\ntimes::AbstractVector: Specific times to sample at\n\nKeyword Arguments\n\nŒît_bounds: Optional tuple (lower, upper) for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: nothing (no bounds).\nglobal_data: Optional Dict mapping global variable names to initial values (as vectors). Note: global variables are optimization variables without explicit box constraints.\n\nReturns\n\nA NamedTrajectory suitable for direct collocation optimization.\n\n\n\n\n\n","category":"type"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-3","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(qtraj::DensityTrajectory; kwargs...)\nNamedTrajectory(qtraj::DensityTrajectory, N::Int; kwargs...)\nNamedTrajectory(qtraj::DensityTrajectory, times::AbstractVector; kwargs...)\n\nConvert a DensityTrajectory to a NamedTrajectory for optimization.\n\nUses the compact density isomorphism (n¬≤ real parameters) which exploits the Hermiticity of density matrices. This halves the state dimension compared to the full [vec(Re(œÅ)); vec(Im(œÅ))] representation.\n\nStored Variables\n\nœÅ‚ÉóÃÉ: Compact isomorphism of the density matrix (n¬≤ real parameters)\nu (or custom drive_name): Control values sampled at times\ndu: Control derivatives (only for CubicSplinePulse)\nt: Times\n\nArguments\n\nN_or_times: One of:\nnothing (default): Use native knot times from spline pulse\nN::Int: Number of uniformly spaced time points\ntimes::AbstractVector: Specific times to sample at\n\nKeyword Arguments\n\nŒît_bounds: Optional tuple (lower, upper) for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: nothing (no bounds).\nglobal_data: Optional Dict mapping global variable names to initial values (as vectors). Note: global variables are optimization variables without explicit box constraints.\n\n\n\n\n\n","category":"type"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-4","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(qtraj::MultiKetTrajectory; kwargs...)\nNamedTrajectory(qtraj::MultiKetTrajectory, N::Int; kwargs...)\nNamedTrajectory(qtraj::MultiKetTrajectory, times::AbstractVector; kwargs...)\n\nConvert an MultiKetTrajectory to a NamedTrajectory for optimization.\n\nStored Variables\n\nœàÃÉ1, œàÃÉ2, ...: Isomorphisms of each ket state\nu (or custom drive_name): Control values sampled at times\ndu: Control derivatives (only for CubicSplinePulse)\nt: Times\n\nArguments\n\nN_or_times: One of:\nnothing (default): Use native knot times from spline pulse\nN::Int: Number of uniformly spaced time points\ntimes::AbstractVector: Specific times to sample at\n\nKeyword Arguments\n\nŒît_bounds: Optional tuple (lower, upper) for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: nothing (no bounds).\nglobal_data: Optional Dict mapping global variable names to initial values (as vectors). Note: global variables are optimization variables without explicit box constraints.\n\n\n\n\n\n","category":"type"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{P}, Tuple{SamplingTrajectory{P, <:UnitaryTrajectory{P}}, Union{Int64, AbstractVector{<:Real}}}} where P<:AbstractPulse","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(sampling::SamplingTrajectory, N::Int)\nNamedTrajectory(sampling::SamplingTrajectory, times::AbstractVector)\n\nConvert a SamplingTrajectory to a NamedTrajectory for optimization.\n\nCreates a trajectory with multiple state variables (one per system),  all sharing the same control pulse. Each state gets a numeric suffix:\n\nUnitaryTrajectory base ‚Üí :≈®‚Éó1, :≈®‚Éó2, ...\nKetTrajectory base ‚Üí :œàÃÉ1, :œàÃÉ2, ...\n\nFor robust optimization, each state variable represents the evolution under a different system (e.g., parameter variations), but all share the same controls.\n\nExample\n\n# Create sampling trajectory with 3 system variations\nsampling = SamplingTrajectory(base_qtraj, [sys1, sys2, sys3])\n\n# Convert to NamedTrajectory with 51 timesteps\ntraj = NamedTrajectory(sampling, 51)\n# Result has: :≈®‚Éó1, :≈®‚Éó2, :≈®‚Éó3, :u, :Œît, :t\n\nKeyword Arguments\n\nŒît_bounds: Optional tuple (lower, upper) for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: nothing (no bounds).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.AbstractQuantumTrajectory","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.AbstractQuantumTrajectory","text":"AbstractQuantumTrajectory{P<:AbstractPulse}\n\nAbstract type for quantum trajectories that wrap physics (system, pulse, solution, goal). Parametric on pulse type P to enable dispatch in problem templates.\n\nAll concrete subtypes should implement:\n\nstate_name(traj) - Get the state variable symbol (fixed per type)\ndrive_name(traj) - Get the drive variable symbol (from pulse)\ntime_name(traj) - Get the time variable symbol (fixed :t)\ntimestep_name(traj) - Get the timestep variable symbol (fixed :Œît)\nduration(traj) - Get the duration (from pulse)\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.DensityTrajectory","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.DensityTrajectory","text":"DensityTrajectory{P<:AbstractPulse, S<:ODESolution} <: AbstractQuantumTrajectory{P}\n\nTrajectory for open quantum systems (Lindblad dynamics).\n\nFields\n\nsystem::OpenQuantumSystem: The open quantum system\npulse::P: The control pulse\ninitial::Matrix{ComplexF64}: Initial density matrix œÅ‚ÇÄ\ngoal::Matrix{ComplexF64}: Target density matrix œÅ_goal\nsolution::S: Pre-computed ODE solution\n\nCallable\n\ntraj(t) returns the density matrix at time t.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.DensityTrajectory-Tuple{OpenQuantumSystem, AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Real}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.DensityTrajectory","text":"DensityTrajectory(system, initial, goal, T::Real; drive_name=:u, algorithm=Tsit5())\n\nConvenience constructor that creates a zero pulse of duration T.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.DensityTrajectory-Tuple{OpenQuantumSystem, AbstractPulse, AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.DensityTrajectory","text":"DensityTrajectory(system, pulse, initial, goal; algorithm=Tsit5())\n\nCreate a density matrix trajectory by solving the Lindblad master equation.\n\nArguments\n\nsystem::OpenQuantumSystem: The open quantum system\npulse::AbstractPulse: The control pulse\ninitial::Matrix: Initial density matrix œÅ‚ÇÄ\ngoal::Matrix: Target density matrix œÅ_goal\n\nKeyword Arguments\n\nalgorithm: ODE solver algorithm (default: Tsit5())\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.KetTrajectory","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.KetTrajectory","text":"KetTrajectory{P<:AbstractPulse, S<:ODESolution} <: AbstractQuantumTrajectory{P}\n\nTrajectory for quantum state transfer. The ODE solution is computed at construction.\n\nFields\n\nsystem::QuantumSystem: The quantum system\npulse::P: The control pulse\ninitial::Vector{ComplexF64}: Initial state |œà‚ÇÄ‚ü©\ngoal::Vector{ComplexF64}: Target state |œà_goal‚ü©\nsolution::S: Pre-computed ODE solution\n\nCallable\n\ntraj(t) returns the state at time t by interpolating the solution.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.KetTrajectory-Tuple{QuantumSystem, AbstractPulse, AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.KetTrajectory","text":"KetTrajectory(system, pulse, initial, goal; algorithm=MagnusGL4())\n\nCreate a ket trajectory by solving the Schr√∂dinger equation.\n\nArguments\n\nsystem::QuantumSystem: The quantum system\npulse::AbstractPulse: The control pulse\ninitial::Vector: Initial state |œà‚ÇÄ‚ü©\ngoal::Vector: Target state |œà_goal‚ü©\n\nKeyword Arguments\n\nalgorithm: ODE solver algorithm (default: MagnusGL4())\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.KetTrajectory-Tuple{QuantumSystem, AbstractVector{<:Number}, AbstractVector{<:Number}, Real}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.KetTrajectory","text":"KetTrajectory(system, initial, goal, T::Real; drive_name=:u, algorithm=MagnusGL4())\n\nConvenience constructor that creates a zero pulse of duration T.\n\nArguments\n\nsystem::QuantumSystem: The quantum system\ninitial::Vector: Initial state |œà‚ÇÄ‚ü©\ngoal::Vector: Target state |œà_goal‚ü©\nT::Real: Duration of the pulse\n\nKeyword Arguments\n\ndrive_name::Symbol: Name of the drive variable (default: :u)\nalgorithm: ODE solver algorithm (default: MagnusGL4())\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory","text":"MultiKetTrajectory{P<:AbstractPulse, S} <: AbstractQuantumTrajectory{P}\n\nTrajectory for multi-state transfer with a shared pulse. Useful for state-to-state problems with multiple initial/goal pairs.\n\nFields\n\nsystem::QuantumSystem: The quantum system\npulse::P: The shared control pulse\ninitials::Vector{Vector{ComplexF64}}: Initial states\ngoals::Vector{Vector{ComplexF64}}: Target states\nweights::Vector{Float64}: Weights for fidelity calculation\nsolution::S: Pre-computed ensemble solution\n\nCallable\n\ntraj(t) returns a vector of states at time t. traj[i] returns the i-th trajectory's solution.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory-Tuple{QuantumSystem, AbstractPulse, Vector{<:AbstractVector{<:Number}}, Vector{<:AbstractVector{<:Number}}}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory","text":"MultiKetTrajectory(system, pulse, initials, goals; weights=..., algorithm=MagnusGL4())\n\nCreate a multi-ket trajectory by solving multiple Schr√∂dinger equations.\n\nArguments\n\nsystem::QuantumSystem: The quantum system\npulse::AbstractPulse: The shared control pulse\ninitials::Vector{Vector}: Initial states\ngoals::Vector{Vector}: Target states\n\nKeyword Arguments\n\nweights: Weights for fidelity (default: uniform)\nalgorithm: ODE solver algorithm (default: MagnusGL4())\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory-Tuple{QuantumSystem, Vector{<:AbstractVector{<:Number}}, Vector{<:AbstractVector{<:Number}}, Real}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory","text":"MultiKetTrajectory(system, initials, goals, T::Real; weights=..., drive_name=:u, algorithm=MagnusGL4())\n\nConvenience constructor that creates a zero pulse of duration T.\n\nArguments\n\nsystem::QuantumSystem: The quantum system\ninitials::Vector{Vector}: Initial states\ngoals::Vector{Vector}: Target states\nT::Real: Duration of the pulse\n\nKeyword Arguments\n\nweights: Weights for fidelity (default: uniform)\ndrive_name::Symbol: Name of the drive variable (default: :u)\nalgorithm: ODE solver algorithm (default: MagnusGL4())\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.SamplingTrajectory","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.SamplingTrajectory","text":"SamplingTrajectory{QT<:AbstractQuantumTrajectory} <: AbstractQuantumTrajectory\n\nWrapper for robust optimization over multiple systems with shared controls.\n\nUsed for sampling-based robust optimization where:\n\nAll systems share the same control pulse\nEach system has different dynamics (e.g., parameter variations)\nOptimization minimizes weighted fidelity across all systems\n\nThis type does NOT store a NamedTrajectory - use NamedTrajectory(sampling, N) for conversion.\n\nFields\n\nbase_trajectory::QT: Base quantum trajectory (defines pulse, initial, goal)\nsystems::Vector{<:AbstractQuantumSystem}: Multiple systems to optimize over\nweights::Vector{Float64}: Weights for each system in objective\n\nExample\n\nsys_nom = QuantumSystem(...)\nsys_variations = [QuantumSystem(...) for _ in 1:3]  # Parameter variations\nqtraj = UnitaryTrajectory(sys_nom, pulse, U_goal)\nsampling = SamplingTrajectory(qtraj, sys_variations, [0.5, 0.3, 0.2])\n\n# Convert to NamedTrajectory for optimization\ntraj = NamedTrajectory(sampling, 51)  # Creates :≈®‚Éó1, :≈®‚Éó2, :≈®‚Éó3\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.SamplingTrajectory-Union{Tuple{QT}, Tuple{P}, Tuple{QT, Vector{<:AbstractQuantumSystem}}} where {P<:AbstractPulse, QT<:AbstractQuantumTrajectory{P}}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.SamplingTrajectory","text":"SamplingTrajectory(base_trajectory, systems; weights=nothing)\n\nCreate a SamplingTrajectory for robust optimization.\n\nArguments\n\nbase_trajectory: Base quantum trajectory (defines pulse, initial, goal)\nsystems: Vector of systems with parameter variations\n\nKeyword Arguments\n\nweights: Optional weights for each system (default: equal weights)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory","text":"UnitaryTrajectory{P<:AbstractPulse, S<:ODESolution, G} <: AbstractQuantumTrajectory{P}\n\nTrajectory for unitary gate synthesis. The ODE solution is computed at construction.\n\nFields\n\nsystem::QuantumSystem: The quantum system\npulse::P: The control pulse (stores drive_name)\ninitial::Matrix{ComplexF64}: Initial unitary (default: identity)\ngoal::G: Target unitary operator (AbstractPiccoloOperator or Matrix)\nsolution::S: Pre-computed ODE solution\n\nCallable\n\ntraj(t) returns the unitary at time t by interpolating the solution.\n\nConversion to NamedTrajectory\n\nUse NamedTrajectory(traj, N) or NamedTrajectory(traj, times) for optimization.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory-Union{Tuple{G}, Tuple{QuantumSystem, AbstractPulse, G}} where G","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory","text":"UnitaryTrajectory(system, pulse, goal; initial=I, algorithm=MagnusGL4())\n\nCreate a unitary trajectory by solving the Schr√∂dinger equation.\n\nArguments\n\nsystem::QuantumSystem: The quantum system\npulse::AbstractPulse: The control pulse\ngoal: Target unitary (Matrix or AbstractPiccoloOperator)\n\nKeyword Arguments\n\ninitial: Initial unitary (default: identity matrix)\nalgorithm: ODE solver algorithm (default: MagnusGL4())\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory-Union{Tuple{G}, Tuple{QuantumSystem, G, Real}} where G","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory","text":"UnitaryTrajectory(system, goal, T::Real; drive_name=:u, algorithm=MagnusGL4())\n\nConvenience constructor that creates a zero pulse of duration T.\n\nArguments\n\nsystem::QuantumSystem: The quantum system\ngoal: Target unitary (Matrix or AbstractPiccoloOperator)\nT::Real: Duration of the pulse\n\nKeyword Arguments\n\ndrive_name::Symbol: Name of the drive variable (default: :u)\nalgorithm: ODE solver algorithm (default: MagnusGL4())\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.drive_name-Tuple{AbstractQuantumTrajectory}","page":"Library","title":"Piccolo.Quantum.Pulses.drive_name","text":"drive_name(traj::AbstractQuantumTrajectory)\n\nGet the drive/control variable name from the trajectory's pulse.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.duration-Tuple{AbstractQuantumTrajectory}","page":"Library","title":"Piccolo.Quantum.Pulses.duration","text":"duration(traj)\n\nGet the duration of a trajectory (from its pulse).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._add_global_data_to_kwargs-Tuple{Any, Any}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._add_global_data_to_kwargs","text":"_add_global_data_to_kwargs(nt_kwargs, global_data)\n\nHelper function to process global variables and add them to NamedTrajectory kwargs. Converts Dict{Symbol, Vector} to flat vector and components NamedTuple.\n\nArguments\n\nnt_kwargs: Existing NamedTuple of kwargs to merge with\nglobal_data: Dict mapping global variable names to vectors of values\n\nReturns\n\nMerged NamedTuple with globaldata and globalcomponents added\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._get_control_data-Tuple{CubicSplinePulse, AbstractVector, AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._get_control_data","text":"_get_control_data(pulse::CubicSplinePulse, times, sys)\n\nFor CubicSplinePulse: return u and du data with system bounds and boundary conditions. Uses the pulse's drive_name to determine variable naming.\n\nWhen times matches the pulse's native knot times, extracts stored u and du directly. When resampling to different times, samples u via interpolation and computes du via ForwardDiff to get the true spline derivative.\n\nReturns\n\ndata: NamedTuple with control data\ncontrol_names: Tuple of control variable names\nbounds: NamedTuple with control bounds\ninitial_constraints: NamedTuple with initial value constraints\nfinal_constraints: NamedTuple with final value constraints\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._get_control_data-Tuple{GaussianPulse, AbstractVector, AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._get_control_data","text":"_get_control_data(pulse::GaussianPulse, times, sys)\n\nFor GaussianPulse: sample as u values with system bounds and boundary conditions. Uses the pulse's drive_name to determine variable naming.\n\nReturns\n\ndata: NamedTuple with control data\ncontrol_names: Tuple of control variable names\nbounds: NamedTuple with control bounds\ninitial_constraints: NamedTuple with initial value constraints (empty for parametric pulses)\nfinal_constraints: NamedTuple with final value constraints (empty for parametric pulses)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._get_control_data-Tuple{Union{LinearSplinePulse, ZeroOrderPulse}, AbstractVector, AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._get_control_data","text":"_get_control_data(pulse::Union{ZeroOrderPulse, LinearSplinePulse}, times, sys)\n\nFor ZeroOrderPulse and LinearSplinePulse: return u data with system bounds and boundary conditions. Uses the pulse's drive_name to determine variable naming.\n\nReturns\n\ndata: NamedTuple with control data\ncontrol_names: Tuple of control variable names\nbounds: NamedTuple with control bounds\ninitial_constraints: NamedTuple with initial value constraints\nfinal_constraints: NamedTuple with final value constraints\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._get_drive_bounds-Tuple{AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._get_drive_bounds","text":"_get_drive_bounds(sys::QuantumSystem)\n\nExtract drive bounds from system as tuple of (lower, upper) vectors.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._named_tuple-Tuple{Vararg{Pair{Symbol}}}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._named_tuple","text":"_named_tuple(pairs...)\n\nCreate a NamedTuple from pairs of (Symbol, value). This is needed when keys are  dynamic (stored in variables).\n\nExample:     name = :x     namedtuple(name => 1, :y => 2)  # Returns (x = 1, y = 2)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._sample_times-Tuple{Any, AbstractVector{<:Real}}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._sample_times","text":"_sample_times(traj, times::AbstractVector)\n\nReturn times as a Float64 vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._sample_times-Tuple{Any, Int64}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._sample_times","text":"_sample_times(traj, N::Int)\n\nGenerate N uniformly spaced times for sampling.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._sample_times-Tuple{Any, Nothing}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._sample_times","text":"_sample_times(traj, ::Nothing)\n\nFor spline pulses, extract native knot times. For other pulses, error.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.extract_pulse","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.extract_pulse","text":"extract_pulse(qtraj::AbstractQuantumTrajectory, traj::NamedTrajectory)\n\nExtract an optimized pulse from a NamedTrajectory.\n\nThis function extracts the control values from the optimized trajectory and creates a new pulse object of the same type as the original pulse in qtraj.\n\nThe extraction process depends on the pulse type:\n\nZeroOrderPulse, LinearSplinePulse: Extracts u (drive variable)\nCubicSplinePulse: Extracts both u and du (derivative variable)\n\nArguments\n\nqtraj: Original quantum trajectory (provides pulse type and drive names)\ntraj: Optimized NamedTrajectory with new control values\n\nReturns\n\nA new pulse of the same type as qtraj.pulse with optimized control values.\n\nExample\n\n# After optimization\nsolve!(prob)\nnew_pulse = extract_pulse(qtraj, prob.trajectory)\nrollout!(qtraj, new_pulse)\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_goal-Tuple{UnitaryTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_goal","text":"get_goal(traj)\n\nGet the goal state/operator from a trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_initial-Tuple{UnitaryTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_initial","text":"get_initial(traj)\n\nGet the initial state/operator from a trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_pulse-Tuple{AbstractQuantumTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_pulse","text":"get_pulse(traj)\n\nGet the control pulse from a trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_solution-Tuple{AbstractQuantumTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_solution","text":"get_solution(traj)\n\nGet the ODE solution from a trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_system-Tuple{AbstractQuantumTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_system","text":"get_system(traj)\n\nGet the quantum system from a trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_systems-Tuple{SamplingTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_systems","text":"get_systems(sampling::SamplingTrajectory)\n\nGet all systems in the sampling trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_weights-Tuple{SamplingTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_weights","text":"get_weights(sampling::SamplingTrajectory)\n\nGet the weights for each system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.state_name-Tuple{UnitaryTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.state_name","text":"state_name(::AbstractQuantumTrajectory)\n\nGet the fixed state variable name for a trajectory type.\n\nUnitaryTrajectory ‚Üí :≈®‚Éó\nKetTrajectory ‚Üí :œàÃÉ\nMultiKetTrajectory ‚Üí :œàÃÉ (with index appended: :œàÃÉ1, :œàÃÉ2, etc.)\nDensityTrajectory ‚Üí :œÅ‚ÉóÃÉ\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.state_names-Tuple{MultiKetTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.state_names","text":"state_names(traj::MultiKetTrajectory)\n\nGet all state names for an ensemble trajectory (:œàÃÉ1, :œàÃÉ2, etc.)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.state_names-Tuple{SamplingTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.state_names","text":"state_names(sampling::SamplingTrajectory)\n\nGet the state variable names for all systems (e.g., [:≈®‚Éó1, :≈®‚Éó2, :≈®‚Éó3]).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.time_name-Tuple{AbstractQuantumTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.time_name","text":"time_name(::AbstractQuantumTrajectory)\n\nGet the time variable name (always :t).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.timestep_name-Tuple{AbstractQuantumTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.timestep_name","text":"timestep_name(::AbstractQuantumTrajectory)\n\nGet the timestep variable name (always :Œît).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts._update_system!-Tuple{DensityTrajectory, OpenQuantumSystem}","page":"Library","title":"Piccolo.Quantum.Rollouts._update_system!","text":"Rollouts._update_system!(qtraj::DensityTrajectory, sys::OpenQuantumSystem)\n\nUpdate the system field in a DensityTrajectory with a new OpenQuantumSystem (typically with updated global parameters after optimization).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts._update_system!-Tuple{KetTrajectory, QuantumSystem}","page":"Library","title":"Piccolo.Quantum.Rollouts._update_system!","text":"Rollouts._update_system!(qtraj::KetTrajectory, sys::QuantumSystem)\n\nUpdate the system field in a KetTrajectory with a new QuantumSystem (typically with updated global parameters after optimization).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts._update_system!-Tuple{MultiKetTrajectory, QuantumSystem}","page":"Library","title":"Piccolo.Quantum.Rollouts._update_system!","text":"Rollouts._update_system!(qtraj::MultiKetTrajectory, sys::QuantumSystem)\n\nUpdate the system field in a MultiKetTrajectory with a new QuantumSystem (typically with updated global parameters after optimization).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts._update_system!-Tuple{SamplingTrajectory, QuantumSystem}","page":"Library","title":"Piccolo.Quantum.Rollouts._update_system!","text":"Rollouts._update_system!(qtraj::SamplingTrajectory, sys::QuantumSystem)\n\nUpdate the system in the base_trajectory of a SamplingTrajectory. Note: This only updates the base trajectory's system, not the systems array. For updating parameter variations in the systems array, that should be done through the SamplingTrajectory constructor or direct modification.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts._update_system!-Tuple{UnitaryTrajectory, QuantumSystem}","page":"Library","title":"Piccolo.Quantum.Rollouts._update_system!","text":"Rollouts._update_system!(qtraj::UnitaryTrajectory, sys::QuantumSystem)\n\nUpdate the system field in a UnitaryTrajectory with a new QuantumSystem (typically with updated global parameters after optimization).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{DensityTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(traj::DensityTrajectory)\n\nCompute the fidelity between the final density matrix and the goal. Uses trace fidelity: F = tr(œÅfinal * œÅgoal)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{KetTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(traj::KetTrajectory)\n\nCompute the fidelity between the final state and the goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{MultiKetTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(traj::MultiKetTrajectory)\n\nCompute the weighted average fidelity across all state transfers.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{SamplingTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(traj::SamplingTrajectory; kwargs...)\n\nCompute the fidelity for each system in the sampling trajectory.\n\nReturns a vector of fidelities, one per system, by rolling out the current pulse with each system and computing the fidelity against the goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{UnitaryTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(traj::UnitaryTrajectory; subspace=nothing)\n\nCompute the fidelity between the final unitary and the goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{DensityTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::DensityTrajectory, pulse::AbstractPulse; algorithm=Tsit5(), n_points=101)\n\nUpdate density trajectory in-place with a new pulse. Note: Default algorithm is Tsit5() since density evolution uses standard ODE solvers. See rollout!(::UnitaryTrajectory, ::AbstractPulse) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{DensityTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::DensityTrajectory; algorithm=Tsit5(), n_points=101, kwargs...)\n\nUpdate density trajectory in-place with same pulse but different ODE parameters. Note: Default algorithm is Tsit5() since density evolution uses standard ODE solvers. See rollout!(::UnitaryTrajectory; kwargs...) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{KetTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::KetTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)\n\nUpdate ket trajectory in-place with a new pulse. See rollout!(::UnitaryTrajectory, ::AbstractPulse) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{KetTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::KetTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)\n\nUpdate ket trajectory in-place with same pulse but different ODE parameters. See rollout!(::UnitaryTrajectory; kwargs...) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{MultiKetTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::MultiKetTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)\n\nUpdate multi-ket trajectory in-place with a new pulse. See rollout!(::UnitaryTrajectory, ::AbstractPulse) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{MultiKetTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::MultiKetTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)\n\nUpdate multi-ket trajectory in-place with same pulse but different ODE parameters. See rollout!(::UnitaryTrajectory; kwargs...) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{SamplingTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::SamplingTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)\n\nUpdate sampling trajectory's base trajectory in-place with a new pulse. Delegates to the base trajectory's rollout! method.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{SamplingTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::SamplingTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)\n\nUpdate sampling trajectory's base trajectory in-place with new ODE parameters. Delegates to the base trajectory's rollout! method.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{UnitaryTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::UnitaryTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)\n\nUpdate quantum trajectory in-place with a new pulse by re-solving the ODE. Mutates qtraj.pulse and qtraj.solution.\n\nArguments\n\nqtraj::UnitaryTrajectory: The trajectory to update\npulse::AbstractPulse: The new control pulse\n\nKeyword Arguments\n\nalgorithm: ODE solver algorithm (default: MagnusGL4())\nn_points::Int: Number of time points to sample (default: 101)\n\nExample\n\nqtraj = UnitaryTrajectory(sys, old_pulse, goal)\nrollout!(qtraj, new_pulse)  # Updates qtraj in-place\nfid = fidelity(qtraj)  # Uses new solution\n\nSee also: rollout\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{UnitaryTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::UnitaryTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)\n\nUpdate quantum trajectory in-place by re-solving with same pulse but different ODE parameters. Mutates qtraj.solution.\n\nUseful for comparing different solvers or tolerances.\n\nKeyword Arguments\n\nalgorithm: ODE solver algorithm (default: MagnusGL4())\nn_points::Int: Number of time points to sample (default: 101)\nAdditional kwargs passed to solve (e.g., abstol, reltol)\n\nExample\n\nqtraj = UnitaryTrajectory(sys, pulse, goal)\n\n# Compare Magnus vs Runge-Kutta\nrollout!(qtraj; algorithm=Tsit5(), abstol=1e-10)\nfid_rk = fidelity(qtraj)\n\nSee also: rollout\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{DensityTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::DensityTrajectory, pulse::AbstractPulse; algorithm=Tsit5(), n_points=101)\n\nCreate a new density trajectory by rolling out a new pulse. Note: Default algorithm is Tsit5() since density evolution uses standard ODE solvers. See rollout(::UnitaryTrajectory, ::AbstractPulse) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{DensityTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::DensityTrajectory; algorithm=Tsit5(), n_points=101, kwargs...)\n\nRe-solve density trajectory with same pulse but different ODE parameters. Note: Default algorithm is Tsit5() since density evolution uses standard ODE solvers. See rollout(::UnitaryTrajectory; kwargs...) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{KetTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::KetTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)\n\nCreate a new ket trajectory by rolling out a new pulse. See rollout(::UnitaryTrajectory, ::AbstractPulse) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{KetTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::KetTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)\n\nRe-solve ket trajectory with same pulse but different ODE parameters. See rollout(::UnitaryTrajectory; kwargs...) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{MultiKetTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::MultiKetTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)\n\nCreate a new multi-ket trajectory by rolling out a new pulse. See rollout(::UnitaryTrajectory, ::AbstractPulse) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{MultiKetTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::MultiKetTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)\n\nRe-solve multi-ket trajectory with same pulse but different ODE parameters. See rollout(::UnitaryTrajectory; kwargs...) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{UnitaryTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::UnitaryTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)\n\nCreate a new quantum trajectory by rolling out a new pulse through the system. Returns a new UnitaryTrajectory with the updated pulse and solution.\n\nArguments\n\nqtraj::UnitaryTrajectory: The base trajectory (provides system, initial, goal)\npulse::AbstractPulse: The new control pulse to roll out\n\nKeyword Arguments\n\nalgorithm: ODE solver algorithm (default: MagnusGL4())\nn_points::Int: Number of time points to sample (default: 101)\n\nExample\n\nqtraj = UnitaryTrajectory(sys, old_pulse, goal)\n\n# Roll out a new pulse\nqtraj_new = rollout(qtraj, new_pulse)\n\n# Check fidelity\nfid = fidelity(qtraj_new)\n\nSee also: extract_pulse, rollout!, fidelity\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{UnitaryTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::UnitaryTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)\n\nRe-solve the trajectory with the same pulse but different ODE parameters. Returns a new UnitaryTrajectory with the updated solution.\n\nUseful for comparing different solvers or tolerances.\n\nKeyword Arguments\n\nalgorithm: ODE solver algorithm (default: MagnusGL4())\nn_points::Int: Number of time points to sample (default: 101)\nAdditional kwargs passed to solve (e.g., abstol, reltol)\n\nExample\n\nqtraj = UnitaryTrajectory(sys, pulse, goal)\n\n# Compare Magnus vs Runge-Kutta\nqtraj_rk = rollout(qtraj; algorithm=Tsit5(), abstol=1e-10)\nfid_magnus = fidelity(qtraj)\nfid_rk = fidelity(qtraj_rk)\n\nSee also: rollout!\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.AbstractPulse","page":"Library","title":"Piccolo.Quantum.Pulses.AbstractPulse","text":"AbstractPulse\n\nAbstract type for all pulse types. All pulses are callable: pulse(t) returns the control vector at time t.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.AbstractSplinePulse","page":"Library","title":"Piccolo.Quantum.Pulses.AbstractSplinePulse","text":"AbstractSplinePulse <: AbstractPulse\n\nAbstract type for spline-based pulses (linear and cubic interpolation). These pulses use the spline coefficients as optimization variables.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.CompositePulse","page":"Library","title":"Piccolo.Quantum.Pulses.CompositePulse","text":"CompositePulse(pulses::Vector{<:AbstractPulse}, mode::Symbol=:interleave)\n\nCreate a composite pulse from multiple component pulses.\n\nArguments\n\npulses: Vector of pulse objects to combine\nmode: How to combine the drives\n:interleave - Interleave drives: [p1d1, p2d1, p1d2, p2d2, ...]\n:concatenate - Concatenate drives: [p1d1, p1d2, ..., p2d1, p2d2, ...]\n\nExample\n\n# For MS gate with 2 ions: [Œ©‚ÇÅ, œÜ‚ÇÅ, Œ©‚ÇÇ, œÜ‚ÇÇ]\nŒ©_pulse = GaussianPulse([Œ©‚ÇÅ, Œ©‚ÇÇ], œÉ, T)  # 2 drives\nœÜ_pulse = ErfPulse([œÜ‚ÇÅ, œÜ‚ÇÇ], œÉ, T)        # 2 drives\npulse = CompositePulse([Œ©_pulse, œÜ_pulse], :interleave)\n# Result: pulse(t) = [Œ©‚ÇÅ(t), œÜ‚ÇÅ(t), Œ©‚ÇÇ(t), œÜ‚ÇÇ(t)]\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.CompositePulse-2","page":"Library","title":"Piccolo.Quantum.Pulses.CompositePulse","text":"CompositePulse{F<:Function} <: AbstractPulse\n\nComposite pulse that combines multiple pulse objects by interleaving their drives.\n\nUseful for creating pulses with different shapes for different control types, such as Gaussian amplitude + erf phase for trapped ion gates.\n\nFields\n\nf::F: Function that evaluates the composite pulse\npulses::Vector{<:AbstractPulse}: Component pulses\ndrive_mapping::Vector{Vector{Int}}: Maps pulse i, drive j to composite drive index\nduration::Float64: Total pulse duration (must match for all components)\nn_drives::Int: Total number of drives across all pulses\n\nExample\n\n# Amplitude: Gaussian (2 drives for 2 ions)\nŒ©_pulse = GaussianPulse([Œ©_max, Œ©_max], œÉ, T)\n\n# Phase: Error function (2 drives for 2 ions)\nœÜ_pulse = ErfPulse([œÜ_max, œÜ_max], œÉ, T)\n\n# Composite: [Œ©‚ÇÅ, œÜ‚ÇÅ, Œ©‚ÇÇ, œÜ‚ÇÇ] - interleaved\npulse = CompositePulse([Œ©_pulse, œÜ_pulse], :interleave)\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.CubicSplinePulse","page":"Library","title":"Piccolo.Quantum.Pulses.CubicSplinePulse","text":"CubicSplinePulse{I<:CubicHermiteSpline} <: AbstractPulse\n\nPulse with cubic Hermite spline interpolation. Uses both control values AND  derivatives for exact reconstruction after optimization.\n\nFields\n\ncontrols::I: CubicHermiteSpline from DataInterpolations\nduration::Float64: Total pulse duration\nn_drives::Int: Number of control drives\ndrive_name::Symbol: Name of the drive variable (default :u)\ninitial_value::Vector{Float64}: Initial boundary condition (default: zeros)\nfinal_value::Vector{Float64}: Final boundary condition (default: zeros)\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector}","page":"Library","title":"Piccolo.Quantum.Pulses.CubicSplinePulse","text":"CubicSplinePulse(controls::AbstractMatrix, derivatives::AbstractMatrix, times::AbstractVector; drive_name=:u, initial_value=nothing, final_value=nothing)\n\nCreate a cubic Hermite spline pulse from control values, derivatives, and times.\n\nArguments\n\ncontrols: Matrix of size (n_drives, n_times) with control values\nderivatives: Matrix of size (n_drives, n_times) with control derivatives\ntimes: Vector of sample times (must start at 0)\n\nKeyword Arguments\n\ndrive_name: Name of the drive variable (default :u)\ninitial_value: Initial boundary condition (default: zeros(n_drives))\nfinal_value: Final boundary condition (default: zeros(n_drives))\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{AbstractMatrix, AbstractVector}","page":"Library","title":"Piccolo.Quantum.Pulses.CubicSplinePulse","text":"CubicSplinePulse(controls::AbstractMatrix, times::AbstractVector; drive_name=:u, initial_value=nothing, final_value=nothing)\n\nCreate a cubic Hermite spline pulse with zero derivatives at all knot points. Useful for initial guesses where smoothness constraints will be enforced by optimizer.\n\nArguments\n\ncontrols: Matrix of size (n_drives, n_times) with control values\ntimes: Vector of sample times (must start at 0)\n\nKeyword Arguments\n\ndrive_name: Name of the drive variable (default :u)\ninitial_value: Initial boundary condition (default: zeros(n_drives))\nfinal_value: Final boundary condition (default: zeros(n_drives))\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{AbstractPulse, Int64}","page":"Library","title":"Piccolo.Quantum.Pulses.CubicSplinePulse","text":"CubicSplinePulse(pulse::AbstractPulse, n_samples::Int; kwargs...)\nCubicSplinePulse(pulse::AbstractPulse, times::AbstractVector; kwargs...)\n\nConvert any pulse to a CubicSplinePulse by sampling at specified times. Derivatives are computed using ForwardDiff for automatic differentiation.\n\nUseful for initializing optimization problems with smooth analytic pulse shapes.\n\nArguments\n\npulse: Source pulse (GaussianPulse, ErfPulse, CompositePulse, etc.)\nn_samples: Number of uniformly spaced samples (alternative to times)\ntimes: Specific sample times (alternative to n_samples)\n\nKeyword Arguments\n\ndrive_name: Name for the drive variable (default: :du)\ninitial_value: Initial boundary condition (default: pulse(0.0))\nfinal_value: Final boundary condition (default: pulse(duration))\n\nExample\n\ngaussian = GaussianPulse([1.0, 2.0], 0.1, 1.0)\ncubic = CubicSplinePulse(gaussian, 50)  # 50 samples with ForwardDiff derivatives\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{NamedTrajectory}","page":"Library","title":"Piccolo.Quantum.Pulses.CubicSplinePulse","text":"CubicSplinePulse(traj::NamedTrajectory; drive_name=:u, derivative_name=:du)\n\nConstruct a CubicSplinePulse (Hermite) from a NamedTrajectory using both  control values and derivatives.\n\nArguments\n\ntraj: NamedTrajectory with control and derivative data\n\nKeyword Arguments\n\ndrive_name: Name of the drive component (default: :u)\nderivative_name: Name of the derivative component (default: :du)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.ErfPulse","page":"Library","title":"Piccolo.Quantum.Pulses.ErfPulse","text":"ErfPulse{F<:Function} <: AbstractPulse\n\nAnalytic error function pulse for phase compensation in trapped ion gates.\n\nThe error function profile is commonly used to compensate AC Stark shifts in  M√∏lmer-S√∏rensen gates, where œÜ(t) ‚àù erf(‚àö2 (t - t‚ÇÄ)/œÉ) cancels time-varying phases from off-resonant spectator modes.\n\nu_i(t) = amplitudes[i] * erf(‚àö2 * (t - centers[i]) / sigmas[i])\n\nTypically scaled to range [0, 1] or [-1, 1] by adjusting amplitude.\n\nFields\n\nf::F: Function that evaluates the pulse\namplitudes::Vector{Float64}: Peak amplitude for each drive\nsigmas::Vector{Float64}: Width parameter for each drive\ncenters::Vector{Float64}: Center time for each drive\nduration::Float64: Total pulse duration\nn_drives::Int: Number of control drives\n\nReferences\n\nMizrahi et al., \"Realization and Calibration of Continuously Parameterized  Two-Qubit Gates...\", IEEE TQE (2024), Figure 7b\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.ErfPulse-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, Real}","page":"Library","title":"Piccolo.Quantum.Pulses.ErfPulse","text":"ErfPulse(amplitudes, sigmas, centers, duration)\n\nCreate an error function pulse with per-drive parameters.\n\nArguments\n\namplitudes: Peak amplitude for each drive\nsigmas: Width parameter for each drive (controls steepness)\ncenters: Center time for each drive (inflection point)\nduration: Total pulse duration\n\nExample\n\nusing SpecialFunctions: erf\n\n# Phase compensation for MS gate\nœÜ_max = œÄ/4  # Maximum phase shift\nT = 50.0     # Gate duration\nœÉ = T/4      # Width parameter\n\npulse = ErfPulse([œÜ_max], [œÉ], [T/2], T)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.ErfPulse-Tuple{AbstractVector{<:Real}, Real, Real}","page":"Library","title":"Piccolo.Quantum.Pulses.ErfPulse","text":"ErfPulse(amplitudes, sigma, duration; center=duration/2)\n\nCreate an error function pulse with shared sigma and center across all drives.\n\nArguments\n\namplitudes: Peak amplitude for each drive\nsigma: Shared width parameter for all drives\nduration: Total pulse duration\n\nKeyword Arguments\n\ncenter: Shared center time (default: duration/2)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.GaussianPulse","page":"Library","title":"Piccolo.Quantum.Pulses.GaussianPulse","text":"GaussianPulse{F<:Function} <: AbstractPulse\n\nAnalytic Gaussian pulse. Each drive has its own amplitude, width (sigma), and center.\n\nu_i(t) = amplitudes[i] * exp(-(t - centers[i])¬≤ / (2 * sigmas[i]¬≤))\n\nFields\n\nf::F: Function that evaluates the pulse\namplitudes::Vector{Float64}: Peak amplitude for each drive\nsigmas::Vector{Float64}: Gaussian width for each drive\ncenters::Vector{Float64}: Center time for each drive\nduration::Float64: Total pulse duration\nn_drives::Int: Number of control drives\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.GaussianPulse-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, Real}","page":"Library","title":"Piccolo.Quantum.Pulses.GaussianPulse","text":"GaussianPulse(amplitudes, sigmas, centers, duration)\n\nCreate a Gaussian pulse with per-drive parameters.\n\nArguments\n\namplitudes: Peak amplitude for each drive\nsigmas: Gaussian width (standard deviation) for each drive\ncenters: Center time for each drive\nduration: Total pulse duration\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.GaussianPulse-Tuple{AbstractVector{<:Real}, Real, Real}","page":"Library","title":"Piccolo.Quantum.Pulses.GaussianPulse","text":"GaussianPulse(amplitudes, sigma, duration; center=duration/2)\n\nCreate a Gaussian pulse with shared sigma and center across all drives.\n\nArguments\n\namplitudes: Peak amplitude for each drive\nsigma: Shared Gaussian width for all drives\nduration: Total pulse duration\n\nKeyword Arguments\n\ncenter: Shared center time (default: duration/2)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.LinearSplinePulse","page":"Library","title":"Piccolo.Quantum.Pulses.LinearSplinePulse","text":"LinearSplinePulse{I<:LinearInterpolation} <: AbstractSplinePulse\n\nPulse with linear interpolation between sample points.\n\nFields\n\ncontrols::I: LinearInterpolation from DataInterpolations\nduration::Float64: Total pulse duration\nn_drives::Int: Number of control drives\ndrive_name::Symbol: Name of the drive variable (default :u)\ninitial_value::Vector{Float64}: Initial boundary condition (default: zeros)\nfinal_value::Vector{Float64}: Final boundary condition (default: zeros)\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.LinearSplinePulse-Tuple{AbstractMatrix, AbstractVector}","page":"Library","title":"Piccolo.Quantum.Pulses.LinearSplinePulse","text":"LinearSplinePulse(controls::AbstractMatrix, times::AbstractVector; drive_name=:u, initial_value=nothing, final_value=nothing)\n\nCreate a linearly interpolated pulse from control samples and times.\n\nArguments\n\ncontrols: Matrix of size (n_drives, n_times) with control values\ntimes: Vector of sample times (must start at 0)\n\nKeyword Arguments\n\ndrive_name: Name of the drive variable (default :u)\ninitial_value: Initial boundary condition (default: zeros(n_drives))\nfinal_value: Final boundary condition (default: zeros(n_drives))\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.LinearSplinePulse-Tuple{AbstractPulse, Int64}","page":"Library","title":"Piccolo.Quantum.Pulses.LinearSplinePulse","text":"LinearSplinePulse(pulse::AbstractPulse, n_samples::Int; kwargs...)\nLinearSplinePulse(pulse::AbstractPulse, times::AbstractVector; kwargs...)\n\nConvert any pulse to a LinearSplinePulse by sampling at specified times.\n\nUseful for initializing optimization problems with analytic pulse shapes.\n\nArguments\n\npulse: Source pulse (GaussianPulse, ErfPulse, CompositePulse, etc.)\nn_samples: Number of uniformly spaced samples (alternative to times)\ntimes: Specific sample times (alternative to n_samples)\n\nKeyword Arguments\n\ndrive_name: Name for the drive variable (default: :u)\ninitial_value: Initial boundary condition (default: pulse(0.0))\nfinal_value: Final boundary condition (default: pulse(duration))\n\nExample\n\ngaussian = GaussianPulse([1.0, 2.0], 0.1, 1.0)\nlinear = LinearSplinePulse(gaussian, 50)  # 50 samples\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.LinearSplinePulse-Tuple{NamedTrajectory}","page":"Library","title":"Piccolo.Quantum.Pulses.LinearSplinePulse","text":"LinearSplinePulse(traj::NamedTrajectory; drive_name=:u)\n\nConstruct a LinearSplinePulse from a NamedTrajectory.\n\nArguments\n\ntraj: NamedTrajectory with control data\n\nKeyword Arguments\n\ndrive_name: Name of the drive component (default: :u)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.ZeroOrderPulse","page":"Library","title":"Piccolo.Quantum.Pulses.ZeroOrderPulse","text":"ZeroOrderPulse{I<:ConstantInterpolation} <: AbstractPulse\n\nPiecewise constant pulse (zero-order hold). The control value at time t is the value at the most recent sample point.\n\nFields\n\ncontrols::I: ConstantInterpolation from DataInterpolations\nduration::Float64: Total pulse duration\nn_drives::Int: Number of control drives\ndrive_name::Symbol: Name of the drive variable (default :u)\ninitial_value::Vector{Float64}: Initial boundary condition (default: zeros)\nfinal_value::Vector{Float64}: Final boundary condition (default: zeros)\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.ZeroOrderPulse-Tuple{AbstractMatrix, AbstractVector}","page":"Library","title":"Piccolo.Quantum.Pulses.ZeroOrderPulse","text":"ZeroOrderPulse(controls::AbstractMatrix, times::AbstractVector; drive_name=:u, initial_value=nothing, final_value=nothing)\n\nCreate a zero-order hold pulse from control samples and times.\n\nArguments\n\ncontrols: Matrix of size (n_drives, n_times) with control values\ntimes: Vector of sample times (must start at 0)\n\nKeyword Arguments\n\ndrive_name: Name of the drive variable (default :u)\ninitial_value: Initial boundary condition (default: zeros(n_drives))\nfinal_value: Final boundary condition (default: zeros(n_drives))\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.ZeroOrderPulse-Tuple{NamedTrajectory}","page":"Library","title":"Piccolo.Quantum.Pulses.ZeroOrderPulse","text":"ZeroOrderPulse(traj::NamedTrajectory; drive_name=:u)\n\nConstruct a ZeroOrderPulse from a NamedTrajectory.\n\nArguments\n\ntraj: NamedTrajectory with control data\n\nKeyword Arguments\n\ndrive_name: Name of the drive component (default: :u)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.drive_name-Tuple{AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Pulses.drive_name","text":"drive_name(pulse::AbstractPulse)\n\nReturn the name of the drive variable for this pulse.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.duration-Tuple{AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Pulses.duration","text":"duration(pulse::AbstractPulse)\n\nReturn the duration of the pulse.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.get_knot_count-Tuple{AbstractSplinePulse}","page":"Library","title":"Piccolo.Quantum.Pulses.get_knot_count","text":"get_knot_count(pulse::AbstractSplinePulse)\n\nReturn the number of knots in the spline pulse.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.get_knot_derivatives-Tuple{CubicSplinePulse}","page":"Library","title":"Piccolo.Quantum.Pulses.get_knot_derivatives","text":"get_knot_derivatives(pulse::CubicSplinePulse)\n\nReturn the Hermite tangents at knot points (the du matrix). Only available for CubicSplinePulse.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.get_knot_times-Tuple{LinearSplinePulse}","page":"Library","title":"Piccolo.Quantum.Pulses.get_knot_times","text":"get_knot_times(pulse::AbstractSplinePulse)\n\nReturn the knot times stored in the spline pulse interpolant.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.get_knot_values-Tuple{LinearSplinePulse}","page":"Library","title":"Piccolo.Quantum.Pulses.get_knot_values","text":"get_knot_values(pulse::CubicSplinePulse)\n\nReturn the control values at knot points (the u matrix).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.n_drives-Tuple{AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Pulses.n_drives","text":"n_drives(pulse::AbstractPulse)\n\nReturn the number of control drives in the pulse.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.sample-Tuple{AbstractPulse, AbstractVector}","page":"Library","title":"Piccolo.Quantum.Pulses.sample","text":"sample(pulse::AbstractPulse, times::AbstractVector)\n\nSample the pulse at the given times. Returns a matrix of size (n_drives, length(times)).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.sample-Tuple{AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Pulses.sample","text":"sample(pulse::AbstractPulse; n_samples::Int=100)\n\nSample the pulse uniformly with n_samples points. Returns (controls, times).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts._update_system!","page":"Library","title":"Piccolo.Quantum.Rollouts._update_system!","text":"_update_system!(qtraj, sys::QuantumSystem)\n\nInternal method to update the system field in a quantum trajectory. Extended in quantum_trajectories module for specific trajectory types.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.Rollouts.extract_globals","page":"Library","title":"Piccolo.Quantum.Rollouts.extract_globals","text":"extract_globals(traj::NamedTrajectory, names::Vector{Symbol}=Symbol[])\n\nExtract global variables from trajectory as a NamedTuple for easy access. If names is empty, extracts all global variables.\n\nExample\n\ntraj = NamedTrajectory(...; global_data=[0.5, 1.0], global_components=(Œ¥=1:1, Œ©=2:2))\ng = extract_globals(traj)  # (Œ¥ = 0.5, Œ© = 1.0)\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(œÅ::AbstractMatrix{<:Number}, œÅ_goal::AbstractMatrix{<:Number})\n\nCalculate the fidelity between two density matrices œÅ and œÅ_goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(œà::AbstractVector{<:Number}, œà_goal::AbstractVector{<:Number})\n\nCalculate the fidelity between two quantum states œà and œà_goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj, args...; kwargs...)\n\nRoll out a quantum trajectory with new pulse or ODE parameters. Extended in quantum_trajectories module for specific trajectory types.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj, args...; kwargs...)\n\nIn-place rollout of quantum trajectory with new pulse or ODE parameters. Extended in quantum_trajectories module for specific trajectory types.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.Rollouts.unitary_fidelity-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Library","title":"Piccolo.Quantum.Rollouts.unitary_fidelity","text":"unitary_fidelity(U::AbstractMatrix{<:Number}, U_goal::AbstractMatrix{<:Number})\n\nCalculate the fidelity between unitary operators U and U_goal in the subspace.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.update_global_params!-Tuple{Any, Any}","page":"Library","title":"Piccolo.Quantum.Rollouts.update_global_params!","text":"update_global_params!(qtraj, traj::NamedTrajectory)\n\nUpdate the global parameters in the quantum trajectory's system with the optimized values from the NamedTrajectory after optimization. Handles immutable QuantumSystem by reconstructing with updated global_params NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.AbstractPiccoloOperator","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.AbstractPiccoloOperator","text":"AbstractPiccoloOperator\n\nUnion type for operators.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator\n\nEmbedded operator type to represent an operator embedded in a subspace of a larger quantum system.\n\nFields\n\noperator::Matrix{<:Number}: Embedded operator of size   prod(subsystem_levels) x prod(subsystem_levels).\nsubspace::Vector{Int}: Indices of the subspace the operator is embedded in.\nsubsystem_levels::Vector{Int}: Levels of the subsystems in the composite system.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n)\n\nEmbed the subspace_operator into the provided subspaces of a composite system, where the subsystem_indices list the subspaces at which the operator is defined, and the subsystem_levels list the levels of the subsystems in which the operator is embedded.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, CompositeQuantumSystem}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    composite_system::CompositeQuantumSystem\n)\n\nEmbed the subspace_operator into the provided subspaces of a composite system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, QuantumSystem}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(subspace_operator::AbstractMatrix{<:Number}, system::QuantumSystem; kwargs...)\n\nEmbed the subspace_operator into a quantum system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{Int64}}} where T<:Number","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\n\nCreate an embedded operator. The operator is embedded at the subspace of the system spanned by the subsystem_levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.embed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.embed","text":"embed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator)\n\nEmbed the subspace_operator in the subspace of a larger embedded_operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.embed-Union{Tuple{R}, Tuple{AbstractMatrix{R}, AbstractVector{Int64}, Int64}} where R<:Number","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.embed","text":"embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int)\n\nEmbed an operator in the subspace of a larger matrix of size levels x levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.get_enr_subspace_indices-Tuple{Int64, AbstractVector{Int64}}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.get_enr_subspace_indices","text":"get_enr_subspace_indices(excitation_restriction::Int, subsystem_levels::AbstractVector{Int})\n\nGet the indices for the subspace of the quantum system with an excitation restriction.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.get_iso_vec_leakage_indices","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.get_iso_vec_leakage_indices","text":"get_iso_vec_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_iso_vec_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_iso_vec_leakage_indices(op::EmbeddedOperator)\n\nGet the indices for the leakage in the isomorphic vector space for operators.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.get_iso_vec_subspace_indices","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.get_iso_vec_subspace_indices","text":"get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the subspace in the isomorphic vector space for operators.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.get_leakage_indices","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.get_leakage_indices","text":"get_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_leakage_indices(op::EmbeddedOperator)\n\nGet the indices for the states that are outside of the provided subspace of the quantum system.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.get_subspace_indices","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.get_subspace_indices","text":"get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)\nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the provided subspace of the quantum system.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.unembed","text":"unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int})\n\nUnembed a subspace operator from the matrix. This is equivalent to calling matrix[subspace, subspace].\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.unembed","text":"unembed(op::AbstractMatrix, embedded_op::EmbeddedOperator)\n\nUnembed a sub-matrix from the op at the subspace defined by embedded_op.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.unembed-Tuple{EmbeddedOperator}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.unembed","text":"unembed(embedded_op::EmbeddedOperator)\n\nUnembed an embedded operator, returning the original operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.LiftedOperators.lift_operator","page":"Library","title":"Piccolo.Quantum.LiftedOperators.lift_operator","text":"lift_operator(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift_operator(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift_operator(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift_operator(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\n\nLift an operator acting on the i-th subsystem within subsystem_levels to an operator acting on the entire system spanning subsystem_levels.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}","page":"Library","title":"Piccolo.Quantum.DirectSums.direct_sum","text":"direct_sum(A::AbstractMatrix, B::AbstractMatrix)\n\nReturns the direct sum of two matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}","page":"Library","title":"Piccolo.Quantum.DirectSums.direct_sum","text":"direct_sum(AÃÉ‚Éó::AbstractVector, BÃÉ‚Éó::AbstractVector)\n\nReturns the direct sum of two iso_vec operators.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}","page":"Library","title":"Piccolo.Quantum.DirectSums.direct_sum","text":"direct_sum(sys1::QuantumSystem, sys2::QuantumSystem)\n\nReturns the direct sum of two QuantumSystem objects.\n\nConstructs a new system where the Hilbert space is the direct sum of the two input systems: H = H‚ÇÅ ‚äï H‚ÇÇ = [H‚ÇÅ  0 ]                [0   H‚ÇÇ]\n\nBoth systems must have the same number of drives. The resulting system uses sys1's drive_bounds.\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], [(-1.0, 1.0)])\nsys2 = QuantumSystem([PAULIS[:Y]], [(-1.0, 1.0)])\nsys_combined = direct_sum(sys1, sys2)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}","page":"Library","title":"Piccolo.Quantum.DirectSums.direct_sum","text":"direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC)\n\nReturns the direct sum of two sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.G-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.G","text":"G(H::AbstractMatrix)::Matrix{Float64}\n\nReturns the isomorphism of -iH, i.e. G(H) = textiso(-iH).\n\nSee also Isomorphisms.iso, Isomorphisms.H.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.H-Tuple{AbstractMatrix{<:Real}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.H","text":"H(G::AbstractMatrix{<:Real})\n\nReturns the inverse of G(H) = iso(-iH), i.e. returns H.\n\nSee also Isomorphisms.iso, Isomorphisms.G.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.ad_vec-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"Piccolo.Quantum.Isomorphisms.ad_vec","text":"ad_vec(H::AbstractMatrix{‚ÑÇ}; anti::Bool=false) where ‚ÑÇ <: Number\n\nReturns the vectorized adjoint action of a matrix H:\n\ntextad_vec(H) = mqty(1  0  0  1) otimes H - (-1)^textanti mqty(0  1  1  0) otimes H^*\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.bloch_to_ket-Union{Tuple{AbstractVector{R}}, Tuple{R}} where R<:Real","page":"Library","title":"Piccolo.Quantum.Isomorphisms.bloch_to_ket","text":"bloch_to_ket(v::AbstractVector{<:Real}; digits=6)\n\nConvert a Bloch vector to a ket (up to global phase).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.compact_iso_to_density-Tuple{AbstractVector{<:Real}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.compact_iso_to_density","text":"compact_iso_to_density(x::AbstractVector{<:Real})\n\nReconstructs a Hermitian density matrix œÅ from its compact real isomorphism vector x of length n^2.\n\nSee also density_to_compact_iso.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.density_lift_matrix-Tuple{Int64}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.density_lift_matrix","text":"density_lift_matrix(n::Int)\n\nReturns the sparse lift matrix L in mathbbR^2n^2 times n^2 that maps the compact density isomorphism to the full textiso_vec representation.\n\nGiven a compact vector x = textdensity_to_compact_iso(œÅ), the full representation is recovered as L x = textdensity_to_iso_vec(œÅ).\n\nThe matrix has n(2n-1) nonzero entries.\n\nSee also density_projection_matrix, density_to_compact_iso.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.density_projection_matrix-Tuple{Int64}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.density_projection_matrix","text":"density_projection_matrix(n::Int)\n\nReturns the sparse projection matrix P in mathbbR^n^2 times 2n^2 that maps the full textiso_vec representation to the compact density isomorphism.\n\nGiven a full vector v = textdensity_to_iso_vec(œÅ) for Hermitian œÅ, the compact representation is P v = textdensity_to_compact_iso(œÅ).\n\nSatisfies PL = I_n^2 where L = density_lift_matrix.\n\nSee also density_lift_matrix, density_to_compact_iso.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.density_to_compact_iso-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.density_to_compact_iso","text":"density_to_compact_iso(œÅ::AbstractMatrix{<:Number})\n\nReturns a compact real isomorphism vector of length n^2 for a Hermitian density matrix œÅ of size n times n. Exploits Hermiticity (œÅ = œÅ^dagger) to halve the representation size compared to density_to_iso_vec.\n\nThe compact vector is ordered as:\n\ntextRe(œÅ_jk) for j leq k (upper triangle, column-major): n(n+1)2 entries\ntextIm(œÅ_jk) for j  k (strict upper triangle, column-major): n(n-1)2 entries\n\nSee also compact_iso_to_density, density_lift_matrix, density_projection_matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.density_to_iso_vec-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.density_to_iso_vec","text":"density_to_iso_vec(œÅ::AbstractMatrix{<:Number})\n\nReturns the isomorphism œÅ‚ÉóÃÉ = ket_to_iso(vec(œÅ)) of a density matrix œÅ\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso","text":"iso(H::AbstractMatrix{<:Number})\n\nReturns the isomorphism of H:\n\niso(H) = widetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\nwhere Im(H) and Re(H) are the imaginary and real parts of H and the tilde  indicates the standard isomorphism of a complex valued matrix:\n\nwidetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\nSee also Isomorphisms.G, Isomorphisms.H.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso_D-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso_D","text":"iso_D(L::AbstractMatrix{‚ÑÇ}) where ‚ÑÇ <: Number\n\nReturns the isomorphic representation of the Lindblad dissipator L.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso_operator_to_iso_vec-Union{Tuple{AbstractMatrix{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù<:Real","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso_operator_to_iso_vec","text":"iso_operator_to_iso_vec(UÃÉ::AbstractMatrix{‚Ñù}) where ‚Ñù <: Real\n\nConvert a real matrix UÃÉ representing an isomorphism operator into a real vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso_operator_to_operator-Tuple{Any}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso_operator_to_operator","text":"iso_operator_to_operator(UÃÉ)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso_to_ket-Tuple{AbstractVector{<:Real}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso_to_ket","text":"iso_to_ket(œàÃÉ::AbstractVector{<:Real})\n\nConvert a real isomorphism vector œàÃÉ into a ket vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso_vec_to_density-Tuple{AbstractVector{<:Real}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso_vec_to_density","text":"iso_vec_to_density(œÅ‚ÉóÃÉ::AbstractVector{<:Real})\n\nReturns the density matrix œÅ from its isomorphism œÅ‚ÉóÃÉ\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso_vec_to_iso_operator-Union{Tuple{AbstractVector{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù<:Real","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso_vec_to_iso_operator","text":"iso_vec_to_iso_operator(UÃÉ‚Éó::AbstractVector{‚Ñù}) where ‚Ñù <: Real\n\nConvert a real vector UÃÉ‚Éó into a real matrix representing an isomorphism operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso_vec_to_operator-Union{Tuple{AbstractVector{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù<:Real","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso_vec_to_operator","text":"iso_vec_to_operator(UÃÉ‚Éó::AbstractVector{‚Ñù}) where ‚Ñù <: Real\n\nConvert a real vector UÃÉ‚Éó into a complex matrix representing an operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.ket_to_bloch-Tuple{AbstractVector{<:Number}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.ket_to_bloch","text":"ket_to_bloch(œà::AbstractVector{<:Number})\n\nConvert a ket to a Bloch vector representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.ket_to_iso-Tuple{AbstractVector{<:Number}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.ket_to_iso","text":"ket_to_iso(œà::AbstractVector{<:Number})\n\nConvert a ket vector œà into a complex vector with real and imaginary parts.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.mat-Tuple{AbstractVector}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.mat","text":"mat(x::AbstractVector)\n\nConvert a vector x into a square matrix. The length of x must be a perfect square.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.operator_to_iso_operator-Tuple{Any}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.operator_to_iso_operator","text":"operator_to_iso_operator(U)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.operator_to_iso_vec-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"Piccolo.Quantum.Isomorphisms.operator_to_iso_vec","text":"operator_to_iso_vec(U::AbstractMatrix{‚ÑÇ}) where ‚ÑÇ <: Number\n\nConvert a complex matrix U representing an operator into a real vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.var_G-Union{Tuple{‚Ñù2}, Tuple{‚Ñù1}, Tuple{AbstractMatrix{‚Ñù1}, AbstractVector{<:AbstractMatrix{‚Ñù2}}}} where {‚Ñù1<:Real, ‚Ñù2<:Real}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.var_G","text":"var_G(G::AbstractMatrix{<:Real}, G_vars::AbstractVector{<:AbstractMatrix{<:Real}})\n\nReturns the variational generator of G with variational derivatives, G_vars.\n\nThe variational generator is \n\ntextvar_G(G G_a G_b) = mqty( G  0  0  G_a  G  0  G_b  0  G )\n\nwhere G is the isomorphism of a Hamiltonian and G_a and G_b are the variational  derivatives of G for parameters a and b, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumControlProblems.QuantumControlProblem","page":"Library","title":"Piccolo.Control.QuantumControlProblems.QuantumControlProblem","text":"QuantumControlProblem{QT<:AbstractQuantumTrajectory}\n\nWrapper combining quantum trajectory information with trajectory optimization problem.\n\nThis type enables:\n\nType-stable dispatch on quantum trajectory type (Unitary, Ket, Density)\nClean separation of quantum information (system, goal) from optimization details\nComposable problem transformations (e.g., SmoothPulseProblem ‚Üí MinimumTimeProblem)\n\nFields\n\nqtraj::QT: Quantum trajectory containing system, goal, and quantum state information\nprob::DirectTrajOptProblem: Direct trajectory optimization problem with objective, dynamics, constraints\n\nConstruction\n\nTypically created via problem templates:\n\nqtraj = UnitaryTrajectory(sys, U_goal, N)\nqcp = SmoothPulseProblem(qtraj; Q=100.0, R=1e-2)\n\nAccessors\n\nget_trajectory(qcp): Get the NamedTrajectory\nget_system(qcp): Get the QuantumSystem\nget_goal(qcp): Get the goal state/unitary\nstate_name(qcp): Get the state variable name\ndrive_name(qcp): Get the control variable name\n\nSolving\n\nsolve!(qcp; max_iter=100, verbose=true)\n\n\n\n\n\n","category":"type"},{"location":"lib/#DirectTrajOpt.Solvers.solve!-Tuple{QuantumControlProblem}","page":"Library","title":"DirectTrajOpt.Solvers.solve!","text":"solve!(qcp::QuantumControlProblem; sync::Bool=true, kwargs...)\n\nSolve the quantum control problem by forwarding to the inner DirectTrajOptProblem.\n\nArguments\n\nsync::Bool=true: If true, call sync_trajectory! after solving to update qtraj.trajectory with physical control values. Set to false to skip synchronization (e.g., for debugging).\n\nAll other keyword arguments are passed to the DirectTrajOpt solver.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumControlProblems.get_trajectory-Tuple{QuantumControlProblem}","page":"Library","title":"Piccolo.Control.QuantumControlProblems.get_trajectory","text":"get_trajectory(qcp::QuantumControlProblem)\n\nGet the NamedTrajectory from the optimization problem.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumControlProblems.sync_trajectory!-Tuple{QuantumControlProblem}","page":"Library","title":"Piccolo.Control.QuantumControlProblems.sync_trajectory!","text":"sync_trajectory!(qcp::QuantumControlProblem)\n\nUpdate the quantum trajectory in-place from the optimized control values.\n\nAfter optimization, this function:\n\nExtracts the optimized controls from prob.trajectory (unadapting if needed)\nCreates a new pulse with those controls via extract_pulse\nRe-solves the ODE to get the updated quantum evolution\nReplaces qtraj with the new quantum trajectory\n\nThis gives you access to the continuous-time ODE solution with the optimized controls, allowing you to:\n\nEvaluate the fidelity via fidelity(qcp.qtraj)\nSample the quantum state at any time via qcp.qtraj(t)\nGet the optimized pulse via get_pulse(qcp.qtraj)\n\nExample\n\nsolve!(qcp; max_iter=100)  # Automatically calls sync_trajectory!\nfid = fidelity(qcp.qtraj)  # Evaluate fidelity with continuous-time solution\npulse = get_pulse(qcp.qtraj)  # Get the optimized pulse\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.drive_name-Tuple{QuantumControlProblem}","page":"Library","title":"Piccolo.Quantum.Pulses.drive_name","text":"drive_name(qcp::QuantumControlProblem)\n\nGet the control variable name from the quantum trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_goal-Tuple{QuantumControlProblem}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_goal","text":"get_goal(qcp::QuantumControlProblem)\n\nGet the goal state/operator from the quantum trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_system-Tuple{QuantumControlProblem}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_system","text":"get_system(qcp::QuantumControlProblem)\n\nGet the QuantumSystem from the quantum trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.state_name-Tuple{QuantumControlProblem}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.state_name","text":"state_name(qcp::QuantumControlProblem)\n\nGet the state variable name from the quantum trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{QuantumControlProblem}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(qcp::QuantumControlProblem; kwargs...)\n\nCompute the fidelity of the quantum trajectory.\n\nThis is a convenience wrapper that forwards to fidelity(qcp.qtraj; kwargs...).\n\nExample\n\nsolve!(qcp)\nfid = fidelity(qcp)  # Equivalent to fidelity(qcp.qtraj)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.BangBangPulseProblem-Tuple{AbstractQuantumTrajectory{<:ZeroOrderPulse}, Int64}","page":"Library","title":"Piccolo.Control.ProblemTemplates.BangBangPulseProblem","text":"BangBangPulseProblem(qtraj::AbstractQuantumTrajectory{<:ZeroOrderPulse}, N::Int; kwargs...)\n\nConstruct a QuantumControlProblem that promotes bang-bang (piecewise-constant, few-switch) controls by penalizing du_1 via an exact slack reformulation.\n\nUnlike SmoothPulseProblem (which uses 2 derivative levels with L2 regularization), this stores only 1 derivative (du) and uses slack variables to impose an exact L1 penalty on it, promoting sparsity in du and thus fewer switches.\n\nL1 penalty via slack variables\n\nIntroduces slack variables s geq 0 (same dimension as du) and enforces:\n\ndu_ki leq s_ki\n\nThen minimizes the linear cost R_du sum_k sum_i s_ki Delta t_k. At optimality, s = du, giving the exact L1 norm.\n\nArguments\n\nqtraj::AbstractQuantumTrajectory{<:ZeroOrderPulse}: Quantum trajectory with piecewise constant pulse\nN::Int: Number of timesteps for discretization\n\nKeyword Arguments\n\nintegrator::Union{Nothing, AbstractIntegrator, Vector{<:AbstractIntegrator}}=nothing: Optional custom integrator(s). If not provided, uses BilinearIntegrator.\nglobal_names::Union{Nothing, Vector{Symbol}}=nothing: Names of global variables to optimize. Requires a custom integrator.\nglobal_bounds::Union{Nothing, Dict{Symbol, Union{Float64, Tuple{Float64, Float64}}}}=nothing: Bounds for global variables.\ndu_bound::Float64=Inf: Bound on discrete first derivative\nŒît_bounds::Union{Nothing, Tuple{Float64, Float64}}=nothing: Timestep bounds\nQ::Float64=100.0: Weight on infidelity/objective\nR::Float64=1e-2: Default regularization weight\nR_u::Union{Float64, Vector{Float64}}=0.0: L2 weight on control amplitude (defaults to 0 ‚Äî bang-bang needs no amplitude regularization)\nR_du::Union{Float64, Vector{Float64}}=R: L1 weight on du (applied to slacks)\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: Additional constraints\npiccolo_options::PiccoloOptions=PiccoloOptions(): Piccolo solver options\n\nReturns\n\nQuantumControlProblem: Wrapper containing quantum trajectory and optimization problem\n\nExamples\n\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\npulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = BangBangPulseProblem(qtraj, N; Q=100.0, R_du=1e-1)\nsolve!(qcp; max_iter=200)\n\nSee also: SmoothPulseProblem for smooth (L2-regularized) controls.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.BangBangPulseProblem-Tuple{MultiKetTrajectory{<:ZeroOrderPulse}, Int64}","page":"Library","title":"Piccolo.Control.ProblemTemplates.BangBangPulseProblem","text":"BangBangPulseProblem(qtraj::MultiKetTrajectory{<:ZeroOrderPulse}, N::Int; kwargs...)\n\nConstruct a QuantumControlProblem for bang-bang pulse optimization over an ensemble of ket state transfers with piecewise constant controls.\n\nSee the single-trajectory method for full documentation of keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.BangBangPulseProblem-Union{Tuple{P}, Tuple{AbstractQuantumTrajectory{P}, Int64}} where P<:AbstractPulse","page":"Library","title":"Piccolo.Control.ProblemTemplates.BangBangPulseProblem","text":"BangBangPulseProblem(qtraj::AbstractQuantumTrajectory, N::Int; kwargs...)\n\nFallback method that provides helpful error for non-ZeroOrderPulse types.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.MinimumTimeProblem-Union{Tuple{QuantumControlProblem{QT}}, Tuple{QT}} where QT<:AbstractQuantumTrajectory","page":"Library","title":"Piccolo.Control.ProblemTemplates.MinimumTimeProblem","text":"MinimumTimeProblem(qcp::QuantumControlProblem; kwargs...)\n\nConvert an existing quantum control problem to minimum-time optimization.\n\nIMPORTANT: This function requires an existing QuantumControlProblem (e.g., from SmoothPulseProblem). It cannot be created directly from a quantum trajectory. The workflow is:\n\nCreate base problem with SmoothPulseProblem (or similar)\nSolve base problem to get feasible solution\nConvert to minimum-time with MinimumTimeProblem\n\nThis ensures the problem starts from a good initialization and maintains solution quality through the final fidelity constraint.\n\nType Dispatch\n\nAutomatically handles different quantum trajectory types through the type parameter:\n\nQuantumControlProblem{UnitaryTrajectory} ‚Üí Uses FinalUnitaryFidelityConstraint\nQuantumControlProblem{KetTrajectory} ‚Üí Uses FinalKetFidelityConstraint\nQuantumControlProblem{DensityTrajectory} ‚Üí Not yet implemented\n\nThe optimization problem is:\n\nbeginaligned\nundersetvectildeq u Delta ttextminimize  quad\nJ_textoriginal(vectildeq u) + D sum_t Delta t_t \ntext subject to   quad textoriginal dynamics  constraints \n F_textfinal geq F_textthreshold \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere q represents the quantum state (unitary, ket, or density matrix).\n\nArguments\n\nqcp::QuantumControlProblem: Existing quantum control problem to convert\n\nKeyword Arguments\n\nfinal_fidelity::Float64=0.99: Minimum fidelity constraint at final time\nD::Float64=100.0: Weight on minimum-time objective ‚àëŒît\npiccolo_options::PiccoloOptions=PiccoloOptions(): Piccolo solver options\n\nReturns\n\nQuantumControlProblem: New problem with minimum-time objective and fidelity constraint\n\nExamples\n\n# Standard workflow\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\npulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# Step 1: Create and solve base smooth pulse problem (with Œît_bounds for free time)\nqcp_smooth = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2, Œît_bounds=(0.01, 0.5))\nsolve!(qcp_smooth; max_iter=100)\n\n# Step 2: Convert to minimum-time\nqcp_mintime = MinimumTimeProblem(qcp_smooth; final_fidelity=0.99, D=100.0)\nsolve!(qcp_mintime; max_iter=100)\n\n# Compare durations\nduration_before = sum(get_timesteps(get_trajectory(qcp_smooth)))\nduration_after = sum(get_timesteps(get_trajectory(qcp_mintime)))\n@assert duration_after <= duration_before\n\n# Nested transformations also work\nqcp_final = MinimumTimeProblem(\n    RobustnessProblem(qcp_smooth);  # Future feature\n    final_fidelity=0.95\n)\n\nConvenience Constructors\n\nYou can also update the goal when creating minimum-time problem:\n\n# Different goal for minimum-time optimization\nqcp_mintime = MinimumTimeProblem(qcp_smooth; goal=U_goal_new, final_fidelity=0.98)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.SamplingProblem-Tuple{QuantumControlProblem, Vector{<:AbstractQuantumSystem}}","page":"Library","title":"Piccolo.Control.ProblemTemplates.SamplingProblem","text":"SamplingProblem(qcp::QuantumControlProblem, systems::Vector{<:AbstractQuantumSystem}; kwargs...)\n\nConstruct a SamplingProblem from an existing QuantumControlProblem and a list of systems.\n\nThis creates a robust optimization problem where the controls are shared across all systems, but each system evolves according to its own dynamics. The objective is the weighted sum of fidelity objectives for each system.\n\nArguments\n\nqcp::QuantumControlProblem: The base problem (defines nominal trajectory, objective, etc.)\nsystems::Vector{<:AbstractQuantumSystem}: List of systems to optimize over\n\nKeyword Arguments\n\nweights::Vector{Float64}=fill(1.0, length(systems)): Weights for each system\nQ::Float64=100.0: Weight on infidelity objective (explicit, not extracted from base problem)\npiccolo_options::PiccoloOptions=PiccoloOptions(): Options for the solver\n\nReturns\n\nQuantumControlProblem{SamplingTrajectory}: A new problem with the sampling trajectory\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.SmoothPulseProblem-Tuple{AbstractQuantumTrajectory{<:ZeroOrderPulse}, Int64}","page":"Library","title":"Piccolo.Control.ProblemTemplates.SmoothPulseProblem","text":"SmoothPulseProblem(qtraj::AbstractQuantumTrajectory{<:ZeroOrderPulse}, N::Int; kwargs...)\n\nConstruct a QuantumControlProblem for smooth pulse optimization with piecewise constant controls.\n\nNote: This problem template is for ZeroOrderPulse only. For spline-based pulses (LinearSplinePulse, CubicSplinePulse), use SplinePulseProblem instead.\n\nThe problem adds discrete derivative variables (du, ddu) that:\n\nRegularize control changes between timesteps\nEnforce smoothness via DerivativeIntegrator constraints\n\nArguments\n\nqtraj::AbstractQuantumTrajectory{<:ZeroOrderPulse}: Quantum trajectory with piecewise constant pulse\nN::Int: Number of timesteps for discretization\n\nKeyword Arguments\n\nintegrator::Union{Nothing, AbstractIntegrator, Vector{<:AbstractIntegrator}}=nothing: Optional custom integrator(s). If not provided, uses BilinearIntegrator (which does not support global variables). A custom integrator is required when global_names is specified.\nglobal_names::Union{Nothing, Vector{Symbol}}=nothing: Names of global variables to optimize. Requires a custom integrator (e.g., HermitianExponentialIntegrator from Piccolissimo) that supports global variables.\nglobal_bounds::Union{Nothing, Dict{Symbol, Union{Float64, Tuple{Float64, Float64}}}}=nothing: Bounds for global variables. Keys are variable names, values are either a scalar (symmetric bounds ¬±value) or a tuple (lower, upper).\ndu_bound::Float64=Inf: Bound on discrete first derivative (controls jump rate)\nddu_bound::Float64=1.0: Bound on discrete second derivative (controls acceleration)\nQ::Float64=100.0: Weight on infidelity/objective\nR::Float64=1e-2: Weight on regularization terms (u, uÃá, √º)\nR_u::Union{Float64, Vector{Float64}}=R: Weight on control regularization\nR_du::Union{Float64, Vector{Float64}}=R: Weight on first derivative regularization\nR_ddu::Union{Float64, Vector{Float64}}=R: Weight on second derivative regularization\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: Additional constraints\npiccolo_options::PiccoloOptions=PiccoloOptions(): Piccolo solver options\n\nReturns\n\nQuantumControlProblem: Wrapper containing quantum trajectory and optimization problem\n\nExamples\n\n# Unitary gate synthesis with piecewise constant pulse\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\npulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2)\nsolve!(qcp; max_iter=100)\n\n# Quantum state transfer\npulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))\nqtraj = KetTrajectory(sys, pulse, œà_init, œà_goal)\nqcp = SmoothPulseProblem(qtraj, N; Q=50.0, R=1e-3)\nsolve!(qcp)\n\nSee also: SplinePulseProblem for spline-based pulses.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.SmoothPulseProblem-Tuple{MultiKetTrajectory{<:ZeroOrderPulse}, Int64}","page":"Library","title":"Piccolo.Control.ProblemTemplates.SmoothPulseProblem","text":"SmoothPulseProblem(qtraj::MultiKetTrajectory{<:ZeroOrderPulse}, N::Int; kwargs...)\n\nConstruct a QuantumControlProblem for smooth pulse optimization over an ensemble of ket state transfers with piecewise constant controls.\n\nThis handles the case where you want to optimize a single pulse that achieves multiple  state transfers simultaneously (e.g., |0‚ü©‚Üí|1‚ü© and |1‚ü©‚Üí|0‚ü© for an X gate via state transfer).\n\nNote: This problem template is for ZeroOrderPulse only. For spline-based pulses, use SplinePulseProblem instead.\n\nArguments\n\nqtraj::MultiKetTrajectory{<:ZeroOrderPulse}: Ensemble of ket state transfers with piecewise constant pulse\nN::Int: Number of timesteps for the discretization\n\nKeyword Arguments\n\nintegrator::Union{Nothing, AbstractIntegrator, Vector{<:AbstractIntegrator}}=nothing: Optional custom integrator(s). If not provided, the default BilinearIntegrator is used. When global_names is specified, you must supply a custom integrator here (i.e., do not rely on the default BilinearIntegrator) that supports global variables.\nglobal_names::Union{Nothing, Vector{Symbol}}=nothing: Names of global variables to optimize. Requires a custom integrator provided via integrator (e.g., HermitianExponentialIntegrator from Piccolissimo) that supports global variables.\nglobal_bounds::Union{Nothing, Dict{Symbol, Union{Float64, Tuple{Float64, Float64}}}}=nothing: Bounds for global variables. Keys are variable names, values are either a scalar (symmetric bounds ¬±value) or a tuple (lower, upper).\ndu_bound::Float64=Inf: Bound on discrete first derivative\nddu_bound::Float64=1.0: Bound on discrete second derivative\nQ::Float64=100.0: Weight on infidelity/objective\nR::Float64=1e-2: Weight on regularization terms (u, uÃá, √º)\nR_u::Union{Float64, Vector{Float64}}=R: Weight on control regularization\nR_du::Union{Float64, Vector{Float64}}=R: Weight on first derivative regularization\nR_ddu::Union{Float64, Vector{Float64}}=R: Weight on second derivative regularization\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: Additional constraints\npiccolo_options::PiccoloOptions=PiccoloOptions(): Piccolo solver options\n\nReturns\n\nQuantumControlProblem{MultiKetTrajectory}: Wrapper containing ensemble trajectory and optimization problem\n\nExamples\n\n# Create ensemble for X gate via state transfer\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\npulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))\n\nœà0 = ComplexF64[1.0, 0.0]\nœà1 = ComplexF64[0.0, 1.0]\n\nensemble_qtraj = MultiKetTrajectory(sys, pulse, [œà0, œà1], [œà1, œà0])\nqcp = SmoothPulseProblem(ensemble_qtraj, N; Q=100.0, R=1e-2)\nsolve!(qcp; max_iter=100)\n\nSee also: SplinePulseProblem for spline-based pulses.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.SmoothPulseProblem-Union{Tuple{P}, Tuple{AbstractQuantumTrajectory{P}, Int64}} where P<:AbstractPulse","page":"Library","title":"Piccolo.Control.ProblemTemplates.SmoothPulseProblem","text":"SmoothPulseProblem(qtraj::AbstractQuantumTrajectory, N::Int; kwargs...)\n\nFallback method that provides helpful error for non-ZeroOrderPulse types.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.SplinePulseProblem","page":"Library","title":"Piccolo.Control.ProblemTemplates.SplinePulseProblem","text":"SplinePulseProblem(qtraj::MultiKetTrajectory{<:AbstractSplinePulse}; kwargs...)\nSplinePulseProblem(qtraj::MultiKetTrajectory{<:AbstractSplinePulse}, N::Int; kwargs...)\nSplinePulseProblem(qtraj::MultiKetTrajectory{<:AbstractSplinePulse}, times::AbstractVector; kwargs...)\n\nCreate a spline-based trajectory optimization problem for ensemble ket state transfers.\n\nUses coherent fidelity objective (phases must align) for gate implementation.\n\nArguments\n\nqtraj::MultiKetTrajectory{<:AbstractSplinePulse}: Ensemble trajectory with spline pulse\nN_or_times: One of:\nnothing (default): Use native knot times from spline pulse\nN::Int: Number of uniformly spaced timesteps\ntimes::AbstractVector: Specific sample times\n\nKeyword Arguments\n\nSame as the base SplinePulseProblem method.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Control.ProblemTemplates.SplinePulseProblem-2","page":"Library","title":"Piccolo.Control.ProblemTemplates.SplinePulseProblem","text":"SplinePulseProblem(qtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}; kwargs...)\nSplinePulseProblem(qtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}, N::Int; kwargs...)\nSplinePulseProblem(qtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}, times::AbstractVector; kwargs...)\n\nConstruct a QuantumControlProblem for spline-based pulse optimization.\n\nUnlike SmoothPulseProblem (which uses piecewise constant controls with discrete smoothing  variables), this problem template is designed for spline-based pulses where the derivative  variables (du) are the actual spline coefficients or slopes.\n\nPulse Type Semantics\n\nLinearSplinePulse: The du variable represents the slope between knots. A DerivativeIntegrator constraint enforces du[k] = (u[k+1] - u[k]) / Œît, making the slopes consistent with the linear interpolation. This constraint ensures mathematical rigor while allowing slope regularization/bounds.\n\nCubicSplinePulse (Hermite spline): The du variable is the tangent/derivative at each  knot point, which is a true independent degree of freedom in Hermite interpolation. No  DerivativeIntegrator is added - the optimizer can adjust both :u and :du independently.\n\nMathematical Notes\n\nLinearSplinePulse: Always adds :du and DerivativeIntegrator to enforce slope consistency\nCubicSplinePulse: :du values are Hermite tangents (unconstrained, only regularized)\n\nBoth pulse types always have :du components in the trajectory, simplifying integrator implementations.\n\nArguments\n\nqtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}: Quantum trajectory with spline pulse\nN_or_times: One of:\nnothing (default): Use native knot times from spline pulse (ideal for warm-starting)\nN::Int: Number of uniformly spaced timesteps\ntimes::AbstractVector: Specific sample times\n\nKeyword Arguments\n\nintegrator::Union{Nothing, AbstractIntegrator, Vector{<:AbstractIntegrator}}=nothing: Optional custom integrator(s). If not provided, uses BilinearIntegrator (which does not support global variables). A custom integrator is required when global_names is specified.\nglobal_names::Union{Nothing, Vector{Symbol}}=nothing: Names of global variables to optimize. Requires a custom integrator (e.g., SplineIntegrator from Piccolissimo) that supports global variables.\nglobal_bounds::Union{Nothing, Dict{Symbol, Union{Float64, Tuple{Float64, Float64}}}}=nothing: Bounds for global variables. Keys are variable names, values are either a scalar (symmetric bounds ¬±value) or a tuple (lower, upper).\ndu_bound::Float64=Inf: Bound on derivative (slope) magnitude\nQ::Float64=100.0: Weight on infidelity/objective\nR::Float64=1e-2: Weight on regularization terms\nR_u::Union{Float64, Vector{Float64}}=R: Weight on control regularization\nR_du::Union{Float64, Vector{Float64}}=R: Weight on derivative regularization  \nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: Additional constraints\npiccolo_options::PiccoloOptions=PiccoloOptions(): Piccolo solver options\n\nReturns\n\nQuantumControlProblem{<:AbstractQuantumTrajectory}: Wrapper containing trajectory and optimization problem\n\nExamples\n\n# Create system and initial pulse\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\npulse = CubicSplinePulse(u_init, du_init, times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# Use native knot structure (best for warm-starting from saved pulse)\nqcp = SplinePulseProblem(qtraj; Q=100.0, du_bound=10.0)\n\n# Or resample to different number of knots\nqcp = SplinePulseProblem(qtraj, 50; Q=100.0, du_bound=10.0)\n\nsolve!(qcp; max_iter=100)\n\nSee also: SmoothPulseProblem for piecewise constant pulses with discrete smoothing.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Control.ProblemTemplates.SplinePulseProblem-Union{Tuple{AbstractQuantumTrajectory{P}}, Tuple{P}, Tuple{AbstractQuantumTrajectory{P}, Union{Nothing, Int64, AbstractVector{<:Real}}}} where P<:AbstractPulse","page":"Library","title":"Piccolo.Control.ProblemTemplates.SplinePulseProblem","text":"SplinePulseProblem(qtraj::AbstractQuantumTrajectory, N_or_times; kwargs...)\n\nFallback method that provides helpful error for non-spline pulse types.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates._ensemble_ket_objective-Tuple{MultiKetTrajectory, NamedTrajectory, Vector{Symbol}, Vector{Float64}, Vector, Float64}","page":"Library","title":"Piccolo.Control.ProblemTemplates._ensemble_ket_objective","text":"_ensemble_ket_objective(qtraj::MultiKetTrajectory, traj, state_names, weights, goals, Q)\n\nCreate a coherent fidelity objective for ensemble state transfers.\n\nFor ensemble trajectories (implementing a gate via multiple state transfers), we use coherent fidelity:     Fcoherent = |1/n ‚àë·µ¢ ‚ü®œà·µ¢goal|œà·µ¢‚ü©|¬≤\n\nThis requires all state overlaps to have aligned phases, which is essential for gate implementation (the gate should have a single global phase).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates._final_fidelity_constraint-Tuple{MultiKetTrajectory, Float64, NamedTrajectory}","page":"Library","title":"Piccolo.Control.ProblemTemplates._final_fidelity_constraint","text":"_final_fidelity_constraint(qtraj::MultiKetTrajectory, final_fidelity, traj)\n\nCreate a coherent fidelity constraint for an MultiKetTrajectory.\n\nUses coherent fidelity: F = |1/n ‚àë·µ¢ ‚ü®œà·µ¢_goal|œà·µ¢‚ü©|¬≤\n\nThis enforces that all state transfers have aligned global phases, which is  essential when implementing a gate via state transfer (e.g., X gate via  |0‚ü©‚Üí|1‚ü© and |1‚ü©‚Üí|0‚ü©).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.add_global_bounds_constraints!-Tuple{AbstractVector{<:AbstractConstraint}, Any, NamedTrajectory}","page":"Library","title":"Piccolo.Control.ProblemTemplates.add_global_bounds_constraints!","text":"add_global_bounds_constraints!(constraints, global_bounds, traj; verbose=false)\n\nAdd GlobalBoundsConstraint entries for each global variable specified in global_bounds.\n\nConverts bounds from user-friendly formats to the format expected by GlobalBoundsConstraint:\n\nFloat64: Symmetric scalar bounds (applied symmetrically to all dimensions)\nTuple{Float64, Float64}: Asymmetric scalar bounds (expanded to vectors)\nVector or Tuple{Vector, Vector}: Already in correct format (passed through)\n\nModifies constraints in place.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.extract_regularization-Tuple{Any, Symbol, NamedTrajectory}","page":"Library","title":"Piccolo.Control.ProblemTemplates.extract_regularization","text":"extract_regularization(objective, state_sym::Symbol, new_traj::NamedTrajectory) -> AbstractObjective\n\nExtract regularization terms (non-state-dependent objectives) from a composite objective, filtering to only include terms for variables that exist in the new trajectory.\n\nUsed by SamplingProblem to extract shared regularizers (e.g., control penalty) from the base problem while excluding regularizers for variables that don't exist in the sampling trajectory (e.g., :du, :ddu which are added by SmoothPulseProblem).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.sampling_state_objective-Tuple{UnitaryTrajectory, NamedTrajectory, Symbol, Float64}","page":"Library","title":"Piccolo.Control.ProblemTemplates.sampling_state_objective","text":"sampling_state_objective(qtraj, traj, state_sym, Q)\n\nCreate the state-dependent objective for a sampling member. Dispatches on quantum trajectory type.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumObjectives.CoherentKetInfidelityObjective-Tuple{Vector{<:AbstractVector{<:Complex}}, Vector{Symbol}, NamedTrajectory}","page":"Library","title":"Piccolo.Control.QuantumObjectives.CoherentKetInfidelityObjective","text":"CoherentKetInfidelityObjective(œà_goals, œàÃÉ_names, traj; Q=100.0)\n\nCreate a terminal objective for coherent ket state infidelity across multiple states.\n\nCoherent fidelity is defined as:     Fcoherent = |1/n ‚àë·µ¢ ‚ü®œà·µ¢goal|œà·µ¢‚ü©|¬≤\n\nUnlike incoherent fidelity (average of individual |‚ü®œà·µ¢_goal|œà·µ¢‚ü©|¬≤), coherent fidelity  requires all state overlaps to have aligned phases. This is essential when implementing a gate via multiple state transfers - the gate should have a single global phase, not independent phases per state.\n\nArguments\n\nœà_goals::Vector{<:AbstractVector{<:Complex}}: Target ket states\nœàÃÉ_names::Vector{Symbol}: Names of isomorphic state variables in trajectory\ntraj::NamedTrajectory: The trajectory\n\nKeyword Arguments\n\nQ::Float64=100.0: Weight on the infidelity objective\n\nExample\n\n# For implementing X gate via |0‚ü©‚Üí|1‚ü© and |1‚ü©‚Üí|0‚ü©\ngoals = [ComplexF64[0, 1], ComplexF64[1, 0]]\nnames = [:œàÃÉ1, :œàÃÉ2]\nobj = CoherentKetInfidelityObjective(goals, names, traj; Q=100.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumObjectives.DensityMatrixInfidelityObjective-Tuple{Symbol, AbstractMatrix{<:ComplexF64}, NamedTrajectory}","page":"Library","title":"Piccolo.Control.QuantumObjectives.DensityMatrixInfidelityObjective","text":"DensityMatrixInfidelityObjective(œÅÃÉ_name, œÅ_goal, traj; Q=100.0)\n\nTerminal objective for density matrix fidelity using the compact isomorphism.\n\nMinimizes |1 - tr(œÅ * œÅ_goal)| where œÅ is reconstructed from the compact iso vector via compact_iso_to_density.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumObjectives.KetInfidelityObjective-Tuple{AbstractVector{<:Complex}, Symbol, NamedTrajectory}","page":"Library","title":"Piccolo.Control.QuantumObjectives.KetInfidelityObjective","text":"KetInfidelityObjective(œà_goal, œàÃÉ_name, traj; Q=100.0)\n\nCreate a terminal objective for ket state infidelity with an explicit goal state.\n\nThis variant is useful for SamplingProblem and EnsembleTrajectory where the goal is shared across multiple state variables that don't have individual goals in traj.goal.\n\nArguments\n\nœà_goal::AbstractVector{<:Complex}: The target ket state (complex vector)\nœàÃÉ_name::Symbol: Name of the isomorphic state variable in the trajectory\ntraj::NamedTrajectory: The trajectory\n\nKeyword Arguments\n\nQ::Float64=100.0: Weight on the infidelity objective\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumObjectives.KetInfidelityObjective-Tuple{Symbol, NamedTrajectory}","page":"Library","title":"Piccolo.Control.QuantumObjectives.KetInfidelityObjective","text":"KetInfidelityObjective(œàÃÉ_name, traj; Q=100.0)\n\nCreate a terminal objective for ket state infidelity, using the goal from traj.goal[œàÃÉ_name].\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumObjectives.LeakageObjective-Tuple{AbstractVector{Int64}, Symbol, NamedTrajectory}","page":"Library","title":"Piccolo.Control.QuantumObjectives.LeakageObjective","text":"LeakageObjective(indices, name, traj::NamedTrajectory)\n\nConstruct a KnotPointObjective that penalizes leakage of name at the knot points specified by times at any indices that are outside the computational subspace.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumObjectives.coherent_ket_fidelity-Tuple{Any, Vector{<:AbstractVector{<:ComplexF64}}}","page":"Library","title":"Piccolo.Control.QuantumObjectives.coherent_ket_fidelity","text":"coherent_ket_fidelity(œàÃÉs, œà_goals)\n\nCompute coherent fidelity across multiple ket states:\n\nF_coherent = |1/n ‚àë·µ¢ ‚ü®œà·µ¢_goal|œà·µ¢‚ü©|¬≤\n\nThis requires all overlaps to have consistent phases (global phase alignment), which is necessary for implementing gates via state transfer.\n\nArguments\n\nœàÃÉs::Vector{<:AbstractVector}: List of isomorphic state vectors\nœà_goals::Vector{<:AbstractVector{<:Complex}}: List of goal states\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumConstraints.FinalCoherentKetFidelityConstraint-Tuple{Vector{<:AbstractVector{<:Complex}}, Vector{Symbol}, Float64, NamedTrajectory}","page":"Library","title":"Piccolo.Control.QuantumConstraints.FinalCoherentKetFidelityConstraint","text":"FinalCoherentKetFidelityConstraint(œà_goals, œàÃÉ_names, final_fidelity, traj)\n\nCreate a final fidelity constraint using coherent ket fidelity across multiple states.\n\nCoherent fidelity: F = |1/n ‚àë·µ¢ ‚ü®œà·µ¢_goal|œà·µ¢‚ü©|¬≤\n\nThis constraint enforces that all state overlaps have aligned phases, which is  essential when implementing a gate via multiple state transfers (e.g., MultiKetTrajectory).\n\nArguments\n\nœà_goals::Vector{<:AbstractVector{<:Complex}}: Target ket states\nœàÃÉ_names::Vector{Symbol}: Names of isomorphic state variables in trajectory\nfinal_fidelity::Float64: Minimum fidelity threshold (constraint: F ‚â• final_fidelity)\ntraj::NamedTrajectory: The trajectory\n\nExample\n\n# For implementing X gate via |0‚ü©‚Üí|1‚ü© and |1‚ü©‚Üí|0‚ü©\ngoals = [ComplexF64[0, 1], ComplexF64[1, 0]]\nnames = [:œàÃÉ1, :œàÃÉ2]\nconstraint = FinalCoherentKetFidelityConstraint(goals, names, 0.99, traj)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumConstraints.LeakageConstraint-Tuple{Float64, AbstractVector{Int64}, Symbol, NamedTrajectory}","page":"Library","title":"Piccolo.Control.QuantumConstraints.LeakageConstraint","text":"LeakageConstraint(value, indices, name, traj::NamedTrajectory)\n\nConstruct a KnotPointConstraint that bounds leakage of name at the knot points specified by times at any indices that are outside the computational subspace.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.Options.PiccoloOptions","page":"Library","title":"Piccolo.Control.Options.PiccoloOptions","text":"PiccoloOptions\n\nOptions for the Piccolo quantum optimal control library.\n\nFields\n\nverbose::Bool = true: Print verbose output\ntimesteps_all_equal::Bool = true: Use equal timesteps\nrollout_integrator::Function = expv: Integrator to use for rollout\ngeodesic = true: Use the geodesic to initialize the optimization.\nzero_initial_and_final_derivative::Bool=false: Zero the initial and final control pulse derivatives.\ncomplex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing: Name of the complex control norm constraint.\ncomplex_control_norm_constraint_radius::Float64 = 1.0: Radius of the complex control norm constraint.\nbound_state::Bool = false: Bound the state variables <= 1.0.\nleakage_constraint::Bool = false: Suppress leakage with constraint and cost.\nleakage_constraint_value::Float64 = 1e-2: Value for the leakage constraint.\nleakage_cost::Float64 = 1e-2: Leakage suppression parameter.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Visualizations.QuantumObjectPlots.plot_state_populations-Tuple{NamedTrajectory}","page":"Library","title":"Piccolo.Visualizations.QuantumObjectPlots.plot_state_populations","text":"plot_state_populations(\n    traj::NamedTrajectory;\n    state_name::Symbol=:œàÃÉ,\n    state_indices::Union{Nothing, AbstractVector{Int}}=nothing,\n    control_name::Symbol=:u,\n    subspace::Union{Nothing, AbstractVector{Int}}=nothing,\n    kwargs...\n)\n\nPlot populations for multiple quantum states stored in a trajectory.\n\nThis function visualizes the time evolution of quantum state populations for trajectories containing multiple state trajectories (e.g., from sampling problems where multiple initial states are evolved). States are identified by a common prefix and numeric suffix pattern (e.g., :œàÃÉ1_system_1, :œàÃÉ2_system_1, etc.).\n\nMathematical Background\n\nFor a quantum state psi(t)rangle in mathcalH evolving under the Schr√∂dinger equation, the population in computational basis state irangle is given by\n\nP_i(t) = langle ipsi(t)rangle^2 = psi_i(t)^2\n\nwhere psi_i(t) is the i-th component of the state vector in the computational basis.\n\nFor a normalized state, we have the conservation property:\n\nsum_i=1^n P_i(t) = langlepsi(t)psi(t)rangle = 1\n\nWhen multiple states are being optimized simultaneously (as in sampling problems), this function plots the populations for each state, allowing comparison of how different initial conditions evolve under the same control protocol.\n\nKey Properties:\n\nPopulations are real and bounded: P_i(t) in 01\nTotal probability is conserved: sum_i P_i(t) = 1\nCan optionally restrict to a subspace (e.g., computational subspace excluding leakage states)\n\nArguments\n\ntraj::NamedTrajectory: A trajectory containing one or more quantum states in isomorphism representation.\n\nKeyword Arguments\n\nstate_name::Symbol: The base name for state components. The function will find all trajectory components matching this prefix (e.g., :œàÃÉ matches :œàÃÉ1_system_1, :œàÃÉ2_system_1, etc.). Default is :œàÃÉ.\nstate_indices::Union{Nothing, AbstractVector{Int}}: If provided, only plot states with these indices (e.g., [1, 3] plots only the 1st and 3rd states). If nothing, plots all states matching the prefix. Default is nothing.\ncontrol_name::Symbol: The name of the control signal component to include in the plot. Default is :u.\nsubspace::Union{Nothing, AbstractVector{Int}}: If provided, only plot populations for these basis states (e.g., 1:2 for a qubit subspace). Useful for excluding leakage levels. Default is nothing (plot all levels).\nkwargs...: Additional keyword arguments passed to NamedTrajectories.plot.\n\nReturns\n\nA Makie Figure object containing the population plots for all selected states.\n\nExample\n\nusing NamedTrajectories\nusing Piccolo\n\n# Example: Two initial states evolving under the same controls\nN = 100\nŒît = 0.1\n\n# Initial states\nœà1_init = ComplexF64[1, 0, 0]  # |0‚ü©\nœà2_init = ComplexF64[0, 1, 0]  # |1‚ü©\n\n# Create trajectory with multiple states\ntraj = NamedTrajectory(\n    (\n        œàÃÉ1_system_1 = hcat([ket_to_iso(œà1_init) for _ in 1:N]...),\n        œàÃÉ2_system_1 = hcat([ket_to_iso(œà2_init) for _ in 1:N]...),\n        u = randn(2, N),\n        Œît = fill(Œît, N),\n    );\n    controls = :u,\n    timestep = :Œît,\n)\n\n# Plot populations for all states\nplot_state_populations(traj)\n\n# Plot only computational subspace (excluding 3rd level)\nplot_state_populations(traj; subspace=1:2)\n\n# Plot only first state\nplot_state_populations(traj; state_indices=[1])\n\nSee also: plot_unitary_populations, NamedTrajectories.plot\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Visualizations.QuantumObjectPlots.plot_unitary_populations-Tuple{NamedTrajectory}","page":"Library","title":"Piccolo.Visualizations.QuantumObjectPlots.plot_unitary_populations","text":"plot_unitary_populations(\n    traj::NamedTrajectory;\n    unitary_columns::AbstractVector{Int}=1:2,\n    unitary_name::Symbol=:≈®‚Éó,\n    control_name::Symbol=:u,\n    kwargs...\n)\n\nPlot the state populations for specified columns of a unitary operator trajectory.\n\nThis function visualizes how the populations (squared magnitudes) of quantum states evolve over time for selected columns of a unitary matrix stored in a NamedTrajectory.\n\nMathematical Background\n\nFor a unitary operator U(t) in mathcalU(n) evolving under a time-dependent Hamiltonian, this function plots the populations\n\nP_ij(t) = U_ij(t)^2\n\nwhere U_ij(t) is the (ij)-th element of the unitary matrix at time t.\n\nFor a quantum system evolving according to the Schr√∂dinger equation\n\nfracddtU(t) = -iH(t)U(t) quad U(0) = I\n\neach column j of U(t) represents the time evolution of the initial basis state jrangle:\n\npsi_j(t)rangle = U(t)jrangle = sum_i=1^n U_ij(t)irangle\n\nThe population P_ij(t) = U_ij(t)^2 gives the probability of finding the system in state irangle at time t given that it started in state jrangle.\n\nKey Properties:\n\nUnitarity ensures sum_i=1^n P_ij(t) = 1 for all j and t (probability conservation)\nP_ij(0) = delta_ij (initially in definite state)\nPopulations are real and bounded: P_ij(t) in 01\n\nThe trajectory stores U(t) in isomorphism representation tildeU(t), a vectorized form that preserves the operator structure while enabling efficient optimization algorithms.\n\nArguments\n\ntraj::NamedTrajectory: A trajectory containing a unitary operator in isomorphism representation.\n\nKeyword Arguments\n\nunitary_columns::AbstractVector{Int}: Indices of unitary matrix columns to plot. Each column j corresponds to the evolution of basis state jrangle. Default is 1:2.\nunitary_name::Symbol: The name of the unitary operator component in the trajectory, stored as an isomorphism vector (tildeU). Default is :≈®‚Éó.\ncontrol_name::Symbol: The name of the control signal component to include in the plot, typically the time-dependent control parameters u(t) in H(t) = H_0 + sum_k u_k(t) H_k. Default is :u.\nkwargs...: Additional keyword arguments passed to NamedTrajectories.plot, such as xlims, ylims, or Makie-specific plotting options.\n\nReturns\n\nA Makie Figure object containing the population plots.\n\nExample\n\nusing NamedTrajectories\nusing Piccolo\nusing Piccolo\n\n# Define Hamiltonian: H = X + a‚ÇÅ(t)Z + a‚ÇÇ(t)Y\nH_drift = PAULIS[:X]\nH_drives = [PAULIS[:Z], PAULIS[:Y]]\n\n# Generate control trajectory\nN, T = 100, 10.0\ntimes = collect(range(0, T, length = N))\nu = 0.1 * randn(2, N)\n\n# Generate unitaries\nUs = exp.(-im * [(H_drift + sum(u[:, k] .* H_drives)) * times[k] for k = 1:N])\n\n# Create trajectory\ntraj = NamedTrajectory(\n    (\n        ≈®‚Éó = hcat(operator_to_iso_vec.(Us)...),\n        u = u,\n        Œît = fill(T / N, N),\n    );\n    controls = :u,\n    timestep = :Œît,\n)\n\n# Plot populations for first two columns\nplot_unitary_populations(traj)\n\n# Plot only the first column\nplot_unitary_populations(traj; unitary_columns=[1])\n\nSee also: NamedTrajectories.plot\n\n\n\n\n\n","category":"method"},{"location":"generated/robust_control/#robust-control-tutorial","page":"Robust Control","title":"Robust Control","text":"This tutorial shows how to design control pulses that are robust to parameter uncertainty using SamplingProblem.","category":"section"},{"location":"generated/robust_control/#The-Problem","page":"Robust Control","title":"The Problem","text":"Real quantum systems have parameter uncertainty:\n\nQubit frequencies drift over time\nFabrication variations between devices\nCalibration errors\n\nA pulse optimized for nominal parameters may perform poorly when parameters vary. SamplingProblem optimizes for multiple parameter values simultaneously.\n\nusing Piccolo\nusing CairoMakie\nusing Random\nRandom.seed!(456)","category":"section"},{"location":"generated/robust_control/#Setup:-Nominal-System","page":"Robust Control","title":"Setup: Nominal System","text":"# Nominal qubit frequency\nœâ_nominal = 0.5\n\nH_drift = œâ_nominal * PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\ndrive_bounds = [1.0, 1.0]\n\nsys_nominal = QuantumSystem(H_drift, H_drives, drive_bounds)\n\n# Time parameters\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\n\n# Target gate\nU_goal = GATES[:X]","category":"section"},{"location":"generated/robust_control/#Step-1:-Optimize-for-Nominal-Parameters-Only","page":"Robust Control","title":"Step 1: Optimize for Nominal Parameters Only","text":"pulse_nom = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj_nom = UnitaryTrajectory(sys_nominal, pulse_nom, U_goal)\n\nqcp_nom = SmoothPulseProblem(qtraj_nom, N; Q = 100.0, R = 1e-2)\ncached_solve!(qcp_nom, \"robust_nominal\"; max_iter = 20, verbose = false, print_level = 1)\n\nfidelity(qcp_nom)","category":"section"},{"location":"generated/robust_control/#Step-2:-Test-Robustness","page":"Robust Control","title":"Step 2: Test Robustness","text":"Let's see how this pulse performs with ¬±10% frequency variation:\n\nfunction evaluate_fidelity(qcp, œâ_test)\n    # Create test system with different frequency\n    H_test = œâ_test * PAULIS[:Z]\n    sys_test = QuantumSystem(H_test, H_drives, drive_bounds)\n\n    # Get optimized pulse\n    pulse_opt = get_pulse(qcp.qtraj)\n\n    # Create trajectory and evaluate\n    qtraj_test = UnitaryTrajectory(sys_test, pulse_opt, U_goal)\n    return fidelity(qtraj_test)\nend\n\n# Test across frequency range\nœâ_range = range(0.9 * œâ_nominal, 1.1 * œâ_nominal, length = 21)\nfidelities_nom = [evaluate_fidelity(qcp_nom, œâ) for œâ in œâ_range]\n\nextrema(fidelities_nom)","category":"section"},{"location":"generated/robust_control/#Step-3:-Robust-Optimization-with-SamplingProblem","page":"Robust Control","title":"Step 3: Robust Optimization with SamplingProblem","text":"Now let's optimize for multiple frequency values simultaneously.\n\n# Create perturbed systems (¬±5% and ¬±10%)\nœâ_samples = [0.9, 0.95, 1.0, 1.05, 1.1] .* œâ_nominal\nsystems = [QuantumSystem(œâ * PAULIS[:Z], H_drives, drive_bounds) for œâ in œâ_samples]\n\n# Optimize for all frequency samples\n\n# Start from the nominal solution\nqcp_robust = SamplingProblem(qcp_nom, systems; Q = 100.0)\ncached_solve!(\n    qcp_robust,\n    \"robust_sampling\";\n    max_iter = 20,\n    verbose = false,\n    print_level = 1,\n)\n\nfidelity(qcp_robust)","category":"section"},{"location":"generated/robust_control/#Step-4:-Compare-Performance","page":"Robust Control","title":"Step 4: Compare Performance","text":"# Evaluate robust pulse\nfidelities_robust = Float64[]\nfor œâ in œâ_range\n    H_test = œâ * PAULIS[:Z]\n    sys_test = QuantumSystem(H_test, H_drives, drive_bounds)\n    pulse_robust = get_pulse(qcp_robust.qtraj)\n    qtraj_test = UnitaryTrajectory(sys_test, pulse_robust, U_goal)\n    push!(fidelities_robust, fidelity(qtraj_test))\nend\n\nextrema(fidelities_robust)","category":"section"},{"location":"generated/robust_control/#Step-5:-Visualize-Comparison","page":"Robust Control","title":"Step 5: Visualize Comparison","text":"fig = Figure(size = (800, 400))\n\nax = Axis(\n    fig[1, 1],\n    xlabel = \"Frequency (œâ/œâ_nominal)\",\n    ylabel = \"Fidelity\",\n    title = \"Robustness Comparison\",\n)\n\nlines!(\n    ax,\n    œâ_range ./ œâ_nominal,\n    fidelities_nom,\n    label = \"Nominal-only\",\n    linewidth = 2,\n    color = :blue,\n)\nlines!(\n    ax,\n    œâ_range ./ œâ_nominal,\n    fidelities_robust,\n    label = \"Robust\",\n    linewidth = 2,\n    color = :red,\n)\n\nhlines!(ax, [0.99], linestyle = :dash, color = :gray, label = \"99% threshold\")\n\naxislegend(ax, position = :lb)\n\nfig","category":"section"},{"location":"generated/robust_control/#Step-6:-Combine-with-Time-Optimization","page":"Robust Control","title":"Step 6: Combine with Time Optimization","text":"We can chain SamplingProblem with MinimumTimeProblem for robust AND time-optimal pulses.\n\n# First, create base problem with free time\npulse_free = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj_free = UnitaryTrajectory(sys_nominal, pulse_free, U_goal)\n\nqcp_free = SmoothPulseProblem(\n    qtraj_free,\n    N;\n    Q = 100.0,\n    R = 1e-2,\n    Œît_bounds = (0.05, 0.3),  # Enable variable timesteps\n)\ncached_solve!(qcp_free, \"robust_free_time\"; max_iter = 15, verbose = false, print_level = 1)\n\n# Add robustness\nqcp_robust_free = SamplingProblem(qcp_free, systems; Q = 100.0)\ncached_solve!(\n    qcp_robust_free,\n    \"robust_free_sampling\";\n    max_iter = 15,\n    verbose = false,\n    print_level = 1,\n)\n\n# Minimize time while maintaining fidelity\nqcp_fast_robust = MinimumTimeProblem(qcp_robust_free; final_fidelity = 0.95, D = 100.0)\ncached_solve!(\n    qcp_fast_robust,\n    \"robust_fast_mintime\";\n    max_iter = 15,\n    verbose = false,\n    print_level = 1,\n)\n\n# Compare durations\nduration_initial = sum(get_timesteps(get_trajectory(qcp_free)))\nduration_robust = sum(get_timesteps(get_trajectory(qcp_robust_free)))\nduration_fast = sum(get_timesteps(get_trajectory(qcp_fast_robust)))\n\nduration_initial, duration_robust, duration_fast","category":"section"},{"location":"generated/robust_control/#Weighted-Sampling","page":"Robust Control","title":"Weighted Sampling","text":"You can weight some parameter values more heavily:\n\n# More weight on nominal, less on extremes\nweights = [0.5, 1.0, 2.0, 1.0, 0.5]  # Emphasize nominal\n\nqcp_weighted = SamplingProblem(qcp_nom, systems; weights = weights, Q = 100.0)\ncached_solve!(\n    qcp_weighted,\n    \"robust_weighted\";\n    max_iter = 15,\n    verbose = false,\n    print_level = 1,\n)\n\n# Evaluate\nfidelities_weighted = Float64[]\nfor œâ in œâ_range\n    H_test = œâ * PAULIS[:Z]\n    sys_test = QuantumSystem(H_test, H_drives, drive_bounds)\n    pulse_w = get_pulse(qcp_weighted.qtraj)\n    qtraj_test = UnitaryTrajectory(sys_test, pulse_w, U_goal)\n    push!(fidelities_weighted, fidelity(qtraj_test))\nend\n\nextrema(fidelities_weighted)","category":"section"},{"location":"generated/robust_control/#Best-Practices","page":"Robust Control","title":"Best Practices","text":"Start with nominal optimization - Get a working solution first\nSample key parameters - Focus on parameters with most uncertainty\nUse 3-5 samples initially - More samples = slower optimization\nVerify with dense evaluation - Test on more points than you optimized for\nBalance robustness and performance - More robust often means longer gates","category":"section"},{"location":"generated/robust_control/#Next-Steps","page":"Robust Control","title":"Next Steps","text":"Problem Templates: Full SamplingProblem documentation\nMinimumTimeProblem: Time optimization details\nComposing Templates: Advanced composition patterns\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/guides/leakage_suppression/#leakage-suppression","page":"Leakage Suppression","title":"Leakage Suppression","text":"When working with multilevel quantum systems (like transmons), population can \"leak\" from the computational subspace to higher energy levels. This guide shows how to suppress leakage in Piccolo.jl.","category":"section"},{"location":"generated/guides/leakage_suppression/#The-Problem","page":"Leakage Suppression","title":"The Problem","text":"Consider a 3-level transmon where we want to implement gates only on the |0‚ü© and |1‚ü© states. During optimization, population might temporarily occupy |2‚ü©, which can:\n\nReduce gate fidelity\nCause errors in subsequent operations\nLead to non-unitary dynamics if |2‚ü© decays","category":"section"},{"location":"generated/guides/leakage_suppression/#EmbeddedOperator","page":"Leakage Suppression","title":"EmbeddedOperator","text":"The key tool for handling subspace gates is EmbeddedOperator. It creates a full unitary that acts as the specified gate on the computational subspace and as identity on leakage levels.\n\nFor a 3-level system with 2-level computational subspace:\n\nU_textembedded = beginpmatrix U_textgate  0  0  I endpmatrix","category":"section"},{"location":"generated/guides/leakage_suppression/#Basic-Usage","page":"Leakage Suppression","title":"Basic Usage","text":"using Piccolo\nusing Random\nRandom.seed!(42)\n\n# Create a 3-level transmon\nsys = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.4, 0.4])\n\n# Define X gate in computational subspace\nU_goal = EmbeddedOperator(:X, sys)\n\nsize(U_goal.operator)\n\nU_goal.subspace","category":"section"},{"location":"generated/guides/leakage_suppression/#Construction-Options","page":"Leakage Suppression","title":"Construction Options","text":"# From symbol (gate name)\nU_X = EmbeddedOperator(:X, sys)\nU_H = EmbeddedOperator(:H, sys)\n\n# From matrix\ncustom_gate = ComplexF64[1 0; 0 exp(im * œÄ / 4)]  # T gate\nU_T = EmbeddedOperator(custom_gate, sys)","category":"section"},{"location":"generated/guides/leakage_suppression/#Accessing-Subspace-Information","page":"Leakage Suppression","title":"Accessing Subspace Information","text":"# Computational subspace indices\nU_goal.subspace\n\n# Leakage indices in isomorphic vector space\nleak_indices = get_iso_vec_leakage_indices(U_goal)\nleak_indices","category":"section"},{"location":"generated/guides/leakage_suppression/#Leakage-via-PiccoloOptions","page":"Leakage Suppression","title":"Leakage via PiccoloOptions","text":"The easiest way to add leakage handling is through PiccoloOptions.","category":"section"},{"location":"generated/guides/leakage_suppression/#Add-Leakage-Objective","page":"Leakage Suppression","title":"Add Leakage Objective","text":"Penalize population in leakage states with a soft cost:\n\nopts_cost = PiccoloOptions(\n    leakage_cost = 10.0,  # Weight on leakage penalty\n    verbose = false,\n)","category":"section"},{"location":"generated/guides/leakage_suppression/#Add-Leakage-Constraint","page":"Leakage Suppression","title":"Add Leakage Constraint","text":"Enforce a hard bound on leakage:\n\nopts_constraint = PiccoloOptions(\n    leakage_constraint = true,\n    leakage_constraint_value = 1e-3,  # Max 0.1% leakage\n    verbose = false,\n)","category":"section"},{"location":"generated/guides/leakage_suppression/#Both-Together","page":"Leakage Suppression","title":"Both Together","text":"opts = PiccoloOptions(\n    leakage_cost = 10.0,\n    leakage_constraint = true,\n    leakage_constraint_value = 1e-3,\n    verbose = false,\n)","category":"section"},{"location":"generated/guides/leakage_suppression/#Complete-Example:-X-Gate-on-3-Level-Transmon","page":"Leakage Suppression","title":"Complete Example: X Gate on 3-Level Transmon","text":"# 1. Create multilevel system\nsys = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.4, 0.4])\n\n# 2. Define embedded gate\nU_goal = EmbeddedOperator(:X, sys)\n\n# 3. Create trajectory\nT, N = 20.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.05 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# 4. Configure leakage suppression\nopts = PiccoloOptions(\n    leakage_cost = 5.0,\n    leakage_constraint = true,\n    leakage_constraint_value = 1e-3,\n    verbose = false,\n)\n\n# 5. Solve\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0, piccolo_options = opts)\ncached_solve!(\n    qcp,\n    \"leakage_suppression_2\";\n    max_iter = 150,\n    verbose = false,\n    print_level = 1,\n)\n\nfidelity(qcp)","category":"section"},{"location":"generated/guides/leakage_suppression/#Manual-Leakage-Objectives-and-Constraints","page":"Leakage Suppression","title":"Manual Leakage Objectives and Constraints","text":"For more control, add leakage handling manually using LeakageObjective and LeakageConstraint. Both take the leakage indices in the isomorphic vector space:\n\ntraj = get_trajectory(qcp)\nleak_indices = get_iso_vec_leakage_indices(U_goal)\n\n# Leakage objective (soft penalty)\nleak_obj = LeakageObjective(leak_indices, :≈®‚Éó, traj; Qs = fill(10.0, N))\n\n# Leakage constraint (hard bound)\nleak_constraint = LeakageConstraint(1e-3, leak_indices, :≈®‚Éó, traj)","category":"section"},{"location":"generated/guides/leakage_suppression/#Strategies-for-Difficult-Problems","page":"Leakage Suppression","title":"Strategies for Difficult Problems","text":"","category":"section"},{"location":"generated/guides/leakage_suppression/#1.-Start-Without-Leakage-Constraints","page":"Leakage Suppression","title":"1. Start Without Leakage Constraints","text":"Get a working solution first, then add constraints:\n\n# Step 1: Optimize without leakage constraints\nqtraj2 = UnitaryTrajectory(sys, pulse, U_goal)\nqcp_initial = SmoothPulseProblem(qtraj2, N; Q = 100.0)\ncached_solve!(\n    qcp_initial,\n    \"leakage_initial_2\";\n    max_iter = 100,\n    verbose = false,\n    print_level = 1,\n)\n\n# Step 2: Add leakage suppression\nopts = PiccoloOptions(\n    leakage_cost = 5.0,\n    leakage_constraint = true,\n    leakage_constraint_value = 1e-3,\n    verbose = false,\n)\nqcp_leakage = SmoothPulseProblem(qtraj2, N; Q = 100.0, piccolo_options = opts)\ncached_solve!(\n    qcp_leakage,\n    \"leakage_with_suppression_2\";\n    max_iter = 150,\n    verbose = false,\n    print_level = 1,\n)\n\nfidelity(qcp_initial)\n\nfidelity(qcp_leakage)","category":"section"},{"location":"generated/guides/leakage_suppression/#2.-Increase-Gate-Time","page":"Leakage Suppression","title":"2. Increase Gate Time","text":"Faster gates often have more leakage. Try a longer gate time if leakage is high.","category":"section"},{"location":"generated/guides/leakage_suppression/#3.-Use-More-Levels","page":"Leakage Suppression","title":"3. Use More Levels","text":"Include more levels to capture dynamics accurately:\n\nsys_4level = TransmonSystem(levels = 4, Œ¥ = 0.2, drive_bounds = [0.2, 0.2])","category":"section"},{"location":"generated/guides/leakage_suppression/#4.-Reduce-Drive-Amplitude","page":"Leakage Suppression","title":"4. Reduce Drive Amplitude","text":"Lower drives can reduce leakage:\n\nsys_low_drive = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.1, 0.1])","category":"section"},{"location":"generated/guides/leakage_suppression/#Analyzing-Leakage","page":"Leakage Suppression","title":"Analyzing Leakage","text":"After solving, visualize the state evolution including leakage levels:\n\nusing CairoMakie\n\ntraj = get_trajectory(qcp)\nfig = plot_unitary_populations(traj)","category":"section"},{"location":"generated/guides/leakage_suppression/#See-Also","page":"Leakage Suppression","title":"See Also","text":"Operators - EmbeddedOperator details\nQuantum Systems - Creating multilevel systems\nObjectives - LeakageObjective documentation\nConstraints - LeakageConstraint documentation\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"guides/#guides-overview","page":"Overview","title":"How-To Guides","text":"This section contains task-oriented guides for specific problems in quantum optimal control.","category":"section"},{"location":"guides/#Available-Guides","page":"Overview","title":"Available Guides","text":"Guide Description\nLeakage Suppression Controlling population leakage in multilevel systems\nGlobal Variables Optimizing system parameters alongside controls\nVisualization Plotting trajectories and analyzing results\nCustom Objectives Creating custom optimization objectives","category":"section"},{"location":"guides/#Guide-Format","page":"Overview","title":"Guide Format","text":"Each guide follows a consistent format:\n\nProblem statement: What are we trying to accomplish?\nPrerequisites: What you need to know first\nStep-by-step solution: How to solve the problem\nComplete example: Full working code\nVariations: Common modifications","category":"section"},{"location":"guides/#Quick-Links-by-Task","page":"Overview","title":"Quick Links by Task","text":"","category":"section"},{"location":"guides/#Handling-Multilevel-Systems","page":"Overview","title":"Handling Multilevel Systems","text":"Defining gates in subspaces with EmbeddedOperator\nAdding leakage penalties and constraints","category":"section"},{"location":"guides/#Advanced-Optimization","page":"Overview","title":"Advanced Optimization","text":"Optimizing system parameters\nCreating custom fidelity measures","category":"section"},{"location":"guides/#Analysis-and-Visualization","page":"Overview","title":"Analysis and Visualization","text":"Plotting control pulses\nVisualizing state populations\nCreating animations","category":"section"},{"location":"guides/#See-Also","page":"Overview","title":"See Also","text":"Quantum Systems - Platform-specific system templates\nProblem Templates - Main optimization API\nConcepts - Detailed type documentation\nTutorials - Step-by-step learning examples","category":"section"},{"location":"generated/systems/cat_qubits/#cat-qubit-systems","page":"Cat Qubits","title":"Cat Qubits","text":"Cat qubits encode quantum information in superpositions of coherent states of a bosonic (cavity) mode, stabilized by engineered dissipation.  Because bit flips are exponentially suppressed in the coherent state amplitude alpha^2, cat qubits are a promising route to hardware-efficient quantum error correction.\n\nPiccolo's CatSystem models a two-mode cat qubit (cat cavity + buffer mode) as an OpenQuantumSystem with Lindblad dissipation.","category":"section"},{"location":"generated/systems/cat_qubits/#Hamiltonian","page":"Cat Qubits","title":"Hamiltonian","text":"The drift Hamiltonian includes self-Kerr, cross-Kerr, and two-photon exchange:\n\nH = -fracchi_aa2 a^dagger 2 a^2\n    - fracchi_bb2 b^dagger 2 b^2\n    - chi_ab a^dagger a b^dagger b\n    + g_2 a^dagger 2 b\n    + g_2^* a^2 b^dagger\n\nwhere a (b) annihilates a cat (buffer) photon, chi_aa chi_bb are self-Kerr nonlinearities, chi_ab is the cross-Kerr, and g_2 is the two-photon exchange coupling that stabilizes the cat manifold alpharangle -alpharangle.\n\nThe two drives are:\n\nBuffer displacement: b + b^dagger\nKerr correction: a^dagger a","category":"section"},{"location":"generated/systems/cat_qubits/#Dissipation","page":"Cat Qubits","title":"Dissipation","text":"Lindblad jump operators model photon loss in both modes:\n\nL_a = sqrtkappa_a a qquad L_b = sqrtkappa_b b\n\nThe buffer decay rate kappa_b is typically much larger than the cat decay rate kappa_a, ensuring the buffer mode is rapidly reset.  The full dynamics follow the Lindblad master equation:\n\ndotrho = -iH rho + sum_k in ab left(\n    L_k rho L_k^dagger - tfrac12L_k^dagger L_k rho\nright)\n\nThis returns an OpenQuantumSystem, which is used with DensityTrajectory for optimization.","category":"section"},{"location":"generated/systems/cat_qubits/#Construction","page":"Cat Qubits","title":"Construction","text":"using Piccolo\n\nsys_cat = CatSystem(\n    cat_levels = 13,       # Cat mode Fock space truncation\n    buffer_levels = 3,     # Buffer mode Fock space truncation\n    g2 = 0.36,             # Two-photon exchange (MHz¬∑2œÄ)\n    œá_aa = -7e-3,          # Cat self-Kerr (MHz¬∑2œÄ)\n    œá_bb = -32.0,          # Buffer self-Kerr (MHz¬∑2œÄ)\n    œá_ab = 0.79,           # Cross-Kerr (MHz¬∑2œÄ)\n    Œ∫a = 53e-3,            # Cat decay rate (MHz¬∑2œÄ)\n    Œ∫b = 13.0,             # Buffer decay rate (MHz¬∑2œÄ)\n    drive_bounds = [1.0, 1.0],\n)\nsys_cat.levels, sys_cat.n_drives\n\nThe Hilbert space dimension is cat_levels √ó buffer_levels.","category":"section"},{"location":"generated/systems/cat_qubits/#Parameters","page":"Cat Qubits","title":"Parameters","text":"Parameter Default Description\ncat_levels 13 Cat mode Fock space truncation\nbuffer_levels 3 Buffer mode Fock space truncation\ng2 0.36 Two-photon exchange (MHz¬∑2pi)\nœá_aa -7e-3 Cat self-Kerr (MHz¬∑2pi)\nœá_bb -32 Buffer self-Kerr (MHz¬∑2pi)\nœá_ab 0.79 Cross-Kerr (MHz¬∑2pi)\nŒ∫a 53e-3 Cat photon loss rate (MHz¬∑2pi)\nŒ∫b 13 Buffer photon loss rate (MHz¬∑2pi)\nprefactor 1 Global scaling of all couplings and rates","category":"section"},{"location":"generated/systems/cat_qubits/#Helper-Functions","page":"Cat Qubits","title":"Helper Functions","text":"","category":"section"},{"location":"generated/systems/cat_qubits/#Coherent-States","page":"Cat Qubits","title":"Coherent States","text":"# Coherent state |Œ±‚ü© in the Fock basis\nŒ± = 2.0\nœà_coherent = coherent_ket(Œ±, 13)\nlength(œà_coherent)\n\nThe coherent state alpharangle = e^-alpha^22 sum_n=0^d-1 fracalpha^nsqrtn nrangle is the starting point for cat state preparation.","category":"section"},{"location":"generated/systems/cat_qubits/#Steady-State-Controls","page":"Cat Qubits","title":"Steady-State Controls","text":"# Controls that maintain |Œ±‚ü© in the cat mode\nN_steps = 100\nu_steady = get_cat_controls(sys_cat, Œ±, N_steps)\nu_steady[:, 1]\n\nget_cat_controls(sys, Œ±, N) returns the buffer drive and Kerr correction that balance the Hamiltonian at coherent amplitude alpha, reading the coupling constants from sys.global_params:\n\nBuffer drive: g_2 alpha^2\nKerr correction: chi_aa(2alpha^2 + 1)","category":"section"},{"location":"generated/systems/cat_qubits/#Example:-Density-Matrix-Optimization","page":"Cat Qubits","title":"Example: Density Matrix Optimization","text":"using LinearAlgebra\n\n# Small system for demonstration\ncat_levels, buffer_levels = 3, 2\nsys = CatSystem(cat_levels = cat_levels, buffer_levels = buffer_levels)\nn = sys.levels\n\n# Initial state: vacuum |0‚ü© ‚äó |0‚ü©\nœÅ0 = zeros(ComplexF64, n, n)\nœÅ0[1, 1] = 1.0\n\n# Goal: coherent state |Œ±‚ü© ‚äó |0‚ü©\nŒ± = 0.5\nœà_cat = coherent_ket(Œ±, cat_levels)\nœà_buf = ComplexF64[1, 0]\nœà_goal = kron(œà_cat, œà_buf)\nœÅg = œà_goal * œà_goal'\n\nT, N_steps = 1.0, 11\ntimes = collect(range(0, T, length = N_steps))\n\n# Initialize with steady-state controls + small perturbation\nu_init = get_cat_controls(sys, Œ±, N_steps) + 0.01 * randn(2, N_steps)\npulse = ZeroOrderPulse(u_init, times)\n\n# DensityTrajectory for open system optimization\nqtraj = DensityTrajectory(sys, pulse, œÅ0, œÅg)\n\nqcp = SmoothPulseProblem(qtraj, N_steps; Q = 100.0, R = 1e-2)\ncached_solve!(qcp, \"systems_cat_density\"; max_iter = 50, print_level = 1)\nfidelity(qcp)","category":"section"},{"location":"generated/systems/cat_qubits/#Compact-Representation","page":"Cat Qubits","title":"Compact Representation","text":"Because rho is Hermitian, DensityTrajectory uses the compact isomorphism internally: a real vector of dimension d^2 instead of 2d^2.  The compact Lindbladian generators mathcalG_c = PmathcalGL are d^2 times d^2 (instead of 2d^2 times 2d^2), giving roughly a 4times speedup. See Isomorphisms for details.","category":"section"},{"location":"generated/systems/cat_qubits/#Typical-Parameters","page":"Cat Qubits","title":"Typical Parameters","text":"Parameter Typical Value Unit\ng_2  2pi 0.1‚Äì1.0 MHz\nchi_aa  2pi 1‚Äì10 kHz\nchi_bb  2pi 10‚Äì50 MHz\nchi_ab  2pi 0.5‚Äì2.0 MHz\nkappa_a  2pi 10‚Äì100 kHz\nkappa_b  2pi 5‚Äì20 MHz\nCoherent amplitude alpha \nCat levels 10‚Äì20 ‚Äî\nBuffer levels 2‚Äì4 ‚Äî","category":"section"},{"location":"generated/systems/cat_qubits/#Best-Practices","page":"Cat Qubits","title":"Best Practices","text":"","category":"section"},{"location":"generated/systems/cat_qubits/#1.-Initialize-with-Steady-State-Controls","page":"Cat Qubits","title":"1. Initialize with Steady-State Controls","text":"Use get_cat_controls to warm-start the optimization.  Adding small random perturbations helps the optimizer escape local minima.","category":"section"},{"location":"generated/systems/cat_qubits/#2.-Truncate-Carefully","page":"Cat Qubits","title":"2. Truncate Carefully","text":"The cat mode Fock space must be large enough to support the coherent state: n_max gtrsim 2alpha^2 + 5.  For alpha = 2, use at least n_max = 13.","category":"section"},{"location":"generated/systems/cat_qubits/#3.-Use-DensityTrajectory","page":"Cat Qubits","title":"3. Use DensityTrajectory","text":"Since CatSystem returns an OpenQuantumSystem, it must be used with DensityTrajectory (not UnitaryTrajectory).  The fidelity is F = operatornametr(rho_textgoal rho(T)).","category":"section"},{"location":"generated/systems/cat_qubits/#References","page":"Cat Qubits","title":"References","text":"Mirrahimi et al., \"Dynamically protected cat-qubits: a new paradigm for universal quantum computation,\" New J. Phys. 16, 045014 (2014)\nGrimm et al., \"Stabilization and operation of a Kerr-cat qubit,\" Nature 584, 205 (2020)\nLescanne et al., \"Exponential suppression of bit-flips in a qubit encoded in an oscillator,\" Nature Phys. 16, 509 (2020)","category":"section"},{"location":"generated/systems/cat_qubits/#See-Also","page":"Cat Qubits","title":"See Also","text":"Quantum Systems Overview ‚Äî General system API\nIsomorphisms ‚Äî Compact density representation\nTrajectories ‚Äî DensityTrajectory for open systems\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/guides/visualization/#visualization","page":"Visualization","title":"Visualization","text":"Piccolo.jl provides visualization tools for analyzing optimization results. This guide covers plotting controls, states, and populations.","category":"section"},{"location":"generated/guides/visualization/#Setup","page":"Visualization","title":"Setup","text":"Visualization requires a Makie backend. We'll create a solved problem to work with:\n\nusing Piccolo\nusing CairoMakie\nusing Random\nRandom.seed!(42)\n\n# Create and solve a simple qubit gate problem\nH_drift = 0.5 * PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\nT = 10.0\nN = 100\ntimes = collect(range(0, T, length = N))\ninitial_controls = 0.1 * randn(2, N)\npulse = ZeroOrderPulse(initial_controls, times)\nqtraj = UnitaryTrajectory(sys, pulse, GATES[:X])\n\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0, R = 1e-2, ddu_bound = 1.0)\ncached_solve!(qcp, \"visualization_unitary\"; max_iter = 50, verbose = false, print_level = 1)\n\nfidelity(qcp)","category":"section"},{"location":"generated/guides/visualization/#Basic-Trajectory-Plotting","page":"Visualization","title":"Basic Trajectory Plotting","text":"The plot function from NamedTrajectories.jl plots trajectory components.","category":"section"},{"location":"generated/guides/visualization/#Plot-Controls","page":"Visualization","title":"Plot Controls","text":"traj = get_trajectory(qcp)\nfig = plot(traj, [:u])","category":"section"},{"location":"generated/guides/visualization/#Plot-Controls-and-Derivatives","page":"Visualization","title":"Plot Controls and Derivatives","text":"fig = plot(traj, [:u, :du, :ddu])","category":"section"},{"location":"generated/guides/visualization/#Quantum-Specific-Plots","page":"Visualization","title":"Quantum-Specific Plots","text":"","category":"section"},{"location":"generated/guides/visualization/#Unitary-Populations","page":"Visualization","title":"Unitary Populations","text":"For UnitaryTrajectory, visualize how state populations evolve during the gate:\n\nfig = plot_unitary_populations(traj)","category":"section"},{"location":"generated/guides/visualization/#Ket-State-Populations","page":"Visualization","title":"Ket State Populations","text":"For KetTrajectory, use plot_state_populations:\n\nœà_init = ComplexF64[1.0, 0.0]\nœà_goal = ComplexF64[0.0, 1.0]\n\npulse_ket = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj_ket = KetTrajectory(sys, pulse_ket, œà_init, œà_goal)\nqcp_ket = SmoothPulseProblem(qtraj_ket, N; Q = 100.0, R = 1e-2, ddu_bound = 1.0)\ncached_solve!(qcp_ket, \"visualization_ket\"; max_iter = 50, verbose = false, print_level = 1)\n\ntraj_ket = get_trajectory(qcp_ket)\nfig = plot_state_populations(traj_ket)","category":"section"},{"location":"generated/guides/visualization/#Custom-Plotting","page":"Visualization","title":"Custom Plotting","text":"For full control, extract trajectory data and use Makie directly.","category":"section"},{"location":"generated/guides/visualization/#Manual-Control-Plots","page":"Visualization","title":"Manual Control Plots","text":"plot_times = cumsum([0; get_timesteps(traj)])[1:(end-1)]\n\nfig = Figure(size = (800, 400))\nax = Axis(fig[1, 1], xlabel = \"Time\", ylabel = \"Control Amplitude\")\n\nfor i = 1:size(traj[:u], 1)\n    lines!(ax, plot_times, traj[:u][i, :], label = \"Drive $i\", linewidth = 2)\nend\n\naxislegend(ax, position = :rt)\nfig","category":"section"},{"location":"generated/guides/visualization/#Subplot-Layouts","page":"Visualization","title":"Subplot Layouts","text":"fig = Figure(size = (1000, 500))\n\n# Controls\nax1 = Axis(fig[1, 1], xlabel = \"Time\", ylabel = \"Amplitude\", title = \"Controls\")\nlines!(ax1, plot_times, traj[:u][1, :], label = \"u_x\", linewidth = 2)\nlines!(ax1, plot_times, traj[:u][2, :], label = \"u_y\", linewidth = 2)\naxislegend(ax1, position = :rt)\n\n# Derivatives\nax2 = Axis(fig[1, 2], xlabel = \"Time\", ylabel = \"Derivative\", title = \"Control Derivatives\")\nlines!(ax2, plot_times, traj[:du][1, :], label = \"du_x\", linewidth = 2)\nlines!(ax2, plot_times, traj[:du][2, :], label = \"du_y\", linewidth = 2)\naxislegend(ax2, position = :rt)\n\nfig","category":"section"},{"location":"generated/guides/visualization/#Phase-Space-Plot","page":"Visualization","title":"Phase Space Plot","text":"fig = Figure(size = (500, 500))\nax = Axis(fig[1, 1], xlabel = \"u_x\", ylabel = \"u_y\", title = \"Control Phase Space\")\nlines!(ax, traj[:u][1, :], traj[:u][2, :], linewidth = 2)\nscatter!(\n    ax,\n    [traj[:u][1, 1]],\n    [traj[:u][2, 1]],\n    color = :green,\n    markersize = 15,\n    label = \"Start\",\n)\nscatter!(\n    ax,\n    [traj[:u][1, end]],\n    [traj[:u][2, end]],\n    color = :red,\n    markersize = 15,\n    label = \"End\",\n)\naxislegend(ax, position = :rt)\nfig","category":"section"},{"location":"generated/guides/visualization/#Fidelity-Evolution","page":"Visualization","title":"Fidelity Evolution","text":"Track fidelity during the pulse:\n\nusing LinearAlgebra\n\nU_goal = GATES[:X]\nfidelities = Float64[]\nfor k = 1:size(traj[:≈®‚Éó], 2)\n    U_k = iso_vec_to_operator(traj[:≈®‚Éó][:, k])\n    F_k = abs(tr(U_goal' * U_k))^2 / sys.levels^2\n    push!(fidelities, F_k)\nend\n\nfig = Figure(size = (800, 300))\nax = Axis(fig[1, 1], xlabel = \"Timestep\", ylabel = \"Fidelity\")\nlines!(ax, 1:length(fidelities), fidelities, linewidth = 2)\nhlines!(ax, [0.99], color = :red, linestyle = :dash, label = \"99% target\")\naxislegend(ax, position = :rb)\nfig","category":"section"},{"location":"generated/guides/visualization/#Comparing-Solutions","page":"Visualization","title":"Comparing Solutions","text":"Compare solutions with different regularization weights:\n\nfig = Figure(size = (800, 400))\nax = Axis(fig[1, 1], xlabel = \"Time\", ylabel = \"u_x\", title = \"Effect of Regularization\")\n\nfor (R, label) in [(1e-3, \"R=1e-3\"), (1e-2, \"R=1e-2\"), (1e-1, \"R=1e-1\")]\n    pulse_r = ZeroOrderPulse(0.1 * randn(2, N), times)\n    qtraj_r = UnitaryTrajectory(sys, pulse_r, GATES[:X])\n    qcp_r = SmoothPulseProblem(qtraj_r, N; Q = 100.0, R = R, ddu_bound = 1.0)\n    cached_solve!(\n        qcp_r,\n        \"visualization_R_$(R)\";\n        max_iter = 50,\n        verbose = false,\n        print_level = 1,\n    )\n    traj_r = get_trajectory(qcp_r)\n    t_r = cumsum([0; get_timesteps(traj_r)])[1:(end-1)]\n    lines!(ax, t_r, traj_r[:u][1, :], label = label, linewidth = 2)\nend\n\naxislegend(ax, position = :rt)\nfig","category":"section"},{"location":"generated/guides/visualization/#Saving-Figures","page":"Visualization","title":"Saving Figures","text":"# PNG (raster)\n# save(\"controls.png\", fig)\n\n# PDF (vector graphics)\n# save(\"controls.pdf\", fig)\n\n# SVG (vector graphics)\n# save(\"controls.svg\", fig)","category":"section"},{"location":"generated/guides/visualization/#Plotting-Tips","page":"Visualization","title":"Plotting Tips","text":"","category":"section"},{"location":"generated/guides/visualization/#1.-Use-Appropriate-Resolution","page":"Visualization","title":"1. Use Appropriate Resolution","text":"For publications, use high-res settings:\n\nfig_hires = Figure(size = (1200, 800), fontsize = 14)","category":"section"},{"location":"generated/guides/visualization/#2.-Use-Consistent-Colors","page":"Visualization","title":"2. Use Consistent Colors","text":"colors = Makie.wong_colors()","category":"section"},{"location":"generated/guides/visualization/#3.-Show-Drive-Bounds","page":"Visualization","title":"3. Show Drive Bounds","text":"bound = 1.0\nfig = Figure(size = (800, 300))\nax = Axis(fig[1, 1], xlabel = \"Time\", ylabel = \"Amplitude\")\nband!(\n    ax,\n    plot_times,\n    -bound * ones(length(plot_times)),\n    bound * ones(length(plot_times)),\n    color = (:gray, 0.2),\n    label = \"Bounds\",\n)\nlines!(ax, plot_times, traj[:u][1, :], label = \"u_x\", linewidth = 2)\naxislegend(ax, position = :rt)\nfig","category":"section"},{"location":"generated/guides/visualization/#See-Also","page":"Visualization","title":"See Also","text":"Visualizations API - Complete API reference\nProblem Templates - Generating solutions to plot\nTrajectories - Understanding trajectory structure\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/problem-templates/spline_pulse/#spline-pulse","page":"SplinePulseProblem","title":"SplinePulseProblem","text":"SplinePulseProblem sets up trajectory optimization with spline-based pulses where derivative variables represent spline slopes or tangents. This is ideal for inherently smooth control pulses and warm-starting from previous solutions.","category":"section"},{"location":"generated/problem-templates/spline_pulse/#When-to-Use","page":"SplinePulseProblem","title":"When to Use","text":"Use SplinePulseProblem when:\n\nYou need inherently smooth control pulses\nYou're warm-starting from a previously optimized solution\nYou want cubic spline smoothness without derivative regularization\nYou're working with hardware that expects smooth pulse shapes","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Pulse-Requirements","page":"SplinePulseProblem","title":"Pulse Requirements","text":"SplinePulseProblem works with spline pulse types:\n\nPulse Type Derivative Meaning\nLinearSplinePulse :du represents constrained slope between knots\nCubicSplinePulse :du represents independent Hermite tangents\n\n# Linear spline\npulse = LinearSplinePulse(controls, times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SplinePulseProblem(qtraj)  # Works\n\n# Cubic spline\npulse = CubicSplinePulse(controls, tangents, times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SplinePulseProblem(qtraj)  # Works","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Constructor-Variants","page":"SplinePulseProblem","title":"Constructor Variants","text":"","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Use-Native-Knot-Times-(Recommended-for-Warm-Starting)","page":"SplinePulseProblem","title":"Use Native Knot Times (Recommended for Warm-Starting)","text":"SplinePulseProblem(qtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}; kwargs...)\n\nUses the pulse's native knot times without resampling. Best for warm-starting from a previous solution.","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Resample-to-N-Timesteps","page":"SplinePulseProblem","title":"Resample to N Timesteps","text":"SplinePulseProblem(qtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}, N::Int; kwargs...)\n\nResamples the pulse to N uniformly spaced timesteps.","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Use-Specific-Times","page":"SplinePulseProblem","title":"Use Specific Times","text":"SplinePulseProblem(qtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}, times::AbstractVector; kwargs...)\n\nResamples the pulse to the specified time points.","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Parameter-Reference","page":"SplinePulseProblem","title":"Parameter Reference","text":"","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Objective-Weights","page":"SplinePulseProblem","title":"Objective Weights","text":"Parameter Type Default Description\nQ Float64 100.0 Weight on infidelity objective\nR Float64 1e-2 Base regularization weight\nR_u Float64 or Vector{Float64} R Regularization on control values\nR_du Float64 or Vector{Float64} R Regularization on derivatives/tangents","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Bounds","page":"SplinePulseProblem","title":"Bounds","text":"Parameter Type Default Description\ndu_bound Float64 Inf Maximum derivative/slope bound\nŒît_bounds Tuple{Float64, Float64} nothing Time-step bounds for free-time optimization","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Advanced-Options","page":"SplinePulseProblem","title":"Advanced Options","text":"Parameter Type Default Description\nintegrator AbstractIntegrator nothing Custom integrator (uses BilinearIntegrator if nothing)\nglobal_names Vector{Symbol} nothing Global parameters to optimize\nglobal_bounds Dict{Symbol, ...} nothing Bounds on global variables\nconstraints Vector{AbstractConstraint} [] Additional constraints\npiccolo_options PiccoloOptions PiccoloOptions() Solver options","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Examples","page":"SplinePulseProblem","title":"Examples","text":"","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Basic-Spline-Optimization","page":"SplinePulseProblem","title":"Basic Spline Optimization","text":"using Piccolo\n\n# Define system\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n# Create cubic spline pulse\nT, N = 10.0, 50\ntimes = collect(range(0, T, length = N))\ncontrols = 0.1 * randn(2, N)\ntangents = zeros(2, N)  ## Initial tangents\npulse = CubicSplinePulse(controls, tangents, times)\n\nqtraj = UnitaryTrajectory(sys, pulse, GATES[:X])\n\n# Solve using native knot times\nqcp = SplinePulseProblem(qtraj; Q = 100.0, du_bound = 10.0)\ncached_solve!(qcp, \"spline_pulse_basic\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Warm-Starting-from-Previous-Solution","page":"SplinePulseProblem","title":"Warm-Starting from Previous Solution","text":"# Load previously optimized pulse\nusing JLD2\n@load \"optimized_pulse.jld2\" saved_pulse\n\n# Create new trajectory with saved pulse\nqtraj = UnitaryTrajectory(sys, saved_pulse, U_goal)\n\n# Use native knot times (no resampling)\nqcp = SplinePulseProblem(qtraj)\nsolve!(qcp; max_iter=50)  # Converges quickly from good initial guess","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Resampling-to-Different-Resolution","page":"SplinePulseProblem","title":"Resampling to Different Resolution","text":"The original pulse above has 50 knots. We can resample to 100 for finer control:\n\nqcp_resampled = SplinePulseProblem(qtraj, 100; Q = 100.0)\ncached_solve!(qcp_resampled, \"spline_pulse_resampled\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Linear-vs-Cubic-Splines","page":"SplinePulseProblem","title":"Linear vs Cubic Splines","text":"Linear Splines: The derivative :du represents the slope between knots. A DerivativeIntegrator constraint enforces du[k] = (u[k+1] - u[k]) / Œît.\n\npulse_linear = LinearSplinePulse(controls, times)\nqtraj_linear = UnitaryTrajectory(sys, pulse_linear, GATES[:X])\nqcp_linear = SplinePulseProblem(qtraj_linear)\n# du is constrained to be consistent with u\n\nCubic Splines (Hermite): The derivative :du represents independent Hermite tangents at each knot. These are free optimization variables with no inter-knot constraint.\n\npulse_cubic = CubicSplinePulse(controls, tangents, times)\nqtraj_cubic = UnitaryTrajectory(sys, pulse_cubic, GATES[:X])\nqcp_cubic = SplinePulseProblem(qtraj_cubic)\n# du (tangents) are independent variables","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Trajectory-Structure","page":"SplinePulseProblem","title":"Trajectory Structure","text":"Unlike SmoothPulseProblem which has three derivative levels (:u, :du, :ddu), SplinePulseProblem only has one:\n\nVariable Description\n:u Control values at knot points\n:du Derivatives/tangents (meaning depends on spline type)\n\nThe reduced number of variables can lead to faster optimization while maintaining smooth pulses through the spline interpolation.","category":"section"},{"location":"generated/problem-templates/spline_pulse/#See-Also","page":"SplinePulseProblem","title":"See Also","text":"SmoothPulseProblem - For piecewise constant controls\nBangBangPulseProblem - For L1-regularized bang-bang controls\nMinimumTimeProblem - Time-optimal control\nPulses - Detailed pulse type documentation\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"concepts/#concepts-overview","page":"Overview","title":"Concepts Overview","text":"Piccolo.jl solves quantum optimal control problems via direct trajectory optimization. This page describes the mathematical problem and how Piccolo.jl's components map onto it.","category":"section"},{"location":"concepts/#The-Optimization-Problem","page":"Overview","title":"The Optimization Problem","text":"Given a quantum system with Hamiltonian\n\nH(boldsymbolu t) = H_textdrift + sum_d c_d(boldsymbolu) H_d\n\nwhere each c_d(boldsymbolu) is a scalar coefficient ‚Äî typically linear (c_d = u_i) but also supporting nonlinear functions (e.g., c_d = u_1^2 + u_2^2) for displaced-frame and cross-Kerr terms ‚Äî we seek piecewise-constant controls boldsymbolu_1 dots boldsymbolu_N that steer the system from an initial state x_1 toward a goal, subject to hardware constraints. Piccolo.jl discretizes this into a finite-dimensional nonlinear program (NLP):\n\nbeginaligned\nmin_boldsymbolu Delta t quad  Q cdot ell(x_N x_textgoal) + sum_k=1^Nleft( R_u lVert boldsymbolu_k rVert^2 + R_du lVert Deltaboldsymbolu_k rVert^2 + R_ddu lVert Delta^2boldsymbolu_k rVert^2 right) 6pt\ntextst quad  x_k+1 = expbigl(Delta t_k cdot G(boldsymbolu_k)bigr) x_k qquad k = 1dots N-1 \n x_1 = x_textinit \n boldsymbolu_min leq boldsymbolu_k leq boldsymbolu_max\nendaligned\n\nwhere:\n\nx_k is the quantum state at timestep k, represented as a real vector via an isomorphism\nG(boldsymbolu) = G_textdrift + sum_i u_i G_textdrivei is the generator of the dynamics (see below)\nell(x_N x_textgoal) is an infidelity measure at the final time\nDelta boldsymbolu_k and Delta^2 boldsymbolu_k are discrete first and second differences of the controls\nQ, R_u, R_du, R_ddu are scalar weights","category":"section"},{"location":"concepts/#Generators","page":"Overview","title":"Generators","text":"The generator G depends on the type of evolution:\n\nEvolution Generator Equation\nClosed (Schr√∂dinger) G(boldsymbolu) = -ibigl(H_textdrift + sum_i u_i H_ibigr) dotU = G U or dotpsi = G psi\nOpen (Lindblad) mathcalG(boldsymbolu) = mathcalL_textdrift + sum_i u_i mathcalL_i dotrho = mathcalG textvec(rho)\n\nFor open systems, the Lindbladian superoperator includes dissipation:\n\nmathcalLrho = -iH rho + sum_k left( L_k rho L_k^dagger - tfrac12L_k^dagger L_k rho right)","category":"section"},{"location":"concepts/#Fidelity-Metrics","page":"Overview","title":"Fidelity Metrics","text":"The terminal cost ell is 1 - F for a trajectory-dependent fidelity F:\n\nTrajectory Fidelity F\nUnitaryTrajectory frac1d^2 lvert operatornametr(U_textgoal^dagger U_N) rvert^2\nKetTrajectory lvert langle psi_textgoal mid psi_N rangle rvert^2\nDensityTrajectory operatornametr(rho_textgoal rho_N)","category":"section"},{"location":"concepts/#Discretization","page":"Overview","title":"Discretization","text":"The dynamics constraint x_k+1 = exp(Delta t_k cdot G(boldsymbolu_k)) x_k is an exact matrix exponential propagator for the piecewise-constant Hamiltonian on each interval t_k t_k+1. This preserves unitarity by construction and is computed efficiently via Krylov subspace methods (ExponentialAction.jl).","category":"section"},{"location":"concepts/#How-Piccolo.jl-Maps-to-the-NLP","page":"Overview","title":"How Piccolo.jl Maps to the NLP","text":"  QuantumSystem          Pulse\n  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n  ‚îÇ H_drift      ‚îÇ    ‚îÇ u(t), times  ‚îÇ\n  ‚îÇ H_drives     ‚îÇ    ‚îÇ pulse type   ‚îÇ\n  ‚îÇ drive_bounds ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ\n         ‚îÇ                   ‚îÇ\n         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                   ‚îÇ\n                   ‚ñº\n             Trajectory                    ‚Üê defines  x_init, x_goal, G(u)\n          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n          ‚îÇ system       ‚îÇ\n          ‚îÇ pulse        ‚îÇ\n          ‚îÇ goal         ‚îÇ\n          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                 ‚îÇ\n                 ‚ñº\n       Problem Template                    ‚Üê assembles the NLP\n     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n     ‚îÇ SmoothPulseProblem   ‚îÇ\n     ‚îÇ BangBangPulseProblem ‚îÇ\n     ‚îÇ SplinePulseProblem   ‚îÇ\n     ‚îÇ MinimumTimeProblem   ‚îÇ\n     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n            ‚îÇ\n            ‚ñº\n     QuantumControlProblem                 ‚Üê the NLP\n     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n     ‚îÇ objective  J(z)   ‚îÇ\n     ‚îÇ dynamics   G(u)   ‚îÇ\n     ‚îÇ constraints       ‚îÇ\n     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n            ‚îÇ\n            ‚ñº\n        solve!(qcp)                        ‚Üê Ipopt (interior point)\n            ‚îÇ\n            ‚ñº\n     optimized pulse u*(t)","category":"section"},{"location":"concepts/#Component-Roles","page":"Overview","title":"Component Roles","text":"NLP element Piccolo.jl component Reference\nSystem Hamiltonian H(boldsymbolu) QuantumSystem Systems\nControl parameterization boldsymbolu(t) Pulse Pulses\nState type, initial/goal, generator G Trajectory Trajectories\nInfidelity ell and regularization Objective Objectives\nBounds, fidelity/leakage constraints Constraint Constraints\nReal vector representation x in mathbbR^n Isomorphism Isomorphisms\nSubspace embeddings Operators Operators","category":"section"},{"location":"concepts/#Decision-Variables","page":"Overview","title":"Decision Variables","text":"The full NLP decision vector z is a NamedTrajectory containing, at each of N knot points:\n\nVariable Symbol Dimension Description\nState x_k n_x Isomorphic quantum state\nControls boldsymbolu_k m Piecewise-constant amplitudes\n1st differences Deltaboldsymbolu_k m Control velocity\n2nd differences Delta^2boldsymbolu_k m Control acceleration\nTimestep Delta t_k 1 Interval duration (optionally free)\n\nThe state dimension n_x depends on the trajectory type and the system dimension d:\n\nTrajectory State n_x\nUnitaryTrajectory tildeU in mathbbR^2d^2 2d^2\nKetTrajectory tildepsi in mathbbR^2d 2d\nDensityTrajectory tilderho in mathbbR^d^2 d^2 (compact)","category":"section"},{"location":"concepts/#Workflow","page":"Overview","title":"Workflow","text":"A typical Piccolo.jl workflow follows these steps:\n\nusing Piccolo\n\n# 1. Define the quantum system: H(u) = H_drift + u‚ÇÅ H_x + u‚ÇÇ H_y\nsys = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]], [1.0, 1.0])\n\n# 2. Initial control pulse\npulse = ZeroOrderPulse(0.1 * randn(2, 100), range(0, 10.0, length=100))\n\n# 3. Trajectory = system + pulse + goal\nqtraj = UnitaryTrajectory(sys, pulse, GATES[:X])\n\n# 4. Assemble the NLP\nqcp = SmoothPulseProblem(qtraj, 100; Q=100.0, R=1e-2)\n\n# 5. Solve (Ipopt interior-point method)\nsolve!(qcp; max_iter=100)\n\n# 6. Extract results\nfidelity(qcp)\noptimized_pulse = get_pulse(qcp.qtraj)","category":"section"},{"location":"concepts/#Concept-Pages","page":"Overview","title":"Concept Pages","text":"Quantum Systems ‚Äî Hamiltonian structure, hardware constraints, and system templates\nTrajectories ‚Äî State types, goals, and generators\nPulses ‚Äî Control parameterizations, how controls vary in time\nObjectives ‚Äî Fidelity and regularization\nConstraints ‚Äî Bounds and equality constraints, leakage, fidelity\nOperators ‚Äî Subspace embeddings and lifted operators\nIsomorphisms ‚Äî Real vector representations","category":"section"},{"location":"concepts/#Architecture","page":"Overview","title":"Architecture","text":"Piccolo.jl\n‚îú‚îÄ‚îÄ Quantum          # Quantum mechanical building blocks\n‚îÇ   ‚îú‚îÄ‚îÄ Systems      # Hamiltonian representations\n‚îÇ   ‚îú‚îÄ‚îÄ Trajectories # Time evolution containers\n‚îÇ   ‚îú‚îÄ‚îÄ Pulses       # Control parameterizations\n‚îÇ   ‚îú‚îÄ‚îÄ Operators    # Embedded and lifted operators\n‚îÇ   ‚îî‚îÄ‚îÄ Isomorphisms # Real vector representations\n‚îÇ\n‚îú‚îÄ‚îÄ Control          # Optimal control framework\n‚îÇ   ‚îú‚îÄ‚îÄ Problems     # QuantumControlProblem wrapper\n‚îÇ   ‚îú‚îÄ‚îÄ Objectives   # Fidelity and regularization\n‚îÇ   ‚îú‚îÄ‚îÄ Constraints  # Bounds and equality constraints\n‚îÇ   ‚îî‚îÄ‚îÄ Templates    # High-level problem constructors\n‚îÇ\n‚îî‚îÄ‚îÄ Visualizations   # Plotting and analysis\n    ‚îú‚îÄ‚îÄ Trajectories # State and control plots\n    ‚îî‚îÄ‚îÄ Populations  # Population dynamics","category":"section"},{"location":"concepts/#Reexported-Packages","page":"Overview","title":"Reexported Packages","text":"Package Role\nDirectTrajOpt NLP assembly and Ipopt interface\nNamedTrajectories Decision variable storage\nTrajectoryIndexingUtils Trajectory slicing and indexing\n\nThese are available when you using Piccolo without additional imports.","category":"section"},{"location":"generated/state_transfer/#state-transfer-tutorial","page":"State Transfer","title":"State Transfer","text":"This tutorial covers state-to-state transfer using KetTrajectory. We'll prepare quantum states and implement gates via state mappings.","category":"section"},{"location":"generated/state_transfer/#Overview","page":"State Transfer","title":"Overview","text":"While UnitaryTrajectory optimizes for a full unitary gate, KetTrajectory optimizes for transferring a specific initial state to a target state. This is useful for:\n\nState preparation\nGates where you only care about specific state mappings\nProblems where full unitary tracking is expensive\n\nusing Piccolo\nusing CairoMakie\nusing Random\nRandom.seed!(123)","category":"section"},{"location":"generated/state_transfer/#Single-State-Transfer","page":"State Transfer","title":"Single State Transfer","text":"Let's prepare the |1‚ü© state starting from |0‚ü©.","category":"section"},{"location":"generated/state_transfer/#Setup","page":"State Transfer","title":"Setup","text":"# Create quantum system\nH_drift = 0.5 * PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n# Time parameters\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\n\n# Initial pulse\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)","category":"section"},{"location":"generated/state_transfer/#Define-State-Transfer","page":"State Transfer","title":"Define State Transfer","text":"# Initial state: |0‚ü©\nœà_init = ComplexF64[1.0, 0.0]\n\n# Target state: |1‚ü©\nœà_goal = ComplexF64[0.0, 1.0]\n\n# Create KetTrajectory\nqtraj = KetTrajectory(sys, pulse, œà_init, œà_goal)","category":"section"},{"location":"generated/state_transfer/#Solve","page":"State Transfer","title":"Solve","text":"qcp = SmoothPulseProblem(qtraj, N; Q = 100.0, R = 1e-2)\ncached_solve!(qcp, \"state_transfer_single\"; max_iter = 20, verbose = false, print_level = 1)\n\nfidelity(qcp)","category":"section"},{"location":"generated/state_transfer/#Visualize-State-Evolution","page":"State Transfer","title":"Visualize State Evolution","text":"traj = get_trajectory(qcp)\n\n# Convert isomorphic states to physical states\nn_steps = size(traj[:œàÃÉ], 2)\npopulations = zeros(2, n_steps)\n\nfor k = 1:n_steps\n    œà = iso_to_ket(traj[:œàÃÉ][:, k])\n    populations[:, k] = abs2.(œà)\nend\n\n# Plot\nfig = Figure(size = (800, 400))\n\nax1 = Axis(fig[1, 1], xlabel = \"Timestep\", ylabel = \"Population\", title = \"State Evolution\")\nlines!(ax1, 1:n_steps, populations[1, :], label = \"|0‚ü©\", linewidth = 2)\nlines!(ax1, 1:n_steps, populations[2, :], label = \"|1‚ü©\", linewidth = 2)\naxislegend(ax1, position = :rt)\n\nfig","category":"section"},{"location":"generated/state_transfer/#Multi-State-Transfer-(Gate-via-States)","page":"State Transfer","title":"Multi-State Transfer (Gate via States)","text":"We can define a gate by specifying how it maps multiple states. MultiKetTrajectory optimizes all mappings simultaneously with coherent phases.","category":"section"},{"location":"generated/state_transfer/#Define-X-Gate-via-State-Mappings","page":"State Transfer","title":"Define X Gate via State Mappings","text":"The X gate maps:\n\n|0‚ü© ‚Üí |1‚ü©\n|1‚ü© ‚Üí |0‚ü©\n\n# Basis states\nœà0 = ComplexF64[1.0, 0.0]  # |0‚ü©\nœà1 = ComplexF64[0.0, 1.0]  # |1‚ü©\n\n# Initial states and their targets\ninitial_states = [œà0, œà1]\ngoal_states = [œà1, œà0]  # X gate swaps them\n\n# Create new pulse for this problem\npulse_multi = ZeroOrderPulse(0.1 * randn(2, N), times)\n\n# Create MultiKetTrajectory\nqtraj_multi = MultiKetTrajectory(sys, pulse_multi, initial_states, goal_states)","category":"section"},{"location":"generated/state_transfer/#Solve-with-Coherent-Fidelity","page":"State Transfer","title":"Solve with Coherent Fidelity","text":"MultiKetTrajectory uses CoherentKetInfidelityObjective, which ensures not just that each state reaches its target, but that the relative phases between states are preserved correctly.\n\nqcp_multi = SmoothPulseProblem(qtraj_multi, N; Q = 100.0, R = 1e-2)\ncached_solve!(\n    qcp_multi,\n    \"state_transfer_multi\";\n    max_iter = 20,\n    verbose = false,\n    print_level = 1,\n)\n\nfidelity(qcp_multi)","category":"section"},{"location":"generated/state_transfer/#Visualize-Both-State-Evolutions","page":"State Transfer","title":"Visualize Both State Evolutions","text":"traj_multi = get_trajectory(qcp_multi)\n\n# Extract populations for both initial states\n# MultiKetTrajectory stores states as :œàÃÉ1, :œàÃÉ2, etc.\nn_steps = size(traj_multi[:œàÃÉ1], 2)\n\npops1 = zeros(2, n_steps)  # Evolution from |0‚ü©\npops2 = zeros(2, n_steps)  # Evolution from |1‚ü©\n\nfor k = 1:n_steps\n    œà1_k = iso_to_ket(traj_multi[:œàÃÉ1][:, k])\n    œà2_k = iso_to_ket(traj_multi[:œàÃÉ2][:, k])\n    pops1[:, k] = abs2.(œà1_k)\n    pops2[:, k] = abs2.(œà2_k)\nend\n\nfig2 = Figure(size = (800, 400))\n\nax1 = Axis(fig2[1, 1], xlabel = \"Timestep\", ylabel = \"Population\", title = \"|0‚ü© ‚Üí |1‚ü©\")\nlines!(ax1, 1:n_steps, pops1[1, :], label = \"|0‚ü©\", linewidth = 2, color = :blue)\nlines!(ax1, 1:n_steps, pops1[2, :], label = \"|1‚ü©\", linewidth = 2, color = :red)\naxislegend(ax1, position = :rt)\n\nax2 = Axis(fig2[1, 2], xlabel = \"Timestep\", ylabel = \"Population\", title = \"|1‚ü© ‚Üí |0‚ü©\")\nlines!(ax2, 1:n_steps, pops2[1, :], label = \"|0‚ü©\", linewidth = 2, color = :blue)\nlines!(ax2, 1:n_steps, pops2[2, :], label = \"|1‚ü©\", linewidth = 2, color = :red)\naxislegend(ax2, position = :rt)\n\nfig2","category":"section"},{"location":"generated/state_transfer/#When-to-Use-Each-Trajectory-Type","page":"State Transfer","title":"When to Use Each Trajectory Type","text":"Trajectory Use Case Pros Cons\nUnitaryTrajectory Full gate synthesis Complete gate, any input Tracks d¬≤ elements\nKetTrajectory Single state prep Fast, simple Single state only\nMultiKetTrajectory Gate via state maps Phase coherent Need all relevant states","category":"section"},{"location":"generated/state_transfer/#Superposition-State-Preparation","page":"State Transfer","title":"Superposition State Preparation","text":"Let's prepare a superposition state: |+‚ü© = (|0‚ü© + |1‚ü©)/‚àö2\n\nœà_plus = ComplexF64[1, 1] / sqrt(2)\n\npulse_super = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj_super = KetTrajectory(sys, pulse_super, œà0, œà_plus)\n\nqcp_super = SmoothPulseProblem(qtraj_super, N; Q = 100.0, R = 1e-2)\ncached_solve!(\n    qcp_super,\n    \"state_transfer_superposition\";\n    max_iter = 20,\n    verbose = false,\n    print_level = 1,\n)\n\nfidelity(qcp_super)\n\nVerify the final state:\n\ntraj_super = get_trajectory(qcp_super)\nœà_final = iso_to_ket(traj_super[:œàÃÉ][:, end])\nround.(œà_final, digits = 3)","category":"section"},{"location":"generated/state_transfer/#Next-Steps","page":"State Transfer","title":"Next Steps","text":"Multilevel Transmon: Work with realistic superconducting qubits\nRobust Control: Make pulses robust to parameter uncertainty\nProblem Templates: Full API documentation\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/concepts/operators/#operators-concept","page":"Operators","title":"Operators","text":"Piccolo.jl provides specialized operator types for working with composite and multilevel quantum systems.","category":"section"},{"location":"generated/concepts/operators/#Overview","page":"Operators","title":"Overview","text":"Type / Function Purpose\nEmbeddedOperator Gates acting on subspace of larger system\nlift_operator Operators lifted to composite Hilbert spaces\ndirect_sum Block diagonal operator combinations","category":"section"},{"location":"generated/concepts/operators/#EmbeddedOperator","page":"Operators","title":"EmbeddedOperator","text":"EmbeddedOperator represents a gate that acts on a computational subspace within a larger Hilbert space. This is essential for multilevel systems like transmons.","category":"section"},{"location":"generated/concepts/operators/#Construction","page":"Operators","title":"Construction","text":"using Piccolo\nusing SparseArrays\n\n# From a gate symbol\nsys = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.2, 0.2])\nU_X = EmbeddedOperator(:X, sys)\n\n# From a matrix\nT_gate = [1 0; 0 exp(im * œÄ / 4)]\nU_T = EmbeddedOperator(T_gate, sys)","category":"section"},{"location":"generated/concepts/operators/#Supported-Gate-Symbols","page":"Operators","title":"Supported Gate Symbols","text":"Standard single-qubit gates:\n\n:I, :X, :Y, :Z - Pauli gates\n:H - Hadamard\n:T, :S - Phase gates\n:sqrtX, :sqrtY - Square root gates\n\nTwo-qubit gates (for composite systems):\n\n:CX, :CNOT - Controlled-NOT\n:CZ - Controlled-Z\n:SWAP - SWAP\n:sqrtiSWAP - ‚àöiSWAP","category":"section"},{"location":"generated/concepts/operators/#Properties","page":"Operators","title":"Properties","text":"U_goal = EmbeddedOperator(:X, sys)\n\n# Access the full operator matrix\nsize(U_goal.operator)\n\n# Computational subspace\nU_goal.subspace","category":"section"},{"location":"generated/concepts/operators/#How-Embedding-Works","page":"Operators","title":"How Embedding Works","text":"For a 3-level system with computational subspace {|0‚ü©, |1‚ü©}:\n\nX_textembedded = beginpmatrix\n0  1  0 \n1  0  0 \n0  0  1\nendpmatrix\n\nThe gate acts as X on the first two levels and as identity on the third.\n\nU_goal.operator |> sparse","category":"section"},{"location":"generated/concepts/operators/#Use-with-Trajectories","page":"Operators","title":"Use with Trajectories","text":"T_dur, N = 10.0, 100\ntimes = collect(range(0, T_dur, length = N))\npulse = ZeroOrderPulse(0.01 * randn(2, N), times)\n\n# EmbeddedOperator is accepted as goal\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# Solve with leakage handling\nopts = PiccoloOptions(leakage_constraint = true, leakage_constraint_value = 1e-3)\nqcp = SmoothPulseProblem(qtraj, N; piccolo_options = opts)\ncached_solve!(qcp, \"operators_embedded\"; max_iter = 100)\nfidelity(qcp)","category":"section"},{"location":"generated/concepts/operators/#lift_operator","page":"Operators","title":"lift_operator","text":"lift_operator lifts an operator from a subsystem to a composite Hilbert space via tensor products.","category":"section"},{"location":"generated/concepts/operators/#Construction-2","page":"Operators","title":"Construction","text":"# Operator on qubit 1 of a 2-qubit system\nX_on_q1 = lift_operator(PAULIS[:X], 1, [2, 2])  # X ‚äó I\nX_on_q1 |> sparse\n\n# Operator on qubit 2\nZ_on_q2 = lift_operator(PAULIS[:Z], 2, [2, 2])  # I ‚äó Z\nZ_on_q2 |> sparse","category":"section"},{"location":"generated/concepts/operators/#Arguments","page":"Operators","title":"Arguments","text":"Argument Type Description\nop Matrix Operator to lift\nsubsystem Int Which subsystem (1-indexed)\ndims Vector{Int} Dimensions of all subsystems","category":"section"},{"location":"generated/concepts/operators/#Example:-Two-Qubit-Hamiltonian","page":"Operators","title":"Example: Two-Qubit Hamiltonian","text":"dims = [2, 2]  # Two qubits\n\n# Individual qubit terms\nZ1 = lift_operator(PAULIS[:Z], 1, dims)\nZ2 = lift_operator(PAULIS[:Z], 2, dims)\nX1 = lift_operator(PAULIS[:X], 1, dims)\nX2 = lift_operator(PAULIS[:X], 2, dims)\n\n# Build Hamiltonian: H = œâ1*Z1 + œâ2*Z2 + J*Z1*Z2\nœâ1, œâ2, J = 1.0, 1.1, 0.05\nH_drift_2q = œâ1 * Z1 + œâ2 * Z2 + J * Z1 * Z2\nH_drift_2q |> sparse","category":"section"},{"location":"generated/concepts/operators/#direct_sum","page":"Operators","title":"direct_sum","text":"direct_sum creates block diagonal operators, useful for parallel operations on independent subspaces.","category":"section"},{"location":"generated/concepts/operators/#Construction-3","page":"Operators","title":"Construction","text":"A = [1 0; 0 -1]\nB = [0 1; 1 0]\nC = direct_sum(A, B)\nC","category":"section"},{"location":"generated/concepts/operators/#Use-Case","page":"Operators","title":"Use Case","text":"Direct sums are useful for:\n\nOperations on multiple independent qubits\nBlock diagonal Hamiltonians\nComposite systems with no coupling","category":"section"},{"location":"generated/concepts/operators/#Common-Patterns","page":"Operators","title":"Common Patterns","text":"","category":"section"},{"location":"generated/concepts/operators/#Mixed-Subsystems","page":"Operators","title":"Mixed Subsystems","text":"Qubit coupled to a resonator (cavity):\n\n# Qubit: 2 levels, Cavity: 10 levels\ndims_qc = [2, 10]\n\n# Qubit operators\nœÉ_x = lift_operator(PAULIS[:X], 1, dims_qc)\nœÉ_z = lift_operator(PAULIS[:Z], 1, dims_qc)\n\n# Cavity operators\na_cav = lift_operator(annihilate(10), 2, dims_qc)\na_dag_cav = lift_operator(create(10), 2, dims_qc)\n\n# Jaynes-Cummings coupling\ng_jc = 0.1\nH_coupling = g_jc * (œÉ_x * (a_cav + a_dag_cav))\nH_coupling |> sparse","category":"section"},{"location":"generated/concepts/operators/#Utility-Functions","page":"Operators","title":"Utility Functions","text":"","category":"section"},{"location":"generated/concepts/operators/#Creating-Standard-Operators","page":"Operators","title":"Creating Standard Operators","text":"# Annihilation and creation operators\nlevels = 5\na = annihilate(levels)\na_dag = create(levels)\nn_op = a_dag * a  # Number operator\nn_op |> sparse\n\n# Pauli matrices\nI2, X, Y, Z = PAULIS[:I], PAULIS[:X], PAULIS[:Y], PAULIS[:Z]\nI2 |> sparse\n\nX |> sparse\n\nY |> sparse\n\nZ |> sparse","category":"section"},{"location":"generated/concepts/operators/#Tensor-Products","page":"Operators","title":"Tensor Products","text":"# Manual tensor product\nH_ZZ = kron(PAULIS[:Z], PAULIS[:Z])\n\n# Or use lift_operator for clarity\nZ1 = lift_operator(PAULIS[:Z], 1, [2, 2])\nZ2 = lift_operator(PAULIS[:Z], 2, [2, 2])\nH_ZZ_lifted = Z1 * Z2\n\nH_ZZ ‚âà H_ZZ_lifted","category":"section"},{"location":"generated/concepts/operators/#See-Also","page":"Operators","title":"See Also","text":"Leakage Suppression - Using EmbeddedOperator for leakage control\nQuantum Systems - Building Hamiltonians with operators\nIsomorphisms - Converting operators to optimization-friendly forms\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"systems/#systems-overview","page":"Overview","title":"Quantum Systems","text":"Piccolo.jl models quantum control using drive-based Hamiltonians:\n\nH(boldsymbolu t) = H_textdrift + sum_d c_d(boldsymbolu) H_d\n\nwhere H_textdrift is the always-on Hamiltonian, H_d are the drive operators, and c_d(boldsymbolu) is a scalar coefficient for each drive. For standard bilinear control, c_d = u_i (LinearDrive); Piccolo.jl also supports NonlinearDrive terms (e.g., c_d = u_1^2 + u_2^2) for displaced-frame and cross-Kerr physics.\n\nFor optimization, the Hamiltonian is converted to a generator:\n\nG(boldsymbolu) = -ileft( H_textdrift + sum_d c_d(boldsymbolu) H_d right)\n\nso that dotpsi = Gpsi (ket) or dotU = GU (unitary propagator). For open systems, the Lindbladian superoperator mathcalG(boldsymbolu) has the same bilinear structure (see Isomorphisms).","category":"section"},{"location":"systems/#System-Types","page":"Overview","title":"System Types","text":"Type Dynamics Use Case\nQuantumSystem dotU = GU Closed systems, gate synthesis\nOpenQuantumSystem dotvecrho = mathcalGvecrho Dissipative systems (Lindblad)\nCompositeQuantumSystem mathcalH = mathcalH_1 otimes mathcalH_2 Multi-subsystem setups","category":"section"},{"location":"systems/#Platform-Templates","page":"Overview","title":"Platform Templates","text":"Each page below documents the physical Hamiltonian, constructor API, and a worked optimization example.\n\nPlatform Template(s) System Type Key Physics\nTransmon Qubits TransmonSystem, MultiTransmonSystem, TransmonCavitySystem QuantumSystem / CompositeQuantumSystem Anharmonicity, dipole coupling, dispersive readout\nTrapped Ions IonChainSystem, RadialMSGateSystem QuantumSystem Motional modes, Lamb-Dicke coupling, M√∏lmer-S√∏rensen gates\nRydberg Atoms RydbergChainSystem QuantumSystem Van der Waals blockade, global/local drives\nCat Qubits CatSystem OpenQuantumSystem Two-photon drive, Kerr nonlinearity, photon loss\nSilicon Spins (coming soon) QuantumSystem Exchange-only qubits, detuning control","category":"section"},{"location":"systems/#Construction","page":"Overview","title":"Construction","text":"All templates produce a QuantumSystem (or subtype) that plugs directly into Trajectories and Problem Templates:\n\nusing Piccolo\n\nsys = TransmonSystem(levels=3, Œ¥=0.2, drive_bounds=[0.2, 0.2])\npulse = ZeroOrderPulse(0.05 * randn(2, 100), collect(range(0, 10, 100)))\nqtraj = UnitaryTrajectory(sys, pulse, GATES[:X])\nqcp = SmoothPulseProblem(qtraj, 100; Q=100.0)\nsolve!(qcp)","category":"section"},{"location":"systems/#Custom-Systems","page":"Overview","title":"Custom Systems","text":"For platforms not covered by a template, build directly from matrices:\n\n# Standard linear drives: H(u) = H_drift + u‚ÇÅ H‚ÇÅ + u‚ÇÇ H‚ÇÇ\nH_drift = my_drift_matrix\nH_drives = [my_drive_1, my_drive_2]\ndrive_bounds = [1.0, 1.0]\n\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\n\nFor systems with nonlinear drive coefficients, use typed drive terms. The Jacobian is auto-generated via ForwardDiff:\n\n# H(u) = u‚ÇÅ œÉx + u‚ÇÇ œÉy + (u‚ÇÅ¬≤ + u‚ÇÇ¬≤) œÉz\ndrives = AbstractDrive[\n    LinearDrive(sparse(ComplexF64.(œÉx)), 1),\n    LinearDrive(sparse(ComplexF64.(œÉy)), 2),\n    NonlinearDrive(œÉz, u -> u[1]^2 + u[2]^2),   # auto-Jacobian\n]\nsys = QuantumSystem(H_drift, drives, [1.0, 1.0])\n\nYou can also provide a hand-written Jacobian (validated against ForwardDiff at construction):\n\nNonlinearDrive(œÉz,\n    u -> u[1]^2 + u[2]^2,                         # coefficient c(u)\n    (u, j) -> j == 1 ? 2u[1] : j == 2 ? 2u[2] : 0.0;  # Jacobian ‚àÇc/‚àÇu‚±º\n    active_controls = [1, 2]                       # structural sparsity hint\n)\n\nAll Hamiltonians must be Hermitian (H = H^dagger); Piccolo.jl validates this at construction.","category":"section"},{"location":"systems/#See-Also","page":"Overview","title":"See Also","text":"Trajectories ‚Äî Combining systems with pulses and goals\nPulses ‚Äî Control parameterizations\nProblem Templates ‚Äî Setting up optimization\nIsomorphisms ‚Äî How complex matrices become real generators","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#smooth-pulse","page":"SmoothPulseProblem","title":"SmoothPulseProblem","text":"SmoothPulseProblem is the most commonly used problem template in Piccolo.jl. It sets up trajectory optimization with piecewise constant controls (ZeroOrderPulse) where control smoothness is enforced through discrete derivative variables.","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#When-to-Use","page":"SmoothPulseProblem","title":"When to Use","text":"Use SmoothPulseProblem when:\n\nYou want piecewise constant control pulses\nYou need smooth transitions between control values\nYou're starting a new optimization (not warm-starting from a previous solution)\nYou want fine control over derivative bounds","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Pulse-Requirement","page":"SmoothPulseProblem","title":"Pulse Requirement","text":"SmoothPulseProblem requires a trajectory with a ZeroOrderPulse:\n\npulse = ZeroOrderPulse(controls, times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SmoothPulseProblem(qtraj, N)  # Works\n\nUsing a spline pulse will result in an error directing you to SplinePulseProblem.","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Constructor","page":"SmoothPulseProblem","title":"Constructor","text":"SmoothPulseProblem(\n    qtraj::AbstractQuantumTrajectory{<:ZeroOrderPulse},\n    N::Int;\n    kwargs...\n)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Parameter-Reference","page":"SmoothPulseProblem","title":"Parameter Reference","text":"","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Required-Parameters","page":"SmoothPulseProblem","title":"Required Parameters","text":"Parameter Type Description\nqtraj AbstractQuantumTrajectory{ZeroOrderPulse} Quantum trajectory containing system, pulse, and goal\nN Int Number of discretization timesteps","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Objective-Weights","page":"SmoothPulseProblem","title":"Objective Weights","text":"Parameter Type Default Description\nQ Float64 100.0 Weight on infidelity objective. Higher values prioritize achieving target fidelity.\nR Float64 1e-2 Base regularization weight applied to all derivative terms.\nR_u Float64 or Vector{Float64} R Regularization on control values. Can be per-drive.\nR_du Float64 or Vector{Float64} R Regularization on first derivative (control jumps).\nR_ddu Float64 or Vector{Float64} R Regularization on second derivative (control acceleration).","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Bounds","page":"SmoothPulseProblem","title":"Bounds","text":"Parameter Type Default Description\ndu_bound Float64 Inf Maximum allowed control jump between timesteps.\nddu_bound Float64 1.0 Maximum allowed control acceleration.\nŒît_bounds Tuple{Float64, Float64} nothing Time-step bounds (min, max) for free-time optimization. Required for MinimumTimeProblem.","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Advanced-Options","page":"SmoothPulseProblem","title":"Advanced Options","text":"Parameter Type Default Description\nintegrator AbstractIntegrator nothing Custom integrator. If nothing, uses BilinearIntegrator.\nglobal_names Vector{Symbol} nothing Names of global parameters to optimize (requires custom integrator).\nglobal_bounds Dict{Symbol, ...} nothing Bounds on global variables. Values can be Float64 (symmetric ¬±) or Tuple{Float64, Float64}.\nconstraints Vector{AbstractConstraint} [] Additional constraints to add to the problem.\npiccolo_options PiccoloOptions PiccoloOptions() Solver and leakage options.","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Examples","page":"SmoothPulseProblem","title":"Examples","text":"","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Basic-Gate-Synthesis","page":"SmoothPulseProblem","title":"Basic Gate Synthesis","text":"using Piccolo\n\n# Define system\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n# Create trajectory\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys, pulse, GATES[:X])\n\n# Solve\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0, R = 1e-2)\ncached_solve!(qcp, \"smooth_pulse_basic\"; max_iter = 100)\n\nfidelity(qcp)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#With-Derivative-Bounds","page":"SmoothPulseProblem","title":"With Derivative Bounds","text":"Constrain how fast controls can change:\n\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    du_bound = 0.5,    ## Limit control jumps\n    ddu_bound = 0.1,    ## Limit control acceleration\n)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Enabling-Free-Time-for-MinimumTimeProblem","page":"SmoothPulseProblem","title":"Enabling Free Time for MinimumTimeProblem","text":"To later use MinimumTimeProblem, give bounds on variable timesteps:\n\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    Œît_bounds = (0.01, 0.5),  ## Timesteps can vary from 0.01 to 0.5\n)\ncached_solve!(qcp, \"smooth_pulse_free_time\"; max_iter = 100)\n\n# Now can minimize time\nqcp_mintime = MinimumTimeProblem(qcp; final_fidelity = 0.99)\ncached_solve!(qcp_mintime, \"smooth_pulse_mintime\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Per-Drive-Regularization","page":"SmoothPulseProblem","title":"Per-Drive Regularization","text":"Apply different regularization to different control channels:\n\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    R_u = [1e-3, 1e-2],     ## Less regularization on drive 1\n    R_du = [1e-2, 1e-1],    ## Different smoothness weights\n    R_ddu = [1e-2, 1e-1],\n)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#With-Leakage-Suppression","page":"SmoothPulseProblem","title":"With Leakage Suppression","text":"For multilevel systems, use PiccoloOptions to enable leakage handling, in this example a 3-level transmon system:\n\nsys = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.2, 0.2])\n\n# Embedded X gate (only affects computational subspace)\nU_goal = EmbeddedOperator(:X, sys)\n\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# Enable leakage suppression\nopts = PiccoloOptions(leakage_constraint = true, leakage_constraint_value = 1e-3)\n\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0, piccolo_options = opts)\ncached_solve!(qcp, \"smooth_pulse_leakage\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#State-Transfer","page":"SmoothPulseProblem","title":"State Transfer","text":"Works with KetTrajectory for state preparation. Here we go back to the 2-level system:\n\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\nœà_init = ComplexF64[1, 0]  ## |0‚ü©\nœà_goal = ComplexF64[0, 1]  ## |1‚ü©\n\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = KetTrajectory(sys, pulse, œà_init, œà_goal)\n\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0)\ncached_solve!(qcp, \"smooth_pulse_state_transfer\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Multiple-State-Transfers","page":"SmoothPulseProblem","title":"Multiple State Transfers","text":"Use MultiKetTrajectory for gates defined by state mappings:\n\nœà0, œà1 = ComplexF64[1, 0], ComplexF64[0, 1]\n\n# X gate: |0‚ü© ‚Üí |1‚ü© and |1‚ü© ‚Üí |0‚ü©\nqtraj = MultiKetTrajectory(sys, pulse, [œà0, œà1], [œà1, œà0])\n\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0)\ncached_solve!(qcp, \"smooth_pulse_multi_ket\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#How-It-Works","page":"SmoothPulseProblem","title":"How It Works","text":"SmoothPulseProblem internally:\n\nAdds derivative variables: Creates :du (first derivative) and :ddu (second derivative) variables alongside controls :u\nSets up integrators: Uses DerivativeIntegrator to enforce consistency:\ndu[k] = (u[k+1] - u[k]) / Œît\nddu[k] = (du[k+1] - du[k]) / Œît\nConfigures objectives:\nInfidelity objective with weight Q\nQuadratic regularization on u, du, ddu with weights R_u, R_du, R_ddu\nApplies bounds: Enforces du_bound and ddu_bound as hard constraints\n\nThe derivative variables act as auxiliary optimization variables that encourage smooth control transitions without requiring explicit smoothness constraints on the original controls.","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#See-Also","page":"SmoothPulseProblem","title":"See Also","text":"BangBangPulseProblem - For L1-regularized bang-bang controls\nSplinePulseProblem - For inherently smooth spline-based controls\nMinimumTimeProblem - Time-optimal control\nSamplingProblem - Robust optimization\nPulses - Pulse type documentation\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/concepts/objectives/#objectives-concept","page":"Objectives","title":"Objectives","text":"Objectives define what the optimization minimizes.  The total cost function evaluated at the N-point trajectory is a weighted sum of a terminal infidelity and running regularization penalties:\n\nJ(boldsymbolz) = Q cdot ell(x_N x_textgoal)\n+ sum_k=1^Nleft(\n    R_u lVert boldsymbolu_k rVert^2\n  + R_du lVert Deltaboldsymbolu_k rVert^2\n  + R_ddu lVert Delta^2boldsymbolu_k rVert^2\nright)\n\nwhere boldsymbolz is the full NLP decision vector (see Concepts Overview).","category":"section"},{"location":"generated/concepts/objectives/#Fidelity-Objectives","page":"Objectives","title":"Fidelity Objectives","text":"The terminal cost ell = 1 - F for a trajectory-dependent fidelity F.  Gradients are computed via ForwardDiff automatic differentiation through the isomorphic state representation.","category":"section"},{"location":"generated/concepts/objectives/#UnitaryInfidelityObjective","page":"Objectives","title":"UnitaryInfidelityObjective","text":"Gate synthesis fidelity for a d-level system:\n\nF_U = frac1d^2 left operatornametr(U_textgoal^dagger U_N) right^2\n\nobj = UnitaryInfidelityObjective(:≈®‚Éó, U_goal; Q=100.0)","category":"section"},{"location":"generated/concepts/objectives/#KetInfidelityObjective","page":"Objectives","title":"KetInfidelityObjective","text":"State-transfer fidelity:\n\nF_psi = left langle psi_textgoal  psi_N rangle right^2\n\nobj = KetInfidelityObjective(:œàÃÉ, œà_goal; Q=100.0)","category":"section"},{"location":"generated/concepts/objectives/#CoherentKetInfidelityObjective","page":"Objectives","title":"CoherentKetInfidelityObjective","text":"For n state pairs with phase coherence (used by MultiKetTrajectory):\n\nF_textcoh = left frac1n sum_j=1^n langle psi_textgoalj  psi_jN rangle right^2\n\nThis is strictly harder than per-state fidelity because relative phases must be correct.\n\nobj = CoherentKetInfidelityObjective([:œàÃÉ1, :œàÃÉ2], [œà_goal1, œà_goal2]; Q=100.0)","category":"section"},{"location":"generated/concepts/objectives/#DensityMatrixInfidelityObjective","page":"Objectives","title":"DensityMatrixInfidelityObjective","text":"For open-system optimization with the compact density isomorphism:\n\nF_rho = operatornametr(rho_textgoal rho_N)\n\nThe state tilderho_N in mathbbR^d^2 is converted back to a Hermitian matrix via compact_iso_to_density before computing the trace.\n\nobj = DensityMatrixInfidelityObjective(:œÅ‚ÉóÃÉ, œÅ_goal, traj; Q=100.0)","category":"section"},{"location":"generated/concepts/objectives/#UnitaryFreePhaseInfidelityObjective","page":"Objectives","title":"UnitaryFreePhaseInfidelityObjective","text":"When global phase doesn't matter, optimizes over phi:\n\nF = max_phi frac1d^2 left operatornametr(e^iphi U_textgoal^dagger U_N) right^2\n\nobj = UnitaryFreePhaseInfidelityObjective(:≈®‚Éó, U_goal; Q=100.0)","category":"section"},{"location":"generated/concepts/objectives/#Regularization-Objectives","page":"Objectives","title":"Regularization Objectives","text":"Regularization penalizes large or rapidly-varying controls via quadratic running costs:\n\nJ_u = sum_k=1^N lVert boldsymbolu_k rVert^2 qquad\nJ_du = sum_k=1^N lVert Deltaboldsymbolu_k rVert^2 qquad\nJ_ddu = sum_k=1^N lVert Delta^2boldsymbolu_k rVert^2\n\nwhere Deltaboldsymbolu_k = boldsymbolu_k - boldsymbolu_k-1 are discrete differences.\n\nreg_u   = QuadraticRegularizer(:u, traj, R)\nreg_du  = QuadraticRegularizer(:du, traj, R)\nreg_ddu = QuadraticRegularizer(:ddu, traj, R)","category":"section"},{"location":"generated/concepts/objectives/#Why-Regularize?","page":"Objectives","title":"Why Regularize?","text":"Smoothness: Derivative regularization encourages smooth pulses\nRobustness: Prevents exploiting numerical precision\nHardware-friendliness: Bounded, smooth controls are easier to implement\nConvergence: Regularization improves the optimization landscape","category":"section"},{"location":"generated/concepts/objectives/#Leakage-Objectives","page":"Objectives","title":"Leakage Objectives","text":"For multilevel systems, leakage to non-computational states can be penalized.","category":"section"},{"location":"generated/concepts/objectives/#LeakageObjective","page":"Objectives","title":"LeakageObjective","text":"op = EmbeddedOperator(:X, sys)  # X gate in computational subspace\nobj = LeakageObjective(:≈®‚Éó, op; Q=10.0)\n\nPenalizes population outside the computational subspace at the final time.","category":"section"},{"location":"generated/concepts/objectives/#Via-PiccoloOptions","page":"Objectives","title":"Via PiccoloOptions","text":"opts = PiccoloOptions(\n    leakage_constraint=true,\n    leakage_constraint_value=1e-3,\n    leakage_cost=10.0\n)\n\nqcp = SmoothPulseProblem(qtraj, N; piccolo_options=opts)","category":"section"},{"location":"generated/concepts/objectives/#Using-Objectives-in-Problem-Templates","page":"Objectives","title":"Using Objectives in Problem Templates","text":"Problem templates automatically set up objectives.  The fidelity objective is selected based on the trajectory type:\n\nTrajectory Type Default Objective\nUnitaryTrajectory UnitaryInfidelityObjective\nKetTrajectory KetInfidelityObjective\nMultiKetTrajectory CoherentKetInfidelityObjective\nDensityTrajectory DensityMatrixInfidelityObjective","category":"section"},{"location":"generated/concepts/objectives/#Example","page":"Objectives","title":"Example","text":"using Piccolo\n\n# Set up a system\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nU_goal = GATES[:X]\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# SmoothPulseProblem automatically creates:\n# - UnitaryInfidelityObjective (for UnitaryTrajectory)\n# - QuadraticRegularizer for :u, :du, :ddu\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,      # Fidelity weight\n    R_u = 1e-3,     # Control regularization\n    R_du = 1e-2,    # First derivative regularization\n    R_ddu = 1e-2,   # Second derivative regularization\n)\ncached_solve!(qcp, \"objectives_example\"; max_iter = 50)\nfidelity(qcp)","category":"section"},{"location":"generated/concepts/objectives/#Objective-Weights","page":"Objectives","title":"Objective Weights","text":"","category":"section"},{"location":"generated/concepts/objectives/#The-Q-Parameter","page":"Objectives","title":"The Q Parameter","text":"Q scales the infidelity term Q cdot (1 - F):\n\nHigher Q (e.g., 1000): Prioritize fidelity over smoothness\nLower Q (e.g., 10): Allow more flexibility in controls","category":"section"},{"location":"generated/concepts/objectives/#The-R-Parameters","page":"Objectives","title":"The R Parameters","text":"R_u, R_du, R_ddu scale the regularization terms:\n\nHigher R: Smoother, smaller controls\nLower R: More aggressive controls allowed","category":"section"},{"location":"generated/concepts/objectives/#Balancing-Trade-offs","page":"Objectives","title":"Balancing Trade-offs","text":"# High fidelity weight\nqcp_high_Q =\n    SmoothPulseProblem(UnitaryTrajectory(sys, pulse, U_goal), N; Q = 1000.0, R = 1e-2)\ncached_solve!(qcp_high_Q, \"objectives_high_Q\"; max_iter = 100)\nfidelity(qcp_high_Q)\n\nHigh regularization\n\nqcp_high_R =\n    SmoothPulseProblem(UnitaryTrajectory(sys, pulse, U_goal), N; Q = 100.0, R = 0.1)\ncached_solve!(qcp_high_R, \"objectives_high_R\"; max_iter = 100)\nfidelity(qcp_high_R)","category":"section"},{"location":"generated/concepts/objectives/#Typical-Starting-Values","page":"Objectives","title":"Typical Starting Values","text":"Parameter Typical Range Starting Point\nQ 10 - 10000 100\nR 1e-6 - 1.0 1e-2\nR_u same as R R\nR_du same as R R\nR_ddu same as R R","category":"section"},{"location":"generated/concepts/objectives/#Best-Practices","page":"Objectives","title":"Best Practices","text":"","category":"section"},{"location":"generated/concepts/objectives/#1.-Start-with-Defaults","page":"Objectives","title":"1. Start with Defaults","text":"Problem templates have sensible defaults. Start there:\n\nqcp = SmoothPulseProblem(qtraj, N)  # Uses Q=100, R=1e-2","category":"section"},{"location":"generated/concepts/objectives/#2.-Tune-Q-First","page":"Objectives","title":"2. Tune Q First","text":"If fidelity is too low, increase Q.","category":"section"},{"location":"generated/concepts/objectives/#3.-Tune-R-if-Controls-are-Problematic","page":"Objectives","title":"3. Tune R if Controls are Problematic","text":"If controls are too noisy or large, increase R.","category":"section"},{"location":"generated/concepts/objectives/#4.-Use-Per-Derivative-Tuning-for-Fine-Control","page":"Objectives","title":"4. Use Per-Derivative Tuning for Fine Control","text":"qcp = SmoothPulseProblem(\n    qtraj, N;\n    R_u=1e-4,    # Allow larger control values\n    R_du=1e-2,   # Penalize jumps moderately\n    R_ddu=0.1    # Strongly penalize acceleration\n)","category":"section"},{"location":"generated/concepts/objectives/#See-Also","page":"Objectives","title":"See Also","text":"Constraints - Hard constraints on solutions\nProblem Templates - How objectives are used\nSmoothPulseProblem - Parameter reference\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/guides/global_variables/#global-variables","page":"Global Variables","title":"Global Variables","text":"Global variables allow you to optimize system parameters alongside control pulses. This is useful for calibrating system properties or finding optimal operating points.","category":"section"},{"location":"generated/guides/global_variables/#When-to-Use-Global-Variables","page":"Global Variables","title":"When to Use Global Variables","text":"System calibration: Finding optimal qubit frequencies or coupling strengths\nGate design: Optimizing hardware parameters for better gates\nSensitivity analysis: Understanding parameter effects","category":"section"},{"location":"generated/guides/global_variables/#Basic-Concept","page":"Global Variables","title":"Basic Concept","text":"Standard optimization only varies control pulses u(t). With global variables, you can also optimize system parameters that appear in the Hamiltonian.\n\nH(u t theta) = H_textdrift(theta) + sum_i u_i(t) H_textdrivei(theta)\n\nWhere theta are global parameters to optimize.","category":"section"},{"location":"generated/guides/global_variables/#Setup-Requirements","page":"Global Variables","title":"Setup Requirements","text":"Global variable optimization requires:\n\nA QuantumSystem with global_params\nA custom integrator that supports globals (e.g., from Piccolissimo)\nGlobal bounds specification\n\nPiccolo's built-in BilinearIntegrator does not support global variables ‚Äî it has no global-aware Jacobian columns or Hessian blocks. A custom integrator from Piccolissimo handles the extended control vector [controls..., globals...] and provides the correct derivative information to the optimizer.\n\nThis guide demonstrates the global variable API using Piccolo's built-in integrator. The globals are stored in the trajectory and bounded, but are not coupled to the dynamics. For full global optimization, use a Piccolissimo integrator.","category":"section"},{"location":"generated/guides/global_variables/#Defining-a-System-with-Global-Parameters","page":"Global Variables","title":"Defining a System with Global Parameters","text":"Global parameters are stored on the QuantumSystem via the global_params keyword argument. With a custom integrator from Piccolissimo, the Hamiltonian function receives u = [controls..., globals...]:\n\n## Function-based system (requires Piccolissimo integrator for dynamics)\nH = (u, t) -> u[3] * PAULIS[:Z] + u[1] * PAULIS[:X] + u[2] * PAULIS[:Y]\nsys = QuantumSystem(H, [1.0, 1.0]; time_dependent=true, global_params=(Œ¥=0.5,))\n\nFor this guide we use a matrix-based system, which works with the built-in BilinearIntegrator:\n\nusing Piccolo\n\nsys = QuantumSystem(\n    PAULIS[:Z],\n    [PAULIS[:X], PAULIS[:Y]],\n    [1.0, 1.0];\n    global_params = (Œ¥ = 0.5,),\n)\n\nsys.global_params","category":"section"},{"location":"generated/guides/global_variables/#Setting-Up-a-Problem-with-Globals","page":"Global Variables","title":"Setting Up a Problem with Globals","text":"When global_params is set on the system, SmoothPulseProblem automatically includes the global variables in the trajectory as optimization variables. The global_bounds keyword constrains their range:\n\nT = 10.0\nN = 50\nU_goal = GATES[:X]\n\nqtraj = UnitaryTrajectory(sys, U_goal, T)\n\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    R = 1e-2,\n    global_bounds = Dict(:Œ¥ => 1.0),  ## symmetric bounds: Œ¥ ‚àà [Œ¥‚ÇÄ - 1.0, Œ¥‚ÇÄ + 1.0]\n)\n\ncached_solve!(\n    qcp,\n    \"global_variables_single\";\n    max_iter = 100,\n    verbose = false,\n    print_level = 1,\n)","category":"section"},{"location":"generated/guides/global_variables/#Accessing-Global-Variables","page":"Global Variables","title":"Accessing Global Variables","text":"After solving, global values are stored in the trajectory's global_data vector, indexed by global_components:\n\ntraj = get_trajectory(qcp)\noptimized_Œ¥ = traj.global_data[traj.global_components[:Œ¥]][1]\noptimized_Œ¥\n\nnote: Note\nWith the built-in BilinearIntegrator, the global variable is not coupled to the dynamics, so its value will remain near the initial value. To actually optimize globals through the Hamiltonian, use a Piccolissimo integrator that provides global-aware Jacobians and Hessians.","category":"section"},{"location":"generated/guides/global_variables/#Global-Bounds-Format","page":"Global Variables","title":"Global Bounds Format","text":"Global bounds can be specified in two ways:\n\nSymmetric bounds (scalar): applied as ¬±value around the initial value.\n\nglobal_bounds = Dict(:Œ¥ => 0.05)  # Œ¥ ‚àà [Œ¥‚ÇÄ - 0.05, Œ¥‚ÇÄ + 0.05]\n\nAsymmetric bounds (tuple): explicit (lower, upper) bounds.\n\nglobal_bounds = Dict(:Œ¥ => (0.05, 0.2))  # Œ¥ ‚àà [0.05, 0.2]\n\nMultiple globals with mixed bound types:\n\nglobal_bounds = Dict(\n    :Œ¥ => (0.05, 0.2),\n    :J => 0.01,  # J ‚àà [J‚ÇÄ - 0.01, J‚ÇÄ + 0.01]\n)","category":"section"},{"location":"generated/guides/global_variables/#Multiple-Global-Variables","page":"Global Variables","title":"Multiple Global Variables","text":"You can define several system parameters simultaneously:\n\nsys_multi =\n    QuantumSystem(PAULIS[:Z], [PAULIS[:X]], [1.0]; global_params = (œâ = 1.0, J = 0.05))\n\nqtraj_multi = UnitaryTrajectory(sys_multi, U_goal, T)\n\nqcp_multi = SmoothPulseProblem(\n    qtraj_multi,\n    N;\n    Q = 100.0,\n    R = 1e-2,\n    global_bounds = Dict(:œâ => (0.9, 1.1), :J => (0.02, 0.1)),\n)\n\ncached_solve!(\n    qcp_multi,\n    \"global_variables_multi\";\n    max_iter = 100,\n    verbose = false,\n    print_level = 1,\n)\n\n# Access optimized global values\ntraj_multi = get_trajectory(qcp_multi)\noptimized_global_data = traj_multi.global_data\n(optimized_global_data)","category":"section"},{"location":"generated/guides/global_variables/#Best-Practices","page":"Global Variables","title":"Best Practices","text":"","category":"section"},{"location":"generated/guides/global_variables/#1.-Start-with-Good-Initial-Values","page":"Global Variables","title":"1. Start with Good Initial Values","text":"Use physically reasonable initial parameters. The initial values come from global_params in the QuantumSystem constructor:\n\nsys = QuantumSystem(H_drift, H_drives, bounds; global_params = (Œ¥ = 0.15,))","category":"section"},{"location":"generated/guides/global_variables/#2.-Use-Reasonable-Bounds","page":"Global Variables","title":"2. Use Reasonable Bounds","text":"Don't make bounds too wide ‚Äî ~50% variation is usually sufficient:\n\nglobal_bounds = Dict(:Œ¥ => (0.1, 0.2))  # Not 10x variation","category":"section"},{"location":"generated/guides/global_variables/#3.-Consider-Sensitivity","page":"Global Variables","title":"3. Consider Sensitivity","text":"Global parameters affect all timesteps, so they have strong influence on the solution. Start with tighter bounds and relax if needed.","category":"section"},{"location":"generated/guides/global_variables/#4.-Verify-Physical-Meaning","page":"Global Variables","title":"4. Verify Physical Meaning","text":"After optimization, check that global values are physically reasonable:","category":"section"},{"location":"generated/guides/global_variables/#Comparison-with-SamplingProblem","page":"Global Variables","title":"Comparison with SamplingProblem","text":"Feature Global Variables SamplingProblem\nParameter role Optimized Fixed (sampled)\nGoal Find optimal parameter Robust to parameter variation\nUse case Calibration, design Uncertainty handling\n\nFor robustness to uncertainty, use SamplingProblem. For finding optimal parameters, use global variables.","category":"section"},{"location":"generated/guides/global_variables/#Limitations","page":"Global Variables","title":"Limitations","text":"Full global optimization requires a custom integrator from Piccolissimo that provides global-aware Jacobians and Hessians\nPiccolo's built-in BilinearIntegrator stores globals in the trajectory but does not couple them to the dynamics\nMore complex optimization landscape\nConvergence can be slower","category":"section"},{"location":"generated/guides/global_variables/#See-Also","page":"Global Variables","title":"See Also","text":"SamplingProblem - For parameter robustness\nQuantum Systems - System construction\nProblem Templates - Main optimization API\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/concepts/isomorphisms/#isomorphisms-concept","page":"Isomorphisms","title":"Isomorphisms","text":"Piccolo.jl uses real isomorphisms to convert complex quantum states and operators into real vectors suitable for numerical optimization.","category":"section"},{"location":"generated/concepts/isomorphisms/#Why-Isomorphisms?","page":"Isomorphisms","title":"Why Isomorphisms?","text":"Optimization algorithms work with real numbers. Quantum states and unitaries are complex, so we need to:\n\nConvert complex objects to real vectors for optimization\nConvert back to complex form for physics calculations","category":"section"},{"location":"generated/concepts/isomorphisms/#State-Isomorphisms","page":"Isomorphisms","title":"State Isomorphisms","text":"","category":"section"},{"location":"generated/concepts/isomorphisms/#Ket-States","page":"Isomorphisms","title":"Ket States","text":"A complex ket state |œà‚ü© is converted to a real vector:\n\nusing Piccolo\nusing LinearAlgebra\n\n# Complex ket\nœà = ComplexF64[1, im] / ‚àö2\n\n# Convert to isomorphic form\nœàÃÉ = ket_to_iso(œà)\n\n# Convert back\nœà_recovered = iso_to_ket(œàÃÉ)\nœà ‚âà œà_recovered","category":"section"},{"location":"generated/concepts/isomorphisms/#Mathematical-Form","page":"Isomorphisms","title":"Mathematical Form","text":"psirangle = beginpmatrix a + ib  c + id endpmatrix\nquadrightarrowquad\ntildepsi = beginpmatrix a  c  b  d endpmatrix\n\nThe isomorphism stacks real parts followed by imaginary parts.","category":"section"},{"location":"generated/concepts/isomorphisms/#Operator-Isomorphisms","page":"Isomorphisms","title":"Operator Isomorphisms","text":"","category":"section"},{"location":"generated/concepts/isomorphisms/#Unitary-Operators","page":"Isomorphisms","title":"Unitary Operators","text":"Unitary matrices are vectorized and converted to real form:\n\n# Complex unitary\nU = GATES[:H]  # Hadamard\nU\n\n# Convert to isomorphic vector\n≈® = operator_to_iso_vec(U)\nlength(≈®)\n\n# Convert back\nU_recovered = iso_vec_to_operator(≈®)\nU ‚âà U_recovered","category":"section"},{"location":"generated/concepts/isomorphisms/#Mathematical-Form-2","page":"Isomorphisms","title":"Mathematical Form","text":"The unitary U is first vectorized (column-major) then split into real and imaginary parts:\n\nU = beginpmatrix U_11  U_12  U_21  U_22 endpmatrix\nrightarrow\ntextvec(U) = beginpmatrix U_11  U_21  U_12  U_22 endpmatrix\nrightarrow\ntildeU = beginpmatrix textRe(textvec(U))  textIm(textvec(U)) endpmatrix","category":"section"},{"location":"generated/concepts/isomorphisms/#Density-Matrix-Isomorphisms","page":"Isomorphisms","title":"Density Matrix Isomorphisms","text":"","category":"section"},{"location":"generated/concepts/isomorphisms/#The-Compact-Representation","page":"Isomorphisms","title":"The Compact Representation","text":"Density matrices œÅ are Hermitian (œÅ = œÅ‚Ä†), so a d√ód density matrix has only d¬≤ independent real parameters ‚Äî not 2d¬≤. Piccolo.jl exploits this with a compact isomorphism that halves the state dimension compared to the naive [Re(vec(œÅ)); Im(vec(œÅ))] approach.\n\nThe compact vector x ‚àà ‚Ñù·µà¬≤ packs the upper triangle of œÅ:\n\nReal parts of the upper triangle (column-major, j ‚â§ k): d(d+1)/2 entries\nImaginary parts of the strict upper triangle (j < k): d(d-1)/2 entries\n\nTotal: d(d+1)/2 + d(d-1)/2 = d¬≤\n\nusing SparseArrays  #hide\n\n# Example: compact isomorphism for a 3-level density matrix\nœÅ = ComplexF64[\n    0.5 0.1+0.2im 0.0+0.1im\n    0.1-0.2im 0.3 0.05+0.0im\n    0.0-0.1im 0.05 0.2\n]\n\nx = density_to_compact_iso(œÅ)\nlength(x)  ## d¬≤ = 9 (not 2d¬≤ = 18)\n\n# Round-trip: compact iso back to density matrix\nœÅ_recovered = compact_iso_to_density(x)\nœÅ ‚âà œÅ_recovered","category":"section"},{"location":"generated/concepts/isomorphisms/#Lift-and-Projection-Matrices","page":"Isomorphisms","title":"Lift and Projection Matrices","text":"The compact representation is related to the full 2d¬≤-dimensional iso_vec by a pair of sparse matrices:\n\nLift matrix L (2d¬≤ √ó d¬≤): maps compact ‚Üí full, reconstructing the lower triangle from Hermiticity\nProjection matrix P (d¬≤ √ó 2d¬≤): maps full ‚Üí compact, extracting the upper triangle\n\nThese satisfy P * L = I(d¬≤) (left inverse).\n\nunderbracetilderho_textfull_2d^2 = L underbracex_d^2\nqquad\nx = P  tilderho_textfull\n\nd_ex = 3\nL = density_lift_matrix(d_ex)\nP = density_projection_matrix(d_ex)\n(size(L), size(P))\n\n# P * L is the identity\nP * L ‚âà I(d_ex^2)","category":"section"},{"location":"generated/concepts/isomorphisms/#Why-This-Matters","page":"Isomorphisms","title":"Why This Matters","text":"For open quantum system optimization, the Lindbladian generators ùí¢ are reduced from (2d¬≤)¬≤ ‚Üí (d¬≤)¬≤ entries via ùí¢_compact = P * ùí¢ * L. For a cat qubit with d = 14 (cat ‚äó buffer), this cuts the state vector from 392 to 196 entries and the generator from ~150k to ~38k entries ‚Äî roughly a 4√ó speedup in integration.","category":"section"},{"location":"generated/concepts/isomorphisms/#Using-Isomorphisms-in-Practice","page":"Isomorphisms","title":"Using Isomorphisms in Practice","text":"","category":"section"},{"location":"generated/concepts/isomorphisms/#Accessing-Trajectory-Data","page":"Isomorphisms","title":"Accessing Trajectory Data","text":"Trajectories store isomorphic states. Let's solve a problem and inspect:\n\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nU_goal = GATES[:X]\n\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0)\ncached_solve!(qcp, \"isomorphisms_example\"; max_iter = 50)\nfidelity(qcp)","category":"section"},{"location":"generated/concepts/isomorphisms/#Inspecting-Isomorphic-State","page":"Isomorphisms","title":"Inspecting Isomorphic State","text":"traj = get_trajectory(qcp)\n\n# Isomorphic unitary at final timestep\n≈®_final = traj[:≈®‚Éó][:, end]\nlength(≈®_final)\n\n# Convert to complex unitary\nU_final = iso_vec_to_operator(≈®_final)\nsize(U_final)","category":"section"},{"location":"generated/concepts/isomorphisms/#Computing-Fidelity-Manually","page":"Isomorphisms","title":"Computing Fidelity Manually","text":"d = size(U_goal, 1)\nF = abs(tr(U_goal' * U_final))^2 / d^2\nF","category":"section"},{"location":"generated/concepts/isomorphisms/#Function-Reference","page":"Isomorphisms","title":"Function Reference","text":"","category":"section"},{"location":"generated/concepts/isomorphisms/#Ket-Conversions","page":"Isomorphisms","title":"Ket Conversions","text":"Function Description\nket_to_iso(œà) Complex ket ‚Üí real vector\niso_to_ket(œàÃÉ) Real vector ‚Üí complex ket","category":"section"},{"location":"generated/concepts/isomorphisms/#Operator-Conversions","page":"Isomorphisms","title":"Operator Conversions","text":"Function Description\noperator_to_iso_vec(U) Complex operator ‚Üí real vector\niso_vec_to_operator(≈®) Real vector ‚Üí complex operator","category":"section"},{"location":"generated/concepts/isomorphisms/#Density-Matrix-Conversions","page":"Isomorphisms","title":"Density Matrix Conversions","text":"Function Description\ndensity_to_compact_iso(œÅ) Hermitian matrix ‚Üí compact real vector (d¬≤)\ncompact_iso_to_density(x) Compact real vector ‚Üí Hermitian matrix\ndensity_lift_matrix(d) Sparse L matrix: compact ‚Üí full (2d¬≤ √ó d¬≤)\ndensity_projection_matrix(d) Sparse P matrix: full ‚Üí compact (d¬≤ √ó 2d¬≤)","category":"section"},{"location":"generated/concepts/isomorphisms/#Variable-Naming-Convention","page":"Isomorphisms","title":"Variable Naming Convention","text":"Piccolo.jl uses a tilde notation to distinguish isomorphic variables:\n\nPhysical Isomorphic Meaning\nœà œàÃÉ Ket state\nU ≈® Unitary operator\nœÅ œÅÃÉ Density matrix\n\nIn trajectories:\n\n:œàÃÉ - Isomorphic ket state\n:≈®‚Éó - Isomorphic vectorized unitary\n:œÅÃÉ - Isomorphic vectorized density matrix","category":"section"},{"location":"generated/concepts/isomorphisms/#Dimension-Reference","page":"Isomorphisms","title":"Dimension Reference","text":"For a system with d levels:\n\nObject Complex Dimension Isomorphic Dimension\nKet |œà‚ü© d complex 2d real\nUnitary U d√ód complex 2d¬≤ real\nDensity œÅ (compact) d√ód Hermitian d¬≤ real\n\n# Verify dimensions for a 2-level system\nd = 2\nlength(ket_to_iso(zeros(ComplexF64, d)))           ## 2d real elements\n\nlength(operator_to_iso_vec(zeros(ComplexF64, d, d))) ## 2d¬≤ real elements\n\nœÅ_test = ComplexF64[1 0; 0 0]\nlength(density_to_compact_iso(œÅ_test))              ## d¬≤ real elements","category":"section"},{"location":"generated/concepts/isomorphisms/#See-Also","page":"Isomorphisms","title":"See Also","text":"Trajectories - How isomorphisms are used in trajectories\nOperators - Working with quantum operators\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/problem-templates/composition/#composition","page":"Composing Templates","title":"Composing Templates","text":"Problem templates in Piccolo.jl are designed to be composable. You can chain them together to build sophisticated optimization pipelines that combine multiple capabilities.","category":"section"},{"location":"generated/problem-templates/composition/#Composition-Overview","page":"Composing Templates","title":"Composition Overview","text":"The templates form a hierarchy:\n\nBase Problems (create from trajectory):\n‚îú‚îÄ‚îÄ SmoothPulseProblem\n‚îú‚îÄ‚îÄ BangBangPulseProblem\n‚îî‚îÄ‚îÄ SplinePulseProblem\n        ‚îÇ\n        ‚ñº\nWrapper Problems (wrap existing problem):\n‚îú‚îÄ‚îÄ SamplingProblem (adds robustness)\n‚îî‚îÄ‚îÄ MinimumTimeProblem (adds time optimization)\n\nAny wrapper can wrap another wrapper, enabling combinations like:\n\nMinimumTimeProblem(SamplingProblem(SmoothPulseProblem(...)))\nMinimumTimeProblem(SplinePulseProblem(...))","category":"section"},{"location":"generated/problem-templates/composition/#Full-Pipeline-Example","page":"Composing Templates","title":"Full Pipeline Example","text":"Here's a complete pipeline: base optimization ‚Üí robust optimization ‚Üí time-optimal control.\n\nusing Piccolo","category":"section"},{"location":"generated/problem-templates/composition/#Step-1:-Setup","page":"Composing Templates","title":"Step 1: Setup","text":"# Define nominal system\nH_drift = 0.5 * PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys_nominal = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n# Create initial trajectory\nT, N = 20.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys_nominal, pulse, GATES[:X])","category":"section"},{"location":"generated/problem-templates/composition/#Step-2:-Base-Problem-(with-free-time-enabled)","page":"Composing Templates","title":"Step 2: Base Problem (with free time enabled)","text":"qcp_base = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    R = 1e-2,\n    Œît_bounds = (0.05, 0.5),  ## Required for MinimumTimeProblem\n)\ncached_solve!(qcp_base, \"composition_base\"; max_iter = 100)\n\nfidelity(qcp_base)\n\nsum(get_timesteps(get_trajectory(qcp_base)))","category":"section"},{"location":"generated/problem-templates/composition/#Step-3:-Add-Robustness","page":"Composing Templates","title":"Step 3: Add Robustness","text":"# Create perturbed systems (¬±5% drift variation)\nsys_high = QuantumSystem(1.05 * H_drift, H_drives, [1.0, 1.0])\nsys_low = QuantumSystem(0.95 * H_drift, H_drives, [1.0, 1.0])\n\nqcp_robust = SamplingProblem(qcp_base, [sys_nominal, sys_high, sys_low]; Q = 100.0)\ncached_solve!(qcp_robust, \"composition_robust\"; max_iter = 100)\n\nfidelity(qcp_robust)","category":"section"},{"location":"generated/problem-templates/composition/#Step-4:-Minimize-Time","page":"Composing Templates","title":"Step 4: Minimize Time","text":"qcp_mintime = MinimumTimeProblem(qcp_robust; final_fidelity = 0.95, D = 100.0)\ncached_solve!(qcp_mintime, \"composition_mintime\"; max_iter = 100)\n\nfidelity(qcp_mintime)\n\nsum(get_timesteps(get_trajectory(qcp_mintime)))","category":"section"},{"location":"generated/problem-templates/composition/#Common-Composition-Patterns","page":"Composing Templates","title":"Common Composition Patterns","text":"","category":"section"},{"location":"generated/problem-templates/composition/#Pattern-1:-Robust-Gate","page":"Composing Templates","title":"Pattern 1: Robust Gate","text":"Optimize for parameter uncertainty without time constraints.\n\nqcp_base = SmoothPulseProblem(qtraj, N; Q=100.0)\nsolve!(qcp_base)\n\nqcp_robust = SamplingProblem(qcp_base, systems)\nsolve!(qcp_robust)","category":"section"},{"location":"generated/problem-templates/composition/#Pattern-2:-Fast-Gate","page":"Composing Templates","title":"Pattern 2: Fast Gate","text":"Minimize time without robustness requirements.\n\nqcp_base = SmoothPulseProblem(qtraj, N; Q=100.0, Œît_bounds=(0.01, 0.5))\nsolve!(qcp_base)\n\nqcp_fast = MinimumTimeProblem(qcp_base; final_fidelity=0.99)\nsolve!(qcp_fast)","category":"section"},{"location":"generated/problem-templates/composition/#Pattern-3:-Fast-Robust-Gate","page":"Composing Templates","title":"Pattern 3: Fast + Robust Gate","text":"The full pipeline for production-quality gates.\n\nqcp_base = SmoothPulseProblem(qtraj, N; Q=100.0, Œît_bounds=(0.01, 0.5))\nsolve!(qcp_base)\n\nqcp_robust = SamplingProblem(qcp_base, systems)\nsolve!(qcp_robust)\n\nqcp_final = MinimumTimeProblem(qcp_robust; final_fidelity=0.95)\nsolve!(qcp_final)","category":"section"},{"location":"generated/problem-templates/composition/#Pattern-4:-Spline-Warm-Start-Pipeline","page":"Composing Templates","title":"Pattern 4: Spline Warm-Start Pipeline","text":"Start with smooth problem, refine with splines.\n\n# Initial optimization with piecewise constant\nqcp_smooth = SmoothPulseProblem(qtraj_smooth, N; Q=100.0)\nsolve!(qcp_smooth)\n\n# Extract optimized pulse and convert to spline\noptimized_pulse = get_pulse(qcp_smooth.qtraj)\nspline_pulse = CubicSplinePulse(optimized_pulse)\nqtraj_spline = UnitaryTrajectory(sys, spline_pulse, U_goal)\n\n# Refine with spline problem\nqcp_spline = SplinePulseProblem(qtraj_spline; Q=100.0)\nsolve!(qcp_spline; max_iter=50)  # Quick refinement","category":"section"},{"location":"generated/problem-templates/composition/#Iteration-and-Refinement","page":"Composing Templates","title":"Iteration and Refinement","text":"You can iteratively refine solutions:\n\n# First pass: coarse optimization\nqcp = SmoothPulseProblem(qtraj, 50; Q=10.0)\nsolve!(qcp; max_iter=50)\n\n# Second pass: increase resolution\n# ... resample to higher N ...\n\n# Third pass: tighten tolerances\nsolve!(qcp; max_iter=100, tol=1e-8)","category":"section"},{"location":"generated/problem-templates/composition/#Accessing-Results-Through-the-Chain","page":"Composing Templates","title":"Accessing Results Through the Chain","text":"Each wrapper preserves access to the underlying trajectory:\n\n# Access trajectory at any level\ntraj = get_trajectory(qcp_mintime)\nsys = get_system(qcp_mintime)\n\n# Fidelity evaluation uses the innermost trajectory type\nfid = fidelity(qcp_mintime)\n\n# Get optimized pulse\npulse = get_pulse(qcp_mintime.qtraj)","category":"section"},{"location":"generated/problem-templates/composition/#Order-Matters","page":"Composing Templates","title":"Order Matters","text":"The order of composition affects the optimization:\n\nMinimumTimeProblem(SamplingProblem(base)):\n\nFirst achieves robustness, then minimizes time\nTime minimization respects the robust solution\nGenerally preferred for production gates\n\nSamplingProblem(MinimumTimeProblem(base)):\n\nFirst minimizes time, then adds robustness\nMay require re-solving if time-optimal solution isn't robust\nLess common, but useful for exploring trade-offs","category":"section"},{"location":"generated/problem-templates/composition/#Tips-for-Complex-Pipelines","page":"Composing Templates","title":"Tips for Complex Pipelines","text":"","category":"section"},{"location":"generated/problem-templates/composition/#1.-Solve-Each-Stage","page":"Composing Templates","title":"1. Solve Each Stage","text":"Always solve! after each composition step:\n\nqcp_base = SmoothPulseProblem(qtraj, N)\nsolve!(qcp_base)  # Important!\n\nqcp_robust = SamplingProblem(qcp_base, systems)\nsolve!(qcp_robust)  # Important!\n\nqcp_mintime = MinimumTimeProblem(qcp_robust)\nsolve!(qcp_mintime)  # Important!","category":"section"},{"location":"generated/problem-templates/composition/#2.-Monitor-Progress","page":"Composing Templates","title":"2. Monitor Progress","text":"Check fidelity at each stage to catch issues early:\n\nfor (name, prob) in [(\"Base\", qcp_base), (\"Robust\", qcp_robust), (\"MinTime\", qcp_mintime)]\n    println(\"$name: Fidelity = $(fidelity(prob))\")\nend","category":"section"},{"location":"generated/problem-templates/composition/#3.-Adjust-Parameters-at-Each-Stage","page":"Composing Templates","title":"3. Adjust Parameters at Each Stage","text":"Different stages may need different settings:\n\n# Base: prioritize finding a solution\nqcp_base = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2)\nsolve!(qcp_base; max_iter=200)\n\n# Robust: may need more iterations\nqcp_robust = SamplingProblem(qcp_base, systems; Q=100.0)\nsolve!(qcp_robust; max_iter=300)\n\n# MinTime: typically faster since starting from good solution\nqcp_mintime = MinimumTimeProblem(qcp_robust; final_fidelity=0.95, D=100.0)\nsolve!(qcp_mintime; max_iter=100)","category":"section"},{"location":"generated/problem-templates/composition/#See-Also","page":"Composing Templates","title":"See Also","text":"SmoothPulseProblem - Base problem template\nBangBangPulseProblem - Bang-bang base problem\nSplinePulseProblem - Spline-based base problem\nMinimumTimeProblem - Time optimization wrapper\nSamplingProblem - Robustness wrapper\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/quickstart/#quickstart","page":"Quickstart","title":"Quickstart Guide","text":"This guide shows you how to set up and solve a quantum optimal control problem in Piccolo.jl. We'll synthesize a single-qubit X gate.","category":"section"},{"location":"generated/quickstart/#The-Problem","page":"Quickstart","title":"The Problem","text":"We want to find control pulses that implement an X gate on a single qubit with system Hamiltonian:\n\nH(t) = fracomega2 sigma_z + u_1(t) sigma_x + u_2(t) sigma_y\n\nusing Piccolo","category":"section"},{"location":"generated/quickstart/#Step-1:-Define-the-Quantum-System","page":"Quickstart","title":"Step 1: Define the Quantum System","text":"First, we define our quantum system by specifying the drift Hamiltonian (always-on), the drive Hamiltonians (controllable), and the bounds on control amplitudes.\n\n# Drift Hamiltonian: qubit frequency term\nH_drift = 0.5 * PAULIS[:Z]\n\n# Drive Hamiltonians: X and Y controls\nH_drives = [PAULIS[:X], PAULIS[:Y]]\n\n# Maximum control amplitudes\ndrive_bounds = [1.0, 1.0]\n\n# Create the quantum system\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)","category":"section"},{"location":"generated/quickstart/#Step-2:-Create-an-Initial-Pulse","page":"Quickstart","title":"Step 2: Create an Initial Pulse","text":"We need an initial guess for the control pulse. ZeroOrderPulse represents piecewise constant controls.\n\n# Time parameters\nT = 10.0   # Total gate duration\nN = 100    # Number of timesteps\n\n# Create time vector\ntimes = collect(range(0, T, length = N))\n\n# Random initial controls (scaled by drive bounds)\ninitial_controls = 0.1 * randn(2, N)\n\n# Create the pulse\npulse = ZeroOrderPulse(initial_controls, times)","category":"section"},{"location":"generated/quickstart/#Step-3:-Define-the-Goal-via-a-Trajectory","page":"Quickstart","title":"Step 3: Define the Goal via a Trajectory","text":"A UnitaryTrajectory combines the system, pulse, and target gate.\n\n# Target: X gate\nU_goal = GATES[:X]\n\n# Create the trajectory\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)","category":"section"},{"location":"generated/quickstart/#Step-4:-Set-Up-the-Optimization-Problem","page":"Quickstart","title":"Step 4: Set Up the Optimization Problem","text":"SmoothPulseProblem creates the optimization problem with:\n\nFidelity objective (weight Q)\nRegularization for smooth controls (weight R)\nDerivative bounds for control smoothness\n\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,       # Fidelity weight\n    R = 1e-2,        # Regularization weight\n    ddu_bound = 1.0,  # Control acceleration bound\n)","category":"section"},{"location":"generated/quickstart/#Step-5:-Solve!","page":"Quickstart","title":"Step 5: Solve!","text":"cached_solve!(qcp, \"quickstart\"; max_iter = 20, verbose = false, print_level = 1)","category":"section"},{"location":"generated/quickstart/#Step-6:-Analyze-Results","page":"Quickstart","title":"Step 6: Analyze Results","text":"After solving, we can check the fidelity and examine the optimized controls.\n\n# Check final fidelity\nfidelity(qcp)\n\nAccess the trajectory and check the final unitary:\n\ntraj = get_trajectory(qcp)\nU_final = iso_vec_to_operator(traj[:≈®‚Éó][:, end])\nround.(U_final, digits = 3)","category":"section"},{"location":"generated/quickstart/#Visualization","page":"Quickstart","title":"Visualization","text":"Piccolo provides specialized plotting functions for quantum trajectories:\n\nusing CairoMakie\n\n# Plot the unitary evolution (state populations over time)\nfig = plot_unitary_populations(traj)","category":"section"},{"location":"generated/quickstart/#Minimum-Time-Optimization","page":"Quickstart","title":"Minimum Time Optimization","text":"Now let's find the shortest gate duration that achieves 99% fidelity.\n\nFirst, we need to create a new problem with variable timesteps enabled:\n\n# Create problem with free-time optimization\nqcp_free = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    R = 1e-2,\n    ddu_bound = 1.0,\n    Œît_bounds = (0.01, 0.5),  # Enable variable timesteps\n)\ncached_solve!(\n    qcp_free,\n    \"quickstart_free_time\";\n    max_iter = 20,\n    verbose = false,\n    print_level = 1,\n)\n\n# Convert to minimum time problem\nqcp_mintime = MinimumTimeProblem(qcp_free; final_fidelity = 0.99)\ncached_solve!(\n    qcp_mintime,\n    \"quickstart_mintime\";\n    max_iter = 20,\n    verbose = false,\n    print_level = 1,\n)\n\nCompare durations:\n\ninitial_duration = sum(get_timesteps(get_trajectory(qcp_free)))\nminimum_duration = sum(get_timesteps(get_trajectory(qcp_mintime)))\n\ninitial_duration\n\nminimum_duration\n\nfidelity(qcp_mintime)\n\nPlot the time-optimal solution:\n\nfig_mintime = plot_unitary_populations(get_trajectory(qcp_mintime))","category":"section"},{"location":"generated/quickstart/#State-Preparation","page":"Quickstart","title":"State Preparation","text":"Instead of synthesizing a full unitary gate, you can prepare a specific quantum state using KetTrajectory:\n\nœà_init = ComplexF64[1.0, 0.0]  # |0‚ü©\nœà_goal = ComplexF64[0.0, 1.0]  # |1‚ü©\nqcp_state = SmoothPulseProblem(KetTrajectory(sys, pulse, œà_init, œà_goal), N)\ncached_solve!(\n    qcp_state,\n    \"quickstart_state\";\n    max_iter = 20,\n    verbose = false,\n    print_level = 1,\n)\nfidelity(qcp_state)","category":"section"},{"location":"generated/quickstart/#Robust-Control","page":"Quickstart","title":"Robust Control","text":"To optimize a pulse that works across parameter variations (e.g., uncertain qubit frequency), use SamplingProblem:\n\n# Perturbed systems: ¬±10% drift Hamiltonian\nsys_low = QuantumSystem(0.9 * H_drift, H_drives, drive_bounds)\nsys_high = QuantumSystem(1.1 * H_drift, H_drives, drive_bounds)\n\n# Start from a nominal solution, then add robustness\nqcp_robust = SamplingProblem(qcp, [sys_low, sys, sys_high])\ncached_solve!(\n    qcp_robust,\n    \"quickstart_robust\";\n    max_iter = 20,\n    verbose = false,\n    print_level = 1,\n)\nfidelity(qcp_robust)","category":"section"},{"location":"generated/quickstart/#Next-Steps","page":"Quickstart","title":"Next Steps","text":"See Concepts for the mathematical formulation\nLearn about different Problem Templates\nExplore Tutorials for more complex examples\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"","page":"Home","title":"Home","text":"<div align=\"center\">\n  <a href=\"https://github.com/harmoniqs/Piccolo.jl\">\n    <img src=\"assets/piccolo_logo_high_contrast.svg\" alt=\"Piccolo.jl\" width=\"45%\"/>\n  </a> \n</div>\n\n<div align=\"center\">\n  <table>\n    <tr>\n      <td align=\"center\">\n        <b>Documentation</b>\n        <br>\n        <a href=\"https://docs.harmoniqs.co/Piccolo/dev/\">\n          <img src=\"https://img.shields.io/badge/docs-stable-blue.svg\" alt=\"Stable\"/>\n        </a>\n        <a href=\"https://docs.harmoniqs.co/Piccolo/dev/\">\n          <img src=\"https://img.shields.io/badge/docs-dev-blue.svg\" alt=\"Dev\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Build Status</b>\n        <br>\n        <a href=\"https://github.com/harmoniqs/Piccolo.jl/actions/workflows/CI.yml?query=branch%3Amain\">\n          <img src=\"https://github.com/harmoniqs/Piccolo.jl/actions/workflows/CI.yml/badge.svg?branch=main\" alt=\"Build Status\"/>\n        </a>\n        <a href=\"https://codecov.io/gh/harmoniqs/Piccolo.jl\">\n          <img src=\"https://codecov.io/gh/harmoniqs/Piccolo.jl/branch/main/graph/badge.svg\" alt=\"Coverage\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>License</b>\n        <br>\n        <a href=\"https://opensource.org/licenses/MIT\">\n          <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"MIT License\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Support</b>\n        <br>\n        <a href=\"https://unitary.fund\">\n          <img src=\"https://img.shields.io/badge/Supported%20By-Unitary%20Fund-FFFF00.svg\" alt=\"Unitary Fund\"/>\n        </a>\n      </td>\n    </tr>\n  </table>\n</div>","category":"section"},{"location":"#Description","page":"Home","title":"Description","text":"Piccolo.jl is a meta-package for quantum optimal control using the Pade Integrator Collocation (Piccolo) method. This package reexports the following packages\n\nDirectTrajOpt.jl\nNamedTrajectories.jl\nTrajectoryIndexingUtils.jl\n\nFor documentation please see the individual packages.","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"Just run\n\nusing Piccolo","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"This package is registered! To install enter the Julia REPL, type ] to enter pkg mode, activate your environment activate, and then run \n\npkg> add Piccolo","category":"section"},{"location":"#Building-Documentation","page":"Home","title":"Building Documentation","text":"This package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility. \n\n# first time only\n./docs/get_docs_utils.sh   # or ./get_docs_utils.sh if cwd is in ./docs/\n\nTo build the docs pages:\n\njulia --project=docs docs/make.jl\n\nor editing the docs live:\n\njulia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"], skip_files=[\"docs/src/index.md\"])\n\nNote: servedocs needs to watch a subset of the files in the docs/ folder. If it watches files that are generated on a docs build/re-build, servedocs will continuously try to re-serve the pages.To prevent this, ensure all generated files are included in the skip dirs or skip files args for servedocs.\n\nFor example, if we forget index.md like so:\n\njulia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"])\n\nit will not build and serve.\n\n","category":"section"},{"location":"#Star-History","page":"Home","title":"Star History","text":"(Image: Star History Chart)\n\n\"Technologies are ways of commandeering nature: the sky belongs to those who know how to fly; the sea belongs to those who know how to swim and navigate.\" ‚Äì Simone de Beauvoir","category":"section"},{"location":"generated/problem-templates/sampling/#sampling","page":"SamplingProblem","title":"SamplingProblem","text":"SamplingProblem enables robust optimization over multiple system variants with shared controls. This is essential for designing pulses that perform well despite parameter uncertainty or variation.","category":"section"},{"location":"generated/problem-templates/sampling/#When-to-Use","page":"SamplingProblem","title":"When to Use","text":"Use SamplingProblem when:\n\nYour system parameters have uncertainty (e.g., qubit frequency drift)\nYou need pulses robust to fabrication variations\nYou want to optimize across an ensemble of similar systems\nYou're designing calibration-free gates","category":"section"},{"location":"generated/problem-templates/sampling/#Key-Design:-Composition-Pattern","page":"SamplingProblem","title":"Key Design: Composition Pattern","text":"SamplingProblem wraps an existing QuantumControlProblem and extends it with multiple system variants:\n\n# Create base problem\nqcp_base = SmoothPulseProblem(qtraj, N; Q=100.0)\nsolve!(qcp_base; max_iter=100)\n\n# Create perturbed systems\nsys_nominal = get_system(qcp_base)\nsys_high = QuantumSystem(1.05 * H_drift, H_drives, drive_bounds)\nsys_low = QuantumSystem(0.95 * H_drift, H_drives, drive_bounds)\n\n# Robust optimization\nqcp_robust = SamplingProblem(qcp_base, [sys_nominal, sys_high, sys_low])\nsolve!(qcp_robust; max_iter=100)","category":"section"},{"location":"generated/problem-templates/sampling/#Constructor","page":"SamplingProblem","title":"Constructor","text":"SamplingProblem(\n    qcp::QuantumControlProblem,\n    systems::Vector{<:AbstractQuantumSystem};\n    weights = fill(1.0, length(systems)),\n    Q = 100.0,\n    piccolo_options = PiccoloOptions()\n)","category":"section"},{"location":"generated/problem-templates/sampling/#Parameter-Reference","page":"SamplingProblem","title":"Parameter Reference","text":"Parameter Type Default Description\nqcp QuantumControlProblem required Base problem providing trajectory structure\nsystems Vector{AbstractQuantumSystem} required System variants to optimize over\nweights Vector{Float64} fill(1.0, length(systems)) Relative importance of each system\nQ Float64 100.0 Infidelity weight (applied to all systems)\npiccolo_options PiccoloOptions PiccoloOptions() Solver options","category":"section"},{"location":"generated/problem-templates/sampling/#Optimization-Objective","page":"SamplingProblem","title":"Optimization Objective","text":"SamplingProblem creates a weighted sum of objectives:\n\nminimize: Œ£·µ¢ w·µ¢ √ó Q·µ¢ √ó (1 - F·µ¢) + regularization\n\nWhere:\n\nw·µ¢ is the weight for system i\nQ·µ¢ is the infidelity weight\nF·µ¢ is the fidelity for system i\n\nAll systems share the same control pulse, but each has its own state trajectory.","category":"section"},{"location":"generated/problem-templates/sampling/#Examples","page":"SamplingProblem","title":"Examples","text":"","category":"section"},{"location":"generated/problem-templates/sampling/#Robust-to-Frequency-Drift","page":"SamplingProblem","title":"Robust to Frequency Drift","text":"using Piccolo\n\n# Nominal system\nH_drift = 0.5 * PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys_nominal = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n# Create trajectory and base problem\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys_nominal, pulse, GATES[:X])\n\nqcp_base = SmoothPulseProblem(qtraj, N; Q = 100.0)\ncached_solve!(qcp_base, \"sampling_base\"; max_iter = 100)\n\n# ¬±5% frequency variation\nsys_high = QuantumSystem(1.05 * H_drift, H_drives, [1.0, 1.0])\nsys_low = QuantumSystem(0.95 * H_drift, H_drives, [1.0, 1.0])\n\n# Robust optimization\nqcp_robust =\n    SamplingProblem(qcp_base, [sys_nominal, sys_high, sys_low]; weights = [1.0, 1.0, 1.0])\ncached_solve!(qcp_robust, \"sampling_robust\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/sampling/#Weighted-Sampling","page":"SamplingProblem","title":"Weighted Sampling","text":"Prioritize certain parameter values:\n\nqcp_weighted = SamplingProblem(\n    qcp_base,\n    [sys_nominal, sys_high, sys_low];\n    weights = [2.0, 1.0, 1.0],  ## Nominal weighted 2x\n)\ncached_solve!(qcp_weighted, \"sampling_weighted\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/sampling/#Dense-Parameter-Sampling","page":"SamplingProblem","title":"Dense Parameter Sampling","text":"For smooth performance across a parameter range:\n\nscales = range(0.9, 1.1, length = 3)\nsystems = [QuantumSystem(s * H_drift, H_drives, [1.0, 1.0]) for s in scales]\n\nqcp_dense = SamplingProblem(qcp_base, systems)\ncached_solve!(qcp_dense, \"sampling_dense\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/sampling/#With-Time-Optimization","page":"SamplingProblem","title":"With Time Optimization","text":"Chain with MinimumTimeProblem:\n\n# Base problem with free time\nqcp_base = SmoothPulseProblem(qtraj, N; Q=100.0, Œît_bounds=(0.05, 0.5))\nsolve!(qcp_base; max_iter=100)\n\n# Add robustness\nqcp_robust = SamplingProblem(qcp_base, [sys_nominal, sys_high, sys_low])\nsolve!(qcp_robust; max_iter=100)\n\n# Minimize time\nqcp_mintime = MinimumTimeProblem(qcp_robust; final_fidelity=0.95)\nsolve!(qcp_mintime; max_iter=100)","category":"section"},{"location":"generated/problem-templates/sampling/#Trajectory-Structure","page":"SamplingProblem","title":"Trajectory Structure","text":"SamplingProblem creates a SamplingTrajectory internally with:\n\nVariable Description\n:u Shared control values\n:≈®‚Éó1, :≈®‚Éó2, ... State for each system (unitary case)\nor :œàÃÉ1, :œàÃÉ2, ... State for each system (ket case)\n\nNote: Derivative variables (:du, :ddu) from the base problem are not carried over. The robustness is achieved through multiple dynamics integrators, one per system.","category":"section"},{"location":"generated/problem-templates/sampling/#Difference-from-MultiKetTrajectory","page":"SamplingProblem","title":"Difference from MultiKetTrajectory","text":"These serve different purposes:\n\nFeature SamplingProblem MultiKetTrajectory\nSystems Multiple different systems Single system\nStates Same goal across systems Different initial/goal pairs\nUse case Parameter uncertainty Multi-state gates\n\nSamplingProblem: \"Same gate, different systems\" MultiKetTrajectory: \"Same system, different state transfers\"","category":"section"},{"location":"generated/problem-templates/sampling/#Evaluating-Robustness","page":"SamplingProblem","title":"Evaluating Robustness","text":"After solving, check fidelity across the parameter range:\n\n# Sample more densely for evaluation\neval_scales = range(0.8, 1.2, length=21)\neval_systems = [QuantumSystem(s * H_drift, H_drives, drive_bounds) for s in eval_scales]\n\n# Get optimized pulse\noptimized_pulse = get_pulse(qcp_robust.qtraj)\n\n# Evaluate\nfor (s, sys) in zip(eval_scales, eval_systems)\n    qtraj_eval = UnitaryTrajectory(sys, optimized_pulse, GATES[:X])\n    fid = fidelity(qtraj_eval)\n    println(\"Scale $s: Fidelity = $fid\")\nend","category":"section"},{"location":"generated/problem-templates/sampling/#See-Also","page":"SamplingProblem","title":"See Also","text":"SmoothPulseProblem - Base problem for piecewise constant controls\nBangBangPulseProblem - Base problem for bang-bang controls\nMinimumTimeProblem - Minimize duration of robust pulses\nComposing Templates - Advanced composition patterns\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/guides/custom_objectives/#custom-objectives","page":"Custom Objectives","title":"Custom Objectives","text":"While Piccolo.jl provides standard objectives for fidelity and regularization, you may need custom objectives for specialized optimization goals. This guide shows how to create and use them.","category":"section"},{"location":"generated/guides/custom_objectives/#Setup","page":"Custom Objectives","title":"Setup","text":"We'll work with a simple single-qubit X gate problem:\n\nusing Piccolo\nusing LinearAlgebra\nusing Random\nRandom.seed!(42)\n\n# Define system\nH_drift = 0.5 * PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\ndrive_bounds = [1.0, 1.0]\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\n\n# Create initial pulse and trajectory\nT = 10.0\nN = 50\ntimes = collect(range(0, T, length = N))\ninitial_controls = 0.1 * randn(2, N)\npulse = ZeroOrderPulse(initial_controls, times)\n\nU_goal = GATES[:X]\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)","category":"section"},{"location":"generated/guides/custom_objectives/#Objective-Types","page":"Custom Objectives","title":"Objective Types","text":"Piccolo uses two objective types from DirectTrajOpt.jl:\n\nType When Evaluated Constructor\nTerminalObjective At final timestep only TerminalObjective(loss, name, traj; Q=weight)\nKnotPointObjective At specified timesteps KnotPointObjective(loss, name, traj; Qs=weights)\n\nBoth take a loss function as their first argument ‚Äî a regular Julia function that maps a component vector to a scalar cost.","category":"section"},{"location":"generated/guides/custom_objectives/#Creating-a-Custom-Terminal-Objective","page":"Custom Objectives","title":"Creating a Custom Terminal Objective","text":"A terminal objective evaluates a loss function on a trajectory component at the final timestep. Let's create one that penalizes trace distance from the target:\n\n# Build the problem to get the internal NamedTrajectory\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0, R = 1e-2, ddu_bound = 1.0)\ntraj = get_trajectory(qcp)\n\n# Define a custom loss: trace distance penalty on the isomorphic unitary vector\ntrace_distance_loss(≈®‚Éó) =\n    let\n        U = iso_vec_to_operator(≈®‚Éó)\n        n = size(U, 1)\n        diff = U - U_goal\n        real(tr(diff' * diff)) / n\n    end\n\n# Wrap it in a TerminalObjective (evaluated on :≈®‚Éó at the final timestep)\ncustom_terminal_obj = TerminalObjective(trace_distance_loss, :≈®‚Éó, traj; Q = 50.0)","category":"section"},{"location":"generated/guides/custom_objectives/#Creating-a-Custom-Knotpoint-Objective","page":"Custom Objectives","title":"Creating a Custom Knotpoint Objective","text":"A knotpoint objective evaluates at every (or selected) timesteps. Let's penalize control energy:\n\n# Loss function: squared norm of control values\ncontrol_energy_loss(u) = dot(u, u)\n\n# Applied at all timesteps on the :u component\ncustom_knotpoint_obj =\n    KnotPointObjective(control_energy_loss, :u, traj; Qs = fill(0.1, N), times = 1:N)","category":"section"},{"location":"generated/guides/custom_objectives/#Adding-Custom-Objectives-to-a-Problem","page":"Custom Objectives","title":"Adding Custom Objectives to a Problem","text":"","category":"section"},{"location":"generated/guides/custom_objectives/#Building-the-objective-manually","page":"Custom Objectives","title":"Building the objective manually","text":"Combine objective terms with +:\n\n# Start with the standard infidelity objective\nJ = UnitaryInfidelityObjective(U_goal, :≈®‚Éó, traj; Q = 100.0)\n\n# Add standard regularization\nJ += QuadraticRegularizer(:u, traj, 1e-2)\nJ += QuadraticRegularizer(:du, traj, 1e-2)\nJ += QuadraticRegularizer(:ddu, traj, 1e-2)\n\n# Add our custom objective\nJ += custom_knotpoint_obj\n\ntypeof(J)","category":"section"},{"location":"generated/guides/custom_objectives/#Adding-to-an-existing-problem","page":"Custom Objectives","title":"Adding to an existing problem","text":"qcp = SmoothPulseProblem(qtraj, N; Q = 100.0, R = 1e-2, ddu_bound = 1.0)\nqcp.prob.objective += custom_knotpoint_obj","category":"section"},{"location":"generated/guides/custom_objectives/#Solving-and-Comparing","page":"Custom Objectives","title":"Solving and Comparing","text":"Solve with the extra control energy penalty:\n\ncached_solve!(\n    qcp,\n    \"custom_objectives_with_penalty\";\n    max_iter = 50,\n    verbose = false,\n    print_level = 1,\n)\nfidelity(qcp)\n\nCompare against the standard problem:\n\nqcp_standard = SmoothPulseProblem(qtraj, N; Q = 100.0, R = 1e-2, ddu_bound = 1.0)\ncached_solve!(\n    qcp_standard,\n    \"custom_objectives_standard\";\n    max_iter = 50,\n    verbose = false,\n    print_level = 1,\n)\nfidelity(qcp_standard)","category":"section"},{"location":"generated/guides/custom_objectives/#Example:-Leakage-Style-Penalty","page":"Custom Objectives","title":"Example: Leakage-Style Penalty","text":"Here's how the built-in LeakageObjective works under the hood ‚Äî it's just a KnotPointObjective with a custom loss function:\n\nleakage_indices = [3, 4]  # Indices of leakage states in the isomorphic vector\n\nleakage_loss(x) = sum(abs2, x[leakage_indices]) / length(leakage_indices)\n\nleakage_obj = KnotPointObjective(leakage_loss, :≈®‚Éó, traj; Qs = fill(1.0, N), times = 1:N)","category":"section"},{"location":"generated/guides/custom_objectives/#Tips-for-Custom-Objectives","page":"Custom Objectives","title":"Tips for Custom Objectives","text":"","category":"section"},{"location":"generated/guides/custom_objectives/#1.-Scale-Appropriately","page":"Custom Objectives","title":"1. Scale Appropriately","text":"Match the scale of built-in objectives:\n\nBuilt-in fidelity uses Q ~ 100\nCustom objectives should use similar magnitude\n\ncustom_obj = TerminalObjective(my_loss, :≈®‚Éó, traj; Q = 50.0)","category":"section"},{"location":"generated/guides/custom_objectives/#2.-Ensure-Smoothness","page":"Custom Objectives","title":"2. Ensure Smoothness","text":"Avoid discontinuities that can cause optimization issues:\n\n## Bad: discontinuous\npenalty = x > 0 ? x^2 : 0\n\n## Good: smooth approximation\npenalty = max(0, x)^2\n\n## Also good: softplus\npenalty = log(1 + exp(k * x)) / k","category":"section"},{"location":"generated/guides/custom_objectives/#3.-Test-Independently","page":"Custom Objectives","title":"3. Test Independently","text":"Verify your objective computes expected values:\n\n## Evaluate the full objective on a trajectory\nvalue = objective_value(custom_obj, traj)\nprintln(\"Objective value: \", value)\n\n## Check gradient\n‚àá = zeros(traj.dim * traj.N + traj.global_dim)\ngradient!(‚àá, custom_obj, traj)","category":"section"},{"location":"generated/guides/custom_objectives/#4.-Start-Simple","page":"Custom Objectives","title":"4. Start Simple","text":"Add custom objectives incrementally:\n\n## Step 1: Solve with standard objectives\nqcp = SmoothPulseProblem(qtraj, N)\nsolve!(qcp)\n\n## Step 2: Check if solution needs improvement\nprintln(\"Fidelity: \", fidelity(qcp))\n\n## Step 3: Add custom objective with small weight\ncustom_obj = KnotPointObjective(my_loss, :u, traj; Qs = fill(0.1, N))\nqcp.prob.objective += custom_obj\nsolve!(qcp)\n\n## Step 4: Increase weight if needed","category":"section"},{"location":"generated/guides/custom_objectives/#5.-Gradients-are-Automatic","page":"Custom Objectives","title":"5. Gradients are Automatic","text":"DirectTrajOpt uses ForwardDiff for automatic differentiation, so gradients are computed automatically for any loss function you provide. No need to implement gradient methods manually.","category":"section"},{"location":"generated/guides/custom_objectives/#See-Also","page":"Custom Objectives","title":"See Also","text":"Objectives - Built-in objectives\nConstraints - Hard constraints (vs soft objective penalties)\nProblem Templates - Using objectives in problems\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/systems/silicon_spins/#silicon-spin-systems","page":"Silicon Spins","title":"Silicon Spins","text":"Silicon spin qubits use electron or hole spins in semiconductor quantum dots for quantum information processing.  Exchange-only (EO) qubits encode a logical qubit in three electron spins, using only exchange interactions (controlled by gate voltages) for universal single-qubit control.\n\nnote: Coming Soon\nThe SiliconSpinSystem template is under development.  The Hamiltonian and API below describe the planned implementation.","category":"section"},{"location":"generated/systems/silicon_spins/#Exchange-Only-Qubit","page":"Silicon Spins","title":"Exchange-Only Qubit","text":"","category":"section"},{"location":"generated/systems/silicon_spins/#Hamiltonian","page":"Silicon Spins","title":"Hamiltonian","text":"Three electron spins in a triple quantum dot with pairwise Heisenberg exchange:\n\nH = J_12(epsilon) boldsymbolS_1 cdot boldsymbolS_2\n    + J_23(epsilon) boldsymbolS_2 cdot boldsymbolS_3\n\nwhere J_ij(epsilon) are the exchange couplings controlled by detuning voltages epsilon.  In the S = 12 subspace (total spin S_texttot = 12), this gives a logical qubit with two states:\n\n0_Lrangle = S_12rangleuparrowrangle qquad\n1_Lrangle = sqrttfrac13T_12rangledownarrowrangle\n    - sqrttfrac23T_12^0rangleuparrowrangle\n\nwhere S_12rangle and T_12rangle are singlet and triplet states of the first two spins.","category":"section"},{"location":"generated/systems/silicon_spins/#Projected-Hamiltonian","page":"Silicon Spins","title":"Projected Hamiltonian","text":"Projecting into the logical subspace, the effective Hamiltonian is:\n\nH_texteff = fracJ_12 + J_234 I\n    + fracJ_12 - J_234 sigma_z\n    + fracsqrt34 J_23 sigma_x\n\nThe exchange couplings J_12 and J_23 serve as control parameters, providing full single-qubit control via sigma_x and sigma_z rotations.","category":"section"},{"location":"generated/systems/silicon_spins/#Two-Exchange-Only-Qubits","page":"Silicon Spins","title":"Two Exchange-Only Qubits","text":"For two EO qubits (six electrons in six dots), the coupling between logical qubits arises from exchange between the adjacent dots of each triple:\n\nH = H_textEO1 + H_textEO2 + J_36 boldsymbolS_3 cdot boldsymbolS_4\n\nwhere J_36 is the inter-qubit exchange coupling (between dot 3 of qubit 1 and dot 4 of qubit 2).","category":"section"},{"location":"generated/systems/silicon_spins/#Planned-API","page":"Silicon Spins","title":"Planned API","text":"# Single EO qubit\nsys = ExchangeOnlyQubit(\n    J12_bounds = (0.0, 10.0),   # Exchange coupling range (GHz)\n    J23_bounds = (0.0, 10.0),\n)\n\n# Two coupled EO qubits\nsys = TwoExchangeOnlyQubits(\n    J12_bounds = (0.0, 10.0),\n    J23_bounds = (0.0, 10.0),\n    J45_bounds = (0.0, 10.0),\n    J56_bounds = (0.0, 10.0),\n    J34_bounds = (0.0, 5.0),    # Inter-qubit coupling\n)","category":"section"},{"location":"generated/systems/silicon_spins/#Typical-Parameters","page":"Silicon Spins","title":"Typical Parameters","text":"Parameter Typical Value Unit\nExchange J 0.1‚Äì10 GHz\nGate time 1‚Äì100 ns\nT_2^* (dephasing) 1‚Äì10 Œºs\nT_1 (relaxation) 0.1‚Äì10 ms","category":"section"},{"location":"generated/systems/silicon_spins/#References","page":"Silicon Spins","title":"References","text":"DiVincenzo et al., \"Universal quantum computation with the exchange interaction,\" Nature 408, 339 (2000)\nWeinstein et al., \"Universal logic with encoded spin qubits in silicon,\" Nature 615, 817 (2023)","category":"section"},{"location":"generated/systems/silicon_spins/#See-Also","page":"Silicon Spins","title":"See Also","text":"Quantum Systems Overview ‚Äî General system API\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/concepts/pulses/#pulses-concept","page":"Pulses","title":"Pulses","text":"Pulses parameterize how control amplitudes boldsymbolu(t) vary over time.  The choice of pulse type determines both the NLP structure and the smoothness class of the resulting controls.","category":"section"},{"location":"generated/concepts/pulses/#Overview","page":"Pulses","title":"Overview","text":"Pulse Type Continuity Decision Variables Use With\nZeroOrderPulse C^-1 (piecewise constant) boldsymbolu_k SmoothPulseProblem\nLinearSplinePulse C^0 boldsymbolu_k (knot values) SplinePulseProblem\nCubicSplinePulse C^1 boldsymbolu_k dotboldsymbolu_k (values + tangents) SplinePulseProblem\nGaussianPulse C^infty A_i sigma_i mu_i (parametric) Analytical\nCompositePulse varies union of sub-pulse variables Various","category":"section"},{"location":"generated/concepts/pulses/#ZeroOrderPulse","page":"Pulses","title":"ZeroOrderPulse","text":"Piecewise constant (zero-order hold) controls ‚Äî the most common choice. On the interval t_k t_k+1), the control is constant:\n\nboldsymbolu(t) = boldsymbolu_k qquad t in t_k t_k+1)\n\nSmoothness is enforced indirectly via regularization of the discrete differences Deltaboldsymbolu_k and Delta^2boldsymbolu_k (see Objectives).","category":"section"},{"location":"generated/concepts/pulses/#Construction","page":"Pulses","title":"Construction","text":"using Piccolo\n\nn_dr = 2\nN = 100\nT = 10.0\n\n# Time points\ntimes = collect(range(0, T, length = N))\n\n# Control values: n_drives √ó N matrix\ncontrols = 0.1 * randn(n_dr, N)\n\npulse_zop = ZeroOrderPulse(controls, times)","category":"section"},{"location":"generated/concepts/pulses/#Properties","page":"Pulses","title":"Properties","text":"# Evaluate at time t\nu = pulse_zop(T / 2)\nu\n\n# Duration\nduration(pulse_zop)\n\n# Number of drives\nn_drives(pulse_zop)","category":"section"},{"location":"generated/concepts/pulses/#Visualization","page":"Pulses","title":"Visualization","text":"Control Value\n    ‚îÇ    ‚îå‚îÄ‚îÄ‚îê\n    ‚îÇ    ‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îê\n    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ\n    ‚îÇ       ‚îî‚îÄ‚îÄ‚îò\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Time","category":"section"},{"location":"generated/concepts/pulses/#Use-Case","page":"Pulses","title":"Use Case","text":"Primary use: SmoothPulseProblem\nCharacteristics: Simple structure, smoothness via derivative regularization\nBest for: Initial optimization, most quantum control problems","category":"section"},{"location":"generated/concepts/pulses/#LinearSplinePulse","page":"Pulses","title":"LinearSplinePulse","text":"Linear interpolation between knot values.  On t_k t_k+1:\n\nboldsymbolu(t) = boldsymbolu_k + fract - t_kt_k+1 - t_k(boldsymbolu_k+1 - boldsymbolu_k)\n\nThis gives C^0 continuity (continuous values, discontinuous first derivative at knots).","category":"section"},{"location":"generated/concepts/pulses/#Construction-2","page":"Pulses","title":"Construction","text":"pulse_linear = LinearSplinePulse(controls, times)","category":"section"},{"location":"generated/concepts/pulses/#Properties-2","page":"Pulses","title":"Properties","text":"Continuous control values\nDiscontinuous first derivative (at knots)\nDerivative = slope between knots\n\nu_linear = pulse_linear(T / 2)\nu_linear","category":"section"},{"location":"generated/concepts/pulses/#Visualization-2","page":"Pulses","title":"Visualization","text":"Control Value\n    ‚îÇ      /\\\n    ‚îÇ     /  \\    /\n    ‚îÇ    /    \\  /\n    ‚îÇ‚îÄ‚îÄ‚îÄ/      \\/\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Time","category":"section"},{"location":"generated/concepts/pulses/#CubicSplinePulse","page":"Pulses","title":"CubicSplinePulse","text":"Cubic Hermite spline interpolation with independent tangents dotboldsymbolu_k at each knot.  The Hermite basis gives C^1 continuity (continuous values and first derivatives).\n\nOn t_k t_k+1 with s = (t - t_k)  (t_k+1 - t_k) in 0 1 and h = t_k+1 - t_k:\n\nboldsymbolu(t) = (2s^3 - 3s^2 + 1)boldsymbolu_k\n+ (s^3 - 2s^2 + s)hdotboldsymbolu_k\n+ (-2s^3 + 3s^2)boldsymbolu_k+1\n+ (s^3 - s^2)hdotboldsymbolu_k+1\n\nBoth boldsymbolu_k and dotboldsymbolu_k are decision variables in SplinePulseProblem.","category":"section"},{"location":"generated/concepts/pulses/#Construction-3","page":"Pulses","title":"Construction","text":"tangents = zeros(n_dr, N)  # Initial tangents (slopes)\npulse_cubic = CubicSplinePulse(controls, tangents, times)","category":"section"},{"location":"generated/concepts/pulses/#Properties-3","page":"Pulses","title":"Properties","text":"Continuous control values AND first derivatives\nTangents are independent optimization variables\nSmooth C¬π continuous curves\n\nu_cubic = pulse_cubic(T / 2)\nu_cubic","category":"section"},{"location":"generated/concepts/pulses/#GaussianPulse","page":"Pulses","title":"GaussianPulse","text":"Parametric Gaussian envelope:\n\nu_i(t) = A_i expleft(-frac(t - mu_i)^22sigma_i^2right)\n\nUseful for analytical pulse design and warm-starting.","category":"section"},{"location":"generated/concepts/pulses/#Construction-4","page":"Pulses","title":"Construction","text":"amplitudes = [0.5, 0.3]\nsigmas = [1.0, 1.5]\ncenters = [5.0, 5.0]\n\npulse_gauss = GaussianPulse(amplitudes, sigmas, centers, T)\n\nu_gauss = pulse_gauss(5.0)\nu_gauss","category":"section"},{"location":"generated/concepts/pulses/#CompositePulse","page":"Pulses","title":"CompositePulse","text":"Combine multiple pulses (e.g., different drives from different sources):\n\npulse1 = GaussianPulse([0.5], [0.5], [2.0], T)\npulse2 = GaussianPulse([0.3], [0.5], [8.0], T)\n\ncomposite = CompositePulse([pulse1, pulse2])\nn_drives(composite)","category":"section"},{"location":"generated/concepts/pulses/#Choosing-a-Pulse-Type","page":"Pulses","title":"Choosing a Pulse Type","text":"Scenario Recommended Pulse Smoothness\nStarting fresh ZeroOrderPulse + SmoothPulseProblem C^-1 (regularized)\nRefining a solution CubicSplinePulse + SplinePulseProblem C^1\nHardware requires smooth pulses CubicSplinePulse C^1\nSimple continuous pulses LinearSplinePulse C^0\nAnalytical pulse design GaussianPulse C^infty","category":"section"},{"location":"generated/concepts/pulses/#Converting-Between-Pulse-Types","page":"Pulses","title":"Converting Between Pulse Types","text":"","category":"section"},{"location":"generated/concepts/pulses/#ZeroOrderPulse-CubicSplinePulse","page":"Pulses","title":"ZeroOrderPulse ‚Üí CubicSplinePulse","text":"# Sample control values from the zero-order pulse\nctrl = hcat([pulse_zop(t) for t in times]...)\n\n# Estimate tangents (finite differences)\ntgts = similar(ctrl)\nfor k = 1:(N-1)\n    tgts[:, k] = (ctrl[:, k+1] - ctrl[:, k]) / (times[k+1] - times[k])\nend\ntgts[:, N] = tgts[:, N-1]\n\n# Create cubic spline\ncubic_from_zop = CubicSplinePulse(ctrl, tgts, times)\nduration(cubic_from_zop)","category":"section"},{"location":"generated/concepts/pulses/#Arbitrary-ZeroOrderPulse","page":"Pulses","title":"Arbitrary ‚Üí ZeroOrderPulse","text":"# Sample any pulse type to create a ZeroOrderPulse\nnew_times = collect(range(0, T, length = 200))\nnew_ctrl = hcat([pulse_cubic(t) for t in new_times]...)\nresampled = ZeroOrderPulse(new_ctrl, new_times)\nlength(new_times)","category":"section"},{"location":"generated/concepts/pulses/#Best-Practices","page":"Pulses","title":"Best Practices","text":"","category":"section"},{"location":"generated/concepts/pulses/#1.-Initialize-Appropriately","page":"Pulses","title":"1. Initialize Appropriately","text":"max_amp = 0.1 * maximum(drive_bounds)\ncontrols = max_amp * randn(n_drives, N)","category":"section"},{"location":"generated/concepts/pulses/#2.-Use-Enough-Time-Points","page":"Pulses","title":"2. Use Enough Time Points","text":"# Rule of thumb: ~10 points per characteristic time scale\nT = 10.0  # Total time\nœÑ = 1.0   # Shortest feature you want to capture\nN = ceil(Int, 10 * T / œÑ)","category":"section"},{"location":"generated/concepts/pulses/#3.-Start-with-ZeroOrderPulse","page":"Pulses","title":"3. Start with ZeroOrderPulse","text":"Even if you need smooth pulses, optimize with ZeroOrderPulse first, then convert to CubicSplinePulse for refinement.","category":"section"},{"location":"generated/concepts/pulses/#See-Also","page":"Pulses","title":"See Also","text":"SmoothPulseProblem - Using ZeroOrderPulse\nSplinePulseProblem - Using spline pulses\nTrajectories - Combining pulses with systems\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/systems/rydberg_atoms/#rydberg-atom-systems","page":"Rydberg Atoms","title":"Rydberg Atoms","text":"Rydberg atom arrays use highly excited atomic states with strong van der Waals interactions to implement quantum gates and many-body simulations.  The atoms are individually trapped (e.g., in optical tweezers) with global laser drives.","category":"section"},{"location":"generated/systems/rydberg_atoms/#Hamiltonian","page":"Rydberg Atoms","title":"Hamiltonian","text":"For N atoms in a 1D chain with spacing d, the Rydberg Hamiltonian in the spin basis grangle = 0rangle, rrangle = 1rangle is:\n\nH = fracOmega(t)2 sum_i sigma_i^x\n    - Delta(t) sum_i n_i\n    + sum_i  j fracC_6r_i - r_j^6 n_i n_j\n\nwhere:\n\nOmega(t) is the global Rabi frequency (laser drive)\nDelta(t) is the global detuning\nn_i = rranglelangle r_i is the Rydberg population operator\nC_6 is the van der Waals coefficient (approx 862690 times 2pi MHz¬∑Œºm^6 for rubidium)\n\nThe interaction C_6  r_i - r_j^6 gives rise to the Rydberg blockade: within the blockade radius r_b = (C_6  Omega)^16, double excitation is energetically forbidden.\n\nIf the Y drive is included (ignore_Y_drive = false), an additional term fracOmega_y(t)2 sum_i sigma_i^y appears, enabling full phase control of the drive.","category":"section"},{"location":"generated/systems/rydberg_atoms/#Construction","page":"Rydberg Atoms","title":"Construction","text":"using Piccolo\n\nsys_rydberg = RydbergChainSystem(\n    N = 3,                     # Number of atoms\n    C = 862690 * 2œÄ,           # van der Waals coefficient (MHz¬∑Œºm‚Å∂)\n    distance = 8.7,            # Atom spacing (Œºm)\n    cutoff_order = 1,          # 1 = nearest-neighbor only\n    drive_bounds = [1.0, 1.0, 1.0],  # [Œ©x, Œ©y, Œî]\n)\nsys_rydberg.levels, sys_rydberg.n_drives\n\nThe Hilbert space is (mathbbC^2)^otimes N with dimension 2^N.","category":"section"},{"location":"generated/systems/rydberg_atoms/#Parameters","page":"Rydberg Atoms","title":"Parameters","text":"Parameter Default Description\nN 3 Number of atoms\nC 862690 times 2pi Van der Waals coefficient (MHz¬∑Œºm^6)\ndistance 8.7 Atom spacing (Œºm)\ncutoff_order 1 Interaction range (1 = nearest neighbor, 2 = next-nearest)\nall2all true Include all-to-all interactions\nignore_Y_drive false Drop the sigma^y drive\nlocal_detune false Include local detuning pattern","category":"section"},{"location":"generated/systems/rydberg_atoms/#Interaction-Range","page":"Rydberg Atoms","title":"Interaction Range","text":"The cutoff_order parameter controls which interaction terms are included:\n\ncutoff_order Pairs included Scaling\n1 nearest-neighbor (i i+1) C_6  d^6\n2 + next-nearest (i i+2) C_6  (2d)^6\nall2all = true all pairs (i j) C_6  ((j-i) cdot d)^6\n\nFor C_6  d^6 gg Omega, the nearest-neighbor approximation is often sufficient.  The ratio V_textnn  V_textnnn = 2^6 = 64.\n\n# All-to-all interactions (default)\nsys_all = RydbergChainSystem(N = 4, all2all = true, drive_bounds = [1.0, 1.0, 1.0])\n\n# Nearest-neighbor only\nsys_nn = RydbergChainSystem(\n    N = 4,\n    all2all = false,\n    cutoff_order = 1,\n    drive_bounds = [1.0, 1.0, 1.0],\n)\n\nsys_all.levels, sys_nn.levels","category":"section"},{"location":"generated/systems/rydberg_atoms/#Example:-GHZ-State-Preparation","page":"Rydberg Atoms","title":"Example: GHZ State Preparation","text":"N_atoms = 3\nsys = RydbergChainSystem(N = N_atoms, drive_bounds = [1.0, 1.0, 1.0])\n\nT, N_steps = 5.0, 80\ntimes = collect(range(0, T, length = N_steps))\npulse = ZeroOrderPulse(0.05 * randn(3, N_steps), times)\n\n# GHZ state: (|000‚ü© + |111‚ü©)/‚àö2\nœà_init = zeros(ComplexF64, 2^N_atoms)\nœà_init[1] = 1.0  # |000‚ü©\n\nœà_ghz = zeros(ComplexF64, 2^N_atoms)\nœà_ghz[1] = 1 / ‚àö2       # |000‚ü©\nœà_ghz[end] = 1 / ‚àö2     # |111‚ü©\n\nqtraj_rydberg = KetTrajectory(sys, pulse, œà_init, œà_ghz)\n\nqcp_rydberg = SmoothPulseProblem(qtraj_rydberg, N_steps; Q = 100.0)\ncached_solve!(qcp_rydberg, \"systems_rydberg_ghz\"; max_iter = 100, print_level = 1)\nfidelity(qcp_rydberg)","category":"section"},{"location":"generated/systems/rydberg_atoms/#Typical-Parameters","page":"Rydberg Atoms","title":"Typical Parameters","text":"Parameter Typical Value Unit\nC_6  2pi (Rb) 862690 MHz¬∑Œºm^6\nAtom spacing 4‚Äì10 Œºm\nOmega  2pi 1‚Äì10 MHz\nDelta  2pi 0‚Äì30 MHz\nBlockade radius 5‚Äì10 Œºm","category":"section"},{"location":"generated/systems/rydberg_atoms/#Best-Practices","page":"Rydberg Atoms","title":"Best Practices","text":"","category":"section"},{"location":"generated/systems/rydberg_atoms/#1.-Check-the-Blockade-Regime","page":"Rydberg Atoms","title":"1. Check the Blockade Regime","text":"Ensure V_textnn = C_6  d^6 gg Omega for the blockade mechanism to be effective.  If V sim Omega, the system operates in the intermediate (anti-blockade) regime.","category":"section"},{"location":"generated/systems/rydberg_atoms/#2.-Start-with-Nearest-Neighbor-Interactions","page":"Rydberg Atoms","title":"2. Start with Nearest-Neighbor Interactions","text":"Use cutoff_order = 1 or all2all = false for initial explorations. Add longer-range interactions (all2all = true) when needed for accuracy.","category":"section"},{"location":"generated/systems/rydberg_atoms/#3.-Scaling","page":"Rydberg Atoms","title":"3. Scaling","text":"The Hilbert space grows as 2^N, so direct Piccolo optimization is practical for N leq 8-10 atoms.","category":"section"},{"location":"generated/systems/rydberg_atoms/#References","page":"Rydberg Atoms","title":"References","text":"Saffman, Walker & M√∏lmer, \"Quantum information with Rydberg atoms,\" Rev. Mod. Phys. 82, 2313 (2010)\nBernien et al., \"Probing many-body dynamics on a 51-atom quantum simulator,\" Nature 551, 579 (2017)","category":"section"},{"location":"generated/systems/rydberg_atoms/#See-Also","page":"Rydberg Atoms","title":"See Also","text":"Quantum Systems Overview ‚Äî General system API\nTrajectories ‚Äî KetTrajectory for state preparation\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/concepts/trajectories/#trajectories-concept","page":"Trajectories","title":"Trajectories","text":"A trajectory bundles a quantum system, a control pulse, and a goal into the central object that problem templates consume.","category":"section"},{"location":"generated/concepts/trajectories/#Overview","page":"Trajectories","title":"Overview","text":"Every trajectory type defines:\n\nThe state x_k and its dynamics x_k+1 = exp(Delta t_k G(boldsymbolu_k)) x_k\nThe initial condition x_1 = x_textinit\nThe goal x_textgoal and associated fidelity metric","category":"section"},{"location":"generated/concepts/trajectories/#Trajectory-Types","page":"Trajectories","title":"Trajectory Types","text":"Type Dynamics State x_k Fidelity F dim(x_k)\nUnitaryTrajectory dotU = -iHU tildeU in mathbbR^2d^2 lvertoperatornametr(U_g^dagger U)rvert^2  d^2 2d^2\nKetTrajectory dotpsi = -iHpsi tildepsi in mathbbR^2d lvertlanglepsi_gmidpsiranglervert^2 2d\nDensityTrajectory dotrho = mathcalGtextvec(rho) tilderho in mathbbR^d^2 (compact) operatornametr(rho_grho) d^2\nMultiKetTrajectory dotpsi_j = -iHpsi_j multiple tildepsi_j coherent (see below) 2d times n_textstates\nSamplingTrajectory per-system dynamics per-system states average fidelity varies\n\nThe isomorphic state x_k is always a real vector; see Isomorphisms for the conversions.","category":"section"},{"location":"generated/concepts/trajectories/#UnitaryTrajectory","page":"Trajectories","title":"UnitaryTrajectory","text":"For synthesizing quantum gates.  The propagator satisfies dotU = G(boldsymbolu)U with U(0) = I.","category":"section"},{"location":"generated/concepts/trajectories/#Construction","page":"Trajectories","title":"Construction","text":"using Piccolo\n\n# Define system\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n# Create pulse\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\n\n# Create trajectory with goal\nU_goal = GATES[:X]\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)","category":"section"},{"location":"generated/concepts/trajectories/#Solve-and-Analyze","page":"Trajectories","title":"Solve and Analyze","text":"qcp = SmoothPulseProblem(qtraj, N; Q = 100.0)\ncached_solve!(qcp, \"trajectories_unitary\"; max_iter = 50)\nfidelity(qcp)","category":"section"},{"location":"generated/concepts/trajectories/#Extracting-the-Pulse","page":"Trajectories","title":"Extracting the Pulse","text":"optimized_pulse = get_pulse(qcp.qtraj)\nduration(optimized_pulse)","category":"section"},{"location":"generated/concepts/trajectories/#KetTrajectory","page":"Trajectories","title":"KetTrajectory","text":"For state preparation: find controls that map psi_textinitrangle to psi_textgoalrangle (up to global phase).  The fidelity is F = langlepsi_textgoalpsi(T)rangle^2.","category":"section"},{"location":"generated/concepts/trajectories/#Construction-2","page":"Trajectories","title":"Construction","text":"# Initial and goal states\nœà_init = ComplexF64[1, 0]  # |0‚ü©\nœà_goal = ComplexF64[0, 1]  # |1‚ü©\n\nqtraj_ket = KetTrajectory(sys, pulse, œà_init, œà_goal)","category":"section"},{"location":"generated/concepts/trajectories/#Solve","page":"Trajectories","title":"Solve","text":"qcp_ket = SmoothPulseProblem(qtraj_ket, N; Q = 100.0)\ncached_solve!(qcp_ket, \"trajectories_ket\"; max_iter = 50)\nfidelity(qcp_ket)","category":"section"},{"location":"generated/concepts/trajectories/#MultiKetTrajectory","page":"Trajectories","title":"MultiKetTrajectory","text":"For gates defined by multiple state mappings with coherent phases.  The fidelity enforces phase alignment across all state pairs:\n\nF = left frac1n sum_j=1^n langle psi_textgoalj  psi_j(T) rangle right^2\n\nThis is strictly harder than per-state fidelity because relative phases must be correct for the mapping to represent a valid gate.","category":"section"},{"location":"generated/concepts/trajectories/#Construction-3","page":"Trajectories","title":"Construction","text":"# Define state pairs: X gate maps |0‚ü© ‚Üí |1‚ü© and |1‚ü© ‚Üí |0‚ü©\nœà0 = ComplexF64[1, 0]\nœà1 = ComplexF64[0, 1]\n\ninitial_states = [œà0, œà1]\ngoal_states = [œà1, œà0]\n\nqtraj_multi = MultiKetTrajectory(sys, pulse, initial_states, goal_states)","category":"section"},{"location":"generated/concepts/trajectories/#Solve-2","page":"Trajectories","title":"Solve","text":"qcp_multi = SmoothPulseProblem(qtraj_multi, N; Q = 100.0)\ncached_solve!(qcp_multi, \"trajectories_multi\"; max_iter = 50)\nfidelity(qcp_multi)","category":"section"},{"location":"generated/concepts/trajectories/#DensityTrajectory","page":"Trajectories","title":"DensityTrajectory","text":"For open quantum systems governed by the Lindblad master equation.  The state rho(t) evolves as dotvecrho = mathcalG(boldsymbolu)vecrho where mathcalG is the Lindbladian superoperator (see Systems).\n\nInternally the state is stored in the compact isomorphism: a real vector of dimension d^2 (not 2d^2) that exploits Hermiticity. The Lindbladian generators are also compacted via mathcalG_c = PmathcalGL (size d^2 times d^2 instead of 2d^2 times 2d^2), giving roughly a 4√ó speedup in integration. See Isomorphisms for details.","category":"section"},{"location":"generated/concepts/trajectories/#Construction-4","page":"Trajectories","title":"Construction","text":"# Open system with a weak dissipation operator\nL = ComplexF64[0.1 0.0; 0.0 0.0]\nopen_sys = OpenQuantumSystem(\n    PAULIS[:Z],\n    [PAULIS[:X], PAULIS[:Y]],\n    [1.0, 1.0];\n    dissipation_operators = [L],\n)\n\n# Initial and goal density matrices\nœÅ_init = ComplexF64[1.0 0.0; 0.0 0.0]  # |0‚ü©‚ü®0|\nœÅ_goal = ComplexF64[0.0 0.0; 0.0 1.0]  # |1‚ü©‚ü®1|\n\nT_density, N_density = 10.0, 50\ntimes_density = collect(range(0, T_density, length = N_density))\npulse_density = ZeroOrderPulse(0.1 * randn(2, N_density), times_density)\nqtraj_density = DensityTrajectory(open_sys, pulse_density, œÅ_init, œÅ_goal)","category":"section"},{"location":"generated/concepts/trajectories/#Solve-and-Analyze-2","page":"Trajectories","title":"Solve and Analyze","text":"The fidelity for density matrices is F = operatornametr(rho_textgoalrho(T)).\n\nqcp_density = SmoothPulseProblem(qtraj_density, N_density; Q = 100.0, R = 1e-2)\ncached_solve!(qcp_density, \"trajectories_density\"; max_iter = 150)\nfidelity(qcp_density)","category":"section"},{"location":"generated/concepts/trajectories/#SamplingTrajectory","page":"Trajectories","title":"SamplingTrajectory","text":"For robust optimization over parameter variations.  Created internally by SamplingProblem, this trajectory type stores multiple system variants sharing a single control pulse.  The objective averages fidelity across all samples:\n\nbarell = frac1Ssum_s=1^S ellbigl(x_N^(s) x_textgoalbigr)\n\nsystems = [sys_nominal, sys_high, sys_low]\nqcp_robust = SamplingProblem(qcp_base, systems)","category":"section"},{"location":"generated/concepts/trajectories/#Common-Operations","page":"Trajectories","title":"Common Operations","text":"","category":"section"},{"location":"generated/concepts/trajectories/#Named-Trajectory-Integration","page":"Trajectories","title":"Named Trajectory Integration","text":"After solving, the NamedTrajectory stores the NLP decision vector at each of the N knot points:\n\ntraj = get_trajectory(qcp)\n\n# Controls at timestep k\nu_1 = traj[1][:u]\nu_1\n\n# All timesteps\nŒîts = get_timesteps(traj)\nlength(Œîts)","category":"section"},{"location":"generated/concepts/trajectories/#Internal-Representation","page":"Trajectories","title":"Internal Representation","text":"States in the trajectory are real isomorphic vectors.  Convert back to complex form with:\n\nU = iso_vec_to_operator(traj[:≈®‚Éó][:, end])     # unitary\nœà = iso_to_ket(traj[:œàÃÉ][:, end])               # ket\nœÅ = compact_iso_to_density(traj[:œÅ‚ÉóÃÉ][:, end])   # density matrix\n\nSee Isomorphisms for details.","category":"section"},{"location":"generated/concepts/trajectories/#Best-Practices","page":"Trajectories","title":"Best Practices","text":"","category":"section"},{"location":"generated/concepts/trajectories/#1.-Match-Pulse-Type-to-Problem","page":"Trajectories","title":"1. Match Pulse Type to Problem","text":"# For SmoothPulseProblem\npulse = ZeroOrderPulse(controls, times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SmoothPulseProblem(qtraj, N)  # ‚úì\n\n# For SplinePulseProblem\npulse = CubicSplinePulse(controls, tangents, times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SplinePulseProblem(qtraj)  # ‚úì","category":"section"},{"location":"generated/concepts/trajectories/#2.-Initialize-with-Reasonable-Controls","page":"Trajectories","title":"2. Initialize with Reasonable Controls","text":"# Scale by drive bounds\nmax_amp = 0.1 * 1.0\ninitial_controls = max_amp * randn(2, N)\nextrema(initial_controls)","category":"section"},{"location":"generated/concepts/trajectories/#See-Also","page":"Trajectories","title":"See Also","text":"Quantum Systems - System definitions\nPulses - Control parameterizations\nProblem Templates - Using trajectories in optimization\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorials/#tutorials-overview","page":"Overview","title":"Tutorials","text":"Step-by-step tutorials for learning Piccolo.jl. Each tutorial builds on previous ones, introducing new concepts progressively.","category":"section"},{"location":"tutorials/#Learning-Path","page":"Overview","title":"Learning Path","text":"","category":"section"},{"location":"tutorials/#For-Beginners","page":"Overview","title":"For Beginners","text":"If you're new to quantum optimal control or Piccolo.jl:\n\nYour First Gate - Complete walkthrough of X gate synthesis\nState Transfer - Learn about KetTrajectory for state preparation\nMultilevel Transmon - Work with realistic multilevel systems","category":"section"},{"location":"tutorials/#For-Experienced-Users","page":"Overview","title":"For Experienced Users","text":"If you're familiar with quantum control concepts:\n\nMultilevel Transmon - EmbeddedOperator and leakage suppression\nRobust Control - SamplingProblem for parameter robustness","category":"section"},{"location":"tutorials/#Tutorial-Overview","page":"Overview","title":"Tutorial Overview","text":"Tutorial Duration Topics\nYour First Gate 15 min Systems, pulses, trajectories, solving, analysis\nState Transfer 15 min KetTrajectory, state preparation, coherent gates\nMultilevel Transmon 20 min TransmonSystem, EmbeddedOperator, leakage\nRobust Control 20 min SamplingProblem, parameter uncertainty","category":"section"},{"location":"tutorials/#Prerequisites","page":"Overview","title":"Prerequisites","text":"Before starting the tutorials, ensure you have:\n\nJulia 1.10+ installed\nPiccolo.jl installed: using Pkg; Pkg.add(\"Piccolo\")\nCairoMakie for plotting: using Pkg; Pkg.add(\"CairoMakie\")\n\nTest your setup:\n\nusing Piccolo\nusing CairoMakie","category":"section"},{"location":"tutorials/#What-You'll-Learn","page":"Overview","title":"What You'll Learn","text":"","category":"section"},{"location":"tutorials/#Your-First-Gate","page":"Overview","title":"Your First Gate","text":"Defining quantum systems with QuantumSystem\nCreating control pulses with ZeroOrderPulse\nSetting optimization goals with UnitaryTrajectory\nSolving with SmoothPulseProblem\nAnalyzing results with fidelity() and plotting","category":"section"},{"location":"tutorials/#State-Transfer","page":"Overview","title":"State Transfer","text":"Using KetTrajectory for state-to-state transfer\nWorking with MultiKetTrajectory for multiple state mappings\nUnderstanding coherent fidelity for phase-sensitive gates","category":"section"},{"location":"tutorials/#Multilevel-Transmon","page":"Overview","title":"Multilevel Transmon","text":"Using TransmonSystem for realistic superconducting qubits\nDefining subspace gates with EmbeddedOperator\nSuppressing leakage to higher energy levels\nUsing PiccoloOptions for leakage handling","category":"section"},{"location":"tutorials/#Robust-Control","page":"Overview","title":"Robust Control","text":"Creating system variants for parameter uncertainty\nUsing SamplingProblem for robust optimization\nEvaluating robustness across parameter ranges\nCombining robustness with time optimization","category":"section"},{"location":"tutorials/#Running-the-Tutorials","page":"Overview","title":"Running the Tutorials","text":"Each tutorial is a complete, runnable Julia script. You can:\n\nRead online: Follow along in the documentation\nRun locally: Download the .jl file from the docs/literate/ folder\nCopy-paste: Copy code blocks into your Julia REPL","category":"section"},{"location":"tutorials/#Next-Steps","page":"Overview","title":"Next Steps","text":"After completing the tutorials:\n\nExplore Problem Templates for the full API\nRead Concepts for detailed documentation\nCheck How-To Guides for specific tasks","category":"section"},{"location":"generated/concepts/constraints/#constraints-concept","page":"Constraints","title":"Constraints","text":"Constraints are hard requirements enforced exactly by the NLP solver (Ipopt). Unlike objectives (which are minimized), constraints must be satisfied at every feasible solution.","category":"section"},{"location":"generated/concepts/constraints/#Overview","page":"Constraints","title":"Overview","text":"The full NLP (see Concepts Overview) has three classes of constraints:\n\nClass Mathematical Form Piccolo Source\nDynamics (equality) x_k+1 = exp(Delta t_k G(boldsymbolu_k)) x_k BilinearIntegrator\nBox bounds (inequality) boldsymbolu_min leq boldsymbolu_k leq boldsymbolu_max QuantumSystem.drive_bounds\nCustom (equality / inequality) fidelity floors, leakage ceilings, ‚Ä¶ PiccoloOptions, manual","category":"section"},{"location":"generated/concepts/constraints/#Bound-Constraints","page":"Constraints","title":"Bound Constraints","text":"","category":"section"},{"location":"generated/concepts/constraints/#Control-Bounds","page":"Constraints","title":"Control Bounds","text":"Control bounds u_i^min leq u_ik leq u_i^max are inherited from the QuantumSystem and enforced at every knot point:\n\nusing Piccolo\n\n# Bounds specified at system creation\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\ndrive_bounds = [1.0, 0.5]  # Drive 1: ¬±1.0, Drive 2: ¬±0.5\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)","category":"section"},{"location":"generated/concepts/constraints/#Derivative-Bounds","page":"Constraints","title":"Derivative Bounds","text":"Derivative bounds limit how fast controls can change.  For SmoothPulseProblem the discrete differences Deltaboldsymbolu_k = boldsymbolu_k - boldsymbolu_k-1 and Delta^2boldsymbolu_k are bounded element-wise:\n\nDelta u_ik leq b_du qquad Delta^2 u_ik leq b_ddu\n\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nU_goal = GATES[:X]\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    du_bound = 0.5,    # Max control jump per timestep\n    ddu_bound = 0.1,   # Max control acceleration\n)\ncached_solve!(qcp, \"constraints_bounds\"; max_iter = 50)\nfidelity(qcp)","category":"section"},{"location":"generated/concepts/constraints/#Timestep-Bounds","page":"Constraints","title":"Timestep Bounds","text":"For free-time optimization the timestep Delta t_k becomes a decision variable with box constraints:\n\nDelta t_min leq Delta t_k leq Delta t_max\n\nqcp = SmoothPulseProblem(qtraj, N; Œît_bounds=(0.01, 0.5))","category":"section"},{"location":"generated/concepts/constraints/#Fidelity-Constraints","page":"Constraints","title":"Fidelity Constraints","text":"Used with MinimumTimeProblem to enforce a minimum gate quality while minimizing total time T = sum_k Delta t_k:\n\nmin_boldsymboluDelta t sum_k=1^N Delta t_k\nquad textst quad F(x_N) geq F_min","category":"section"},{"location":"generated/concepts/constraints/#Automatic-Setup-in-MinimumTimeProblem","page":"Constraints","title":"Automatic Setup in MinimumTimeProblem","text":"# First solve a base problem with variable timesteps\nqcp_base = SmoothPulseProblem(qtraj, N; Œît_bounds = (0.01, 0.5))\ncached_solve!(qcp_base, \"constraints_base_freetime\"; max_iter = 100)\nfidelity(qcp_base)\n\n# Automatically adds FinalUnitaryFidelityConstraint\nqcp_mintime = MinimumTimeProblem(qcp_base; final_fidelity = 0.99)\ncached_solve!(qcp_mintime, \"constraints_mintime\"; max_iter = 100)\nfidelity(qcp_mintime)","category":"section"},{"location":"generated/concepts/constraints/#Leakage-Constraints","page":"Constraints","title":"Leakage Constraints","text":"For multilevel systems where d  d_textcomp, leakage to non-computational states can be bounded:\n\n1 - sum_j in mathcalS_textcomp langle j  rho_N  j rangle leq epsilon_textleak\n\nopts = PiccoloOptions(leakage_constraint = true, leakage_constraint_value = 1e-3)\n\n# Example with a transmon system\nsys_transmon = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.2, 0.2])\npulse_t = ZeroOrderPulse(0.01 * randn(2, N), times)\nU_X = EmbeddedOperator(:X, sys_transmon)\nqtraj_t = UnitaryTrajectory(sys_transmon, pulse_t, U_X)\n\nqcp_leak = SmoothPulseProblem(qtraj_t, N; piccolo_options = opts)\ncached_solve!(qcp_leak, \"constraints_leakage\"; max_iter = 100)\nfidelity(qcp_leak)","category":"section"},{"location":"generated/concepts/constraints/#PiccoloOptions","page":"Constraints","title":"PiccoloOptions","text":"PiccoloOptions provides a convenient way to configure common constraint and objective settings:\n\nOption Type Default Description\nleakage_constraint Bool false Enable leakage constraint\nleakage_constraint_value Float64 1e-3 Maximum leakage epsilon_textleak\nleakage_cost Float64 0.0 Leakage objective weight\ntimesteps_all_equal Bool false Force uniform timesteps\nverbose Bool false Print solver progress","category":"section"},{"location":"generated/concepts/constraints/#Constraints-vs-Objectives","page":"Constraints","title":"Constraints vs Objectives","text":"Use Case Constraint Objective\nMust achieve F geq 099 Fidelity constraint \nPrefer higher fidelity  Infidelity objective\nControl must be leq 10 Bound constraint \nPrefer smaller controls  Regularization\nLeakage must be  10^-3 Leakage constraint \nPrefer less leakage  Leakage objective\n\nTrade-off: Constraints guarantee satisfaction (if feasible) but can make the problem harder to solve.  Objectives are softer but offer no guarantees. A practical strategy is to start with objectives alone, then add constraints for hard requirements.","category":"section"},{"location":"generated/concepts/constraints/#Constraint-Feasibility","page":"Constraints","title":"Constraint Feasibility","text":"Common causes of infeasibility:\n\nTarget fidelity too high for the given gate time\nInsufficient time for the gate (quantum speed limit)\nControl bounds too tight\nConflicting constraints (e.g., low leakage + high fidelity + short time)","category":"section"},{"location":"generated/concepts/constraints/#Best-Practices","page":"Constraints","title":"Best Practices","text":"","category":"section"},{"location":"generated/concepts/constraints/#1.-Start-Without-Constraints","page":"Constraints","title":"1. Start Without Constraints","text":"# First, find a good solution with just objectives\nqcp_simple = SmoothPulseProblem(UnitaryTrajectory(sys, pulse, U_goal), N; Q = 100.0)\ncached_solve!(qcp_simple, \"constraints_simple\"; max_iter = 100)\nfidelity(qcp_simple)","category":"section"},{"location":"generated/concepts/constraints/#2.-Add-Constraints-Gradually","page":"Constraints","title":"2. Add Constraints Gradually","text":"if fidelity(qcp_simple) > 0.99\n    qcp_constrained = MinimumTimeProblem(qcp_simple; final_fidelity=0.99)\n    solve!(qcp_constrained)\nend","category":"section"},{"location":"generated/concepts/constraints/#3.-Use-Margin-for-Robustness","page":"Constraints","title":"3. Use Margin for Robustness","text":"# Target slightly higher than needed\nqcp = MinimumTimeProblem(qcp_base; final_fidelity=0.995)  # Want 0.99","category":"section"},{"location":"generated/concepts/constraints/#See-Also","page":"Constraints","title":"See Also","text":"Objectives - Soft optimization targets\nProblem Templates - Using constraints in practice\nMinimumTimeProblem - Fidelity-constrained time optimization\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/getting-started/installation/#installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"generated/getting-started/installation/#Requirements","page":"Installation","title":"Requirements","text":"Julia 1.10 or later\nA working internet connection (for package installation)","category":"section"},{"location":"generated/getting-started/installation/#Installing-Piccolo.jl","page":"Installation","title":"Installing Piccolo.jl","text":"Piccolo.jl is registered in the Julia General registry. Install it using the Julia package manager:\n\nusing Pkg\nPkg.add(\"Piccolo\")\n\nOr from the Julia REPL, press ] to enter package mode and run:\n\npkg> add Piccolo","category":"section"},{"location":"generated/getting-started/installation/#Verifying-Installation","page":"Installation","title":"Verifying Installation","text":"Test your installation by running:\n\nusing Piccolo\n\n# Check that core types are available\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\nsys","category":"section"},{"location":"generated/getting-started/installation/#Optional:-Visualization-Support","page":"Installation","title":"Optional: Visualization Support","text":"For plotting, you'll need a Makie backend. CairoMakie is recommended:\n\nusing Pkg\nPkg.add(\"CairoMakie\")\n\nThen in your code:\n\nusing Piccolo\nusing CairoMakie","category":"section"},{"location":"generated/getting-started/installation/#Development-Installation","page":"Installation","title":"Development Installation","text":"For contributing to Piccolo.jl or using the latest development version:\n\nusing Pkg\nPkg.develop(url=\"https://github.com/harmoniqs/Piccolo.jl\")\n\nOr clone the repository and use dev mode:\n\ngit clone https://github.com/harmoniqs/Piccolo.jl.git\ncd Piccolo.jl\njulia --project=.\n\nusing Pkg\nPkg.instantiate()","category":"section"},{"location":"generated/getting-started/installation/#Troubleshooting","page":"Installation","title":"Troubleshooting","text":"","category":"section"},{"location":"generated/getting-started/installation/#Precompilation-Takes-Long","page":"Installation","title":"Precompilation Takes Long","text":"First-time precompilation can take several minutes due to dependencies. This is normal and only happens once.","category":"section"},{"location":"generated/getting-started/installation/#Missing-Dependencies","page":"Installation","title":"Missing Dependencies","text":"If you encounter missing dependency errors, try:\n\nusing Pkg\nPkg.instantiate()\nPkg.precompile()","category":"section"},{"location":"generated/getting-started/installation/#Version-Conflicts","page":"Installation","title":"Version Conflicts","text":"If you have version conflicts with other packages:\n\nusing Pkg\nPkg.update()\n\nOr create a fresh environment:\n\nusing Pkg\nPkg.activate(\"my_project\")\nPkg.add(\"Piccolo\")","category":"section"},{"location":"generated/getting-started/installation/#Next-Steps","page":"Installation","title":"Next Steps","text":"Once installed, continue to the Quickstart guide to run your first optimization.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"problem-templates/#problem-templates-overview","page":"Overview","title":"Problem Templates","text":"Problem templates are the primary user-facing API in Piccolo.jl. They provide high-level constructors that set up quantum optimal control problems with sensible defaults while allowing fine-grained customization.","category":"section"},{"location":"problem-templates/#Overview","page":"Overview","title":"Overview","text":"Piccolo.jl provides five main problem templates:\n\nTemplate Purpose Pulse Type\nSmoothPulseProblem Piecewise constant controls with smoothness regularization ZeroOrderPulse\nBangBangPulseProblem Piecewise constant controls with L1 (bang-bang) regularization ZeroOrderPulse\nSplinePulseProblem Spline-based controls for smooth pulses LinearSplinePulse, CubicSplinePulse\nMinimumTimeProblem Time-optimal control (wraps another problem) Any\nSamplingProblem Robust optimization over parameter variations Any","category":"section"},{"location":"problem-templates/#Choosing-a-Template","page":"Overview","title":"Choosing a Template","text":"Use this decision flowchart to select the right template for your task:\n\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n        ‚îÇ  What pulse type?    ‚îÇ\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n           ‚ñº               ‚ñº\n    ZeroOrderPulse    SplinePulse\n           ‚îÇ               ‚îÇ\n           ‚ñº               ‚ñº\n  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n  ‚îÇ Smooth or      ‚îÇ ‚îÇ SplinePulse     ‚îÇ\n  ‚îÇ bang-bang?      ‚îÇ ‚îÇ Problem         ‚îÇ\n  ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n      ‚îÇ        ‚îÇ              ‚îÇ\n   Smooth   Bang-bang         ‚îÇ\n      ‚îÇ        ‚îÇ              ‚îÇ\n      ‚ñº        ‚ñº              ‚îÇ\n  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ\n  ‚îÇ Smooth ‚îÇ ‚îÇ BangBang ‚îÇ     ‚îÇ\n  ‚îÇ Pulse  ‚îÇ ‚îÇ Pulse    ‚îÇ     ‚îÇ\n  ‚îÇ Problem‚îÇ ‚îÇ Problem  ‚îÇ     ‚îÇ\n  ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ\n      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ\n             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                      ‚ñº\n           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n           ‚îÇ Need robustness? ‚îÇ\n           ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò\n            Yes‚îÇ          ‚îÇNo\n               ‚ñº          ‚îÇ\n       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n       ‚îÇ Sampling     ‚îÇ   ‚îÇ\n       ‚îÇ Problem      ‚îÇ   ‚îÇ\n       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                    ‚ñº\n           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n           ‚îÇ Minimize time? ‚îÇ\n           ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò\n            Yes‚îÇ        ‚îÇNo\n               ‚ñº        ‚îÇ\n       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\n       ‚îÇ MinimumTime  ‚îÇ ‚îÇ\n       ‚îÇ Problem      ‚îÇ ‚îÇ\n       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\n              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                   ‚ñº\n              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n              ‚îÇ Done!  ‚îÇ\n              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò","category":"section"},{"location":"problem-templates/#Quick-Decision-Guide","page":"Overview","title":"Quick Decision Guide","text":"Choose your base problem:\n\nSmoothPulseProblem: Start here for most problems. Uses piecewise constant pulses with derivative regularization for smoothness.\nBangBangPulseProblem: Use when you want piecewise constant pulses with minimal switching (L1 regularization promotes bang-bang controls).\nSplinePulseProblem: Use when you need inherently smooth pulses or want to warm-start from a previous solution.\n\nAdd robustness (optional):\n\nSamplingProblem: Wrap your base problem to optimize over multiple system variants (e.g., different detuning values).\n\nMinimize time (optional):\n\nMinimumTimeProblem: Wrap any problem to find the shortest gate duration that achieves a target fidelity.","category":"section"},{"location":"problem-templates/#Composability","page":"Overview","title":"Composability","text":"Problem templates can be chained together:\n\n# Step 1: Create base problem with free time enabled\nqcp_base = SmoothPulseProblem(qtraj, N; Œît_bounds=(0.01, 0.5))\nsolve!(qcp_base; max_iter=100)\n\n# Step 2: Add robustness\nqcp_robust = SamplingProblem(qcp_base, [sys_nominal, sys_perturbed])\nsolve!(qcp_robust; max_iter=100)\n\n# Step 3: Minimize time while maintaining fidelity\nqcp_mintime = MinimumTimeProblem(qcp_robust; final_fidelity=0.99)\nsolve!(qcp_mintime; max_iter=100)","category":"section"},{"location":"problem-templates/#Common-Workflow","page":"Overview","title":"Common Workflow","text":"All problem templates follow the same workflow:\n\n# 1. Define quantum system\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\n\n# 2. Create initial pulse\npulse = ZeroOrderPulse(initial_controls, times)\n\n# 3. Create trajectory with goal\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# 4. Set up optimization problem\nqcp = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2)\n\n# 5. Solve\nsolve!(qcp; max_iter=100)\n\n# 6. Analyze results\nprintln(\"Fidelity: \", fidelity(qcp))\noptimized_pulse = get_pulse(qcp.qtraj)","category":"section"},{"location":"problem-templates/#Key-Concepts","page":"Overview","title":"Key Concepts","text":"","category":"section"},{"location":"problem-templates/#Pulse-Type-Matching","page":"Overview","title":"Pulse Type Matching","text":"Each base problem template requires a specific pulse type:\n\nProblem Template Required Pulse Type\nSmoothPulseProblem ZeroOrderPulse\nBangBangPulseProblem ZeroOrderPulse\nSplinePulseProblem LinearSplinePulse or CubicSplinePulse\n\nUsing the wrong pulse type will result in a helpful error message.","category":"section"},{"location":"problem-templates/#Trajectory-Types","page":"Overview","title":"Trajectory Types","text":"Problem templates work with different trajectory types depending on your goal:\n\nTrajectory Type Use Case\nUnitaryTrajectory Gate synthesis (most common)\nKetTrajectory State transfer\nDensityTrajectory Open system evolution\nMultiKetTrajectory Multiple state transfers with coherent phases","category":"section"},{"location":"problem-templates/#Regularization-Parameters","page":"Overview","title":"Regularization Parameters","text":"Most problems use these regularization parameters:\n\nQ: Weight on infidelity objective (higher = prioritize fidelity)\nR: Base regularization weight for control smoothness\nR_u, R_du, R_ddu: Per-derivative regularization weights","category":"section"},{"location":"problem-templates/#Free-Time-Optimization","page":"Overview","title":"Free-Time Optimization","text":"To enable time optimization with MinimumTimeProblem, set Œît_bounds in your base problem:\n\nqcp = SmoothPulseProblem(qtraj, N; Œît_bounds=(0.01, 0.5))","category":"section"},{"location":"problem-templates/#Detailed-Documentation","page":"Overview","title":"Detailed Documentation","text":"SmoothPulseProblem - Full parameter reference and examples\nBangBangPulseProblem - L1-regularized bang-bang controls\nSplinePulseProblem - Spline-based optimization\nMinimumTimeProblem - Time-optimal control\nSamplingProblem - Robust optimization\nComposing Templates - Advanced composition patterns","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#bang-bang-pulse","page":"BangBangPulseProblem","title":"BangBangPulseProblem","text":"BangBangPulseProblem promotes bang-bang (piecewise-constant, few-switch) controls by penalizing du_1 via an exact slack reformulation. Unlike SmoothPulseProblem (which uses 2 derivative levels with L2 regularization), this stores only 1 derivative (du) and uses slack variables to impose an exact L1 penalty, promoting sparsity in du and thus fewer switches.","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#When-to-Use","page":"BangBangPulseProblem","title":"When to Use","text":"Use BangBangPulseProblem when:\n\nYou want piecewise constant control pulses with minimal switching\nYou want to promote bang-bang style controls (long constant segments)\nYou prefer exact L1 regularization over smooth L2 approximations","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Comparison-with-SmoothPulseProblem","page":"BangBangPulseProblem","title":"Comparison with SmoothPulseProblem","text":" SmoothPulseProblem BangBangPulseProblem\nDerivatives stored du, ddu du only\nRegularization on du L2 (QuadraticRegularizer) L1 (LinearRegularizer on slacks)\nRegularization on u L2 L2 (same)\nExtra variables ‚Äî slack s_du ‚â• 0\nExtra constraints ‚Äî L1SlackConstraint: du leq s\nBound params du_bound, ddu_bound du_bound only","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#How-the-L1-Penalty-Works","page":"BangBangPulseProblem","title":"How the L1 Penalty Works","text":"Instead of a smooth approximation, the L1 penalty uses an exact slack reformulation. Slack variables s geq 0 (same dimension as du) are introduced with the constraint:\n\ndu_ki leq s_ki\n\nThen the linear cost R_du sum_k sum_i s_ki Delta t_k is minimized. At optimality, s = du, giving the exact L1 norm.","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Pulse-Requirement","page":"BangBangPulseProblem","title":"Pulse Requirement","text":"BangBangPulseProblem requires a trajectory with a ZeroOrderPulse:\n\npulse = ZeroOrderPulse(controls, times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = BangBangPulseProblem(qtraj, N)  # Works\n\nUsing a spline pulse will result in an error directing you to SplinePulseProblem.","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Constructor","page":"BangBangPulseProblem","title":"Constructor","text":"BangBangPulseProblem(\n    qtraj::AbstractQuantumTrajectory{<:ZeroOrderPulse},\n    N::Int;\n    kwargs...\n)","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Parameter-Reference","page":"BangBangPulseProblem","title":"Parameter Reference","text":"","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Required-Parameters","page":"BangBangPulseProblem","title":"Required Parameters","text":"Parameter Type Description\nqtraj AbstractQuantumTrajectory{ZeroOrderPulse} Quantum trajectory containing system, pulse, and goal\nN Int Number of discretization timesteps","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Objective-Weights","page":"BangBangPulseProblem","title":"Objective Weights","text":"Parameter Type Default Description\nQ Float64 100.0 Weight on infidelity objective. Higher values prioritize achieving target fidelity.\nR Float64 1e-2 Base regularization weight applied to all terms.\nR_u Float64 or Vector{Float64} 0.0 L2 regularization on control values. Defaults to 0 (no amplitude regularization). Can be per-drive.\nR_du Float64 or Vector{Float64} R L1 weight on first derivative (applied to slacks). Higher values produce fewer switches.","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Bounds","page":"BangBangPulseProblem","title":"Bounds","text":"Parameter Type Default Description\ndu_bound Float64 Inf Maximum allowed control jump between timesteps.\nŒît_bounds Tuple{Float64, Float64} nothing Time-step bounds (min, max) for free-time optimization. Required for MinimumTimeProblem.","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Advanced-Options","page":"BangBangPulseProblem","title":"Advanced Options","text":"Parameter Type Default Description\nintegrator AbstractIntegrator nothing Custom integrator. If nothing, uses BilinearIntegrator.\nglobal_names Vector{Symbol} nothing Names of global parameters to optimize (requires custom integrator).\nglobal_bounds Dict{Symbol, ...} nothing Bounds on global variables. Values can be Float64 (symmetric ¬±) or Tuple{Float64, Float64}.\nconstraints Vector{AbstractConstraint} [] Additional constraints to add to the problem.\npiccolo_options PiccoloOptions PiccoloOptions() Solver and leakage options.","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Examples","page":"BangBangPulseProblem","title":"Examples","text":"","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Basic-Gate-Synthesis","page":"BangBangPulseProblem","title":"Basic Gate Synthesis","text":"using Piccolo\nusing CairoMakie\n\n# Define system\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n# Create trajectory\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys, pulse, GATES[:X])\n\n# Solve with L1 regularization on du\nqcp = BangBangPulseProblem(qtraj, N; Q = 100.0, R_du = 1.0)\ncached_solve!(qcp, \"bang_bang_basic\"; max_iter = 200)\n\nfidelity(qcp)","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Visualize-unitary-populations","page":"BangBangPulseProblem","title":"Visualize unitary populations","text":"traj = get_trajectory(qcp)\nfig = plot_unitary_populations(traj)","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Minimum-Time","page":"BangBangPulseProblem","title":"Minimum Time","text":"qcp_min = MinimumTimeProblem(qcp, final_fidelity = 0.99)\ncached_solve!(qcp_min, \"bang_bang_min_time\"; max_iter = 300)\n\nbefore = get_duration(traj)\nafter = duration(get_pulse(qcp_min.qtraj))\nbefore - after\n\nfig = plot_unitary_populations(get_trajectory(qcp_min))","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Tuning-the-L1-Weight","page":"BangBangPulseProblem","title":"Tuning the L1 Weight","text":"The R_du parameter controls how aggressively switches are penalized. Higher values produce fewer switches (more bang-bang):\n\nqcp = BangBangPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    R_du = 1.0,    ## Strong L1 penalty ‚Üí fewer switches\n)","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#With-Derivative-Bounds","page":"BangBangPulseProblem","title":"With Derivative Bounds","text":"Constrain the maximum control jump size:\n\nqcp = BangBangPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    R_du = 1e-1,\n    du_bound = 0.5,    ## Limit control jumps\n)","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Per-Drive-Regularization","page":"BangBangPulseProblem","title":"Per-Drive Regularization","text":"Apply different L1 weights to different control channels:\n\nqcp = BangBangPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    R_u = [1e-3, 1e-2],     ## Less L2 regularization on drive 1\n    R_du = [1e-1, 1.0],     ## Stronger L1 on drive 2\n)","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#State-Transfer","page":"BangBangPulseProblem","title":"State Transfer","text":"œà_init = ComplexF64[1, 0]  ## |0‚ü©\nœà_goal = ComplexF64[0, 1]  ## |1‚ü©\n\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = KetTrajectory(sys, pulse, œà_init, œà_goal)\n\nqcp = BangBangPulseProblem(qtraj, N; Q = 100.0, R_du = 1.0)\ncached_solve!(qcp, \"bang_bang_state_transfer\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#Multiple-State-Transfers","page":"BangBangPulseProblem","title":"Multiple State Transfers","text":"Use MultiKetTrajectory for gates defined by state mappings:\n\nœà0, œà1 = ComplexF64[1, 0], ComplexF64[0, 1]\n\n# X gate: |0‚ü© ‚Üí |1‚ü© and |1‚ü© ‚Üí |0‚ü©\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = MultiKetTrajectory(sys, pulse, [œà0, œà1], [œà1, œà0])\n\nqcp = BangBangPulseProblem(qtraj, N; Q = 100.0, R_du = 1.0)\ncached_solve!(qcp, \"bang_bang_multi_ket\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#How-It-Works","page":"BangBangPulseProblem","title":"How It Works","text":"BangBangPulseProblem internally:\n\nAdds 1 derivative variable: Creates :du (first derivative) alongside controls :u (compared to 2 in SmoothPulseProblem)\nAdds slack variables: Creates :s_du (non-negative, same dimension as :du), initialized at |du|\nSets up integrators: Uses DerivativeIntegrator to enforce:\ndu[k] = (u[k+1] - u[k]) / Œît\nConfigures objectives:\nInfidelity objective with weight Q\nQuadratic (L2) regularization on u with weight R_u\nLinear (L1) regularization on s_du with weight R_du\nApplies constraints: L1SlackConstraint enforces |du| ‚â§ s_du, and du_bound as hard constraints\n\nAt optimality the slacks satisfy s = |du|, so the linear cost on s equals the exact L1 norm of du.","category":"section"},{"location":"generated/problem-templates/bang_bang_pulse/#See-Also","page":"BangBangPulseProblem","title":"See Also","text":"SmoothPulseProblem - For smooth (L2-regularized) controls\nSplinePulseProblem - For inherently smooth spline-based controls\nMinimumTimeProblem - Time-optimal control\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/systems/trapped_ions/#trapped-ion-systems","page":"Trapped Ions","title":"Trapped Ions","text":"Trapped-ion quantum computers encode qubits in internal states of individual ions confined in electromagnetic traps.  Entangling operations are mediated by shared motional (phonon) modes of the ion chain.","category":"section"},{"location":"generated/systems/trapped_ions/#IonChainSystem","page":"Trapped Ions","title":"IonChainSystem","text":"","category":"section"},{"location":"generated/systems/trapped_ions/#Hamiltonian","page":"Trapped Ions","title":"Hamiltonian","text":"A chain of N ions, each with internal levels coupled to M shared motional modes.  In the rotating frame at frequency omega_textframe:\n\nH = sum_i=1^N (omega_qi - omega_textframe) sigma_i^+ sigma_i^-\n    + sum_m=1^M omega_m a_m^dagger a_m\n    + sum_im eta_im sigma_i^x(a_m + a_m^dagger)\n    + sum_i bigl Omega_xi(t) sigma_i^x + Omega_yi(t) sigma_i^y bigr\n\nwhere:\n\nsigma_i^pm are raising/lowering operators for ion i\na_m a_m^dagger are phonon operators for motional mode m\nomega_qi is the qubit transition frequency\nomega_m is the motional mode frequency\neta_im is the Lamb-Dicke parameter coupling ion i to mode m\nOmega_xi(t) Omega_yi(t) are the laser drive amplitudes\n\nThe Hilbert space is mathcalH = bigotimes_i mathbbC^d_textion otimes bigotimes_m mathbbC^n_textmax, with total dimension d_textion^N times n_textmax^M.","category":"section"},{"location":"generated/systems/trapped_ions/#Construction","page":"Trapped Ions","title":"Construction","text":"using Piccolo\n\n# Two ions, one motional mode\nsys_ion = IonChainSystem(\n    N_ions = 2,\n    N_modes = 1,\n    mode_levels = 5,        # Fock space truncation\n    œâq = 1.0,               # Qubit frequency (GHz)\n    œâm = 0.1,               # Motional mode frequency (GHz)\n    Œ∑ = 0.1,                # Lamb-Dicke parameter\n    drive_bounds = fill(0.5, 4),  # [Œ©x‚ÇÅ, Œ©y‚ÇÅ, Œ©x‚ÇÇ, Œ©y‚ÇÇ]\n)\nsys_ion.levels, sys_ion.n_drives","category":"section"},{"location":"generated/systems/trapped_ions/#Parameters","page":"Trapped Ions","title":"Parameters","text":"Parameter Default Description\nN_ions 2 Number of ions\nion_levels 2 Internal levels per ion\nN_modes 1 Number of motional modes\nmode_levels 10 Fock space truncation\nœâq 1.0 Qubit frequency (scalar or vector, GHz)\nœâm 0.1 Mode frequency (scalar or vector, GHz)\nŒ∑ 0.1 Lamb-Dicke parameter (scalar or N times M matrix)\nlab_frame false Use lab frame\nmultiply_by_2œÄ true Multiply Hamiltonian by 2pi","category":"section"},{"location":"generated/systems/trapped_ions/#Example:-Two-Ion-Entangling-Gate","page":"Trapped Ions","title":"Example: Two-Ion Entangling Gate","text":"T, N = 50.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.01 * randn(4, N), times)\n\n# MS-type entangling gate: exp(-iœÄ/4 œÉx‚äóœÉx) on ions ‚äó |0‚ü© on mode\nœà_init = zeros(ComplexF64, sys_ion.levels)\nœà_init[1] = 1.0  # |00‚ü© ‚äó |0‚ü©_phonon\n\n# Target: Bell state in qubit subspace ‚äó ground motional state\nMS(Œ∏) = exp(-im * Œ∏ / 2 * kron(ComplexF64[0 1; 1 0], ComplexF64[0 1; 1 0]))\nœà_goal_qubit = MS(œÄ / 2) * ComplexF64[1, 0, 0, 0]\nœà_goal = zeros(ComplexF64, sys_ion.levels)\nœà_goal[1:4] = œà_goal_qubit\n\nqtraj_ion = KetTrajectory(sys_ion, pulse, œà_init, œà_goal)\n\nqcp_ion = SmoothPulseProblem(qtraj_ion, N; Q = 100.0)\ncached_solve!(qcp_ion, \"systems_ion_ms\"; max_iter = 50, print_level = 1)\nfidelity(qcp_ion)","category":"section"},{"location":"generated/systems/trapped_ions/#RadialMSGateSystem","page":"Trapped Ions","title":"RadialMSGateSystem","text":"","category":"section"},{"location":"generated/systems/trapped_ions/#Hamiltonian-2","page":"Trapped Ions","title":"Hamiltonian","text":"Specialized system for the radial-mode M√∏lmer-S√∏rensen gate.  In the interaction picture, the time-dependent Hamiltonian is:\n\nH(t) = -fraci2 sum_i=1^N sum_k=1^2N\n    eta_ki Omega_i(t) sigma_xi\n    left( a_k e^-i delta_k t - a_k^dagger e^i delta_k t right)\n\nwhere k indexes the 2N radial modes (N modes along each transverse axis), Omega_i(t) is the Rabi frequency for ion i, and delta_k is the detuning from mode k.\n\nThis produces a time-dependent QuantumSystem where sys.H(u, t) evaluates the Hamiltonian at controls u and time t.","category":"section"},{"location":"generated/systems/trapped_ions/#Construction-2","page":"Trapped Ions","title":"Construction","text":"sys_ms = RadialMSGateSystem(\n    N_ions = 2,\n    mode_levels = 3,\n    œâm_radial = [5.0, 5.0, 5.1, 5.1],  # 2N radial mode frequencies (GHz)\n    Œ¥ = 0.2,                             # Detuning (GHz)\n    Œ∑ = 0.1,                             # Lamb-Dicke parameter\n    drive_bounds = [1.0, 1.0],           # Per-ion amplitude bounds\n)\nsys_ms.levels, sys_ms.n_drives","category":"section"},{"location":"generated/systems/trapped_ions/#Parameters-2","page":"Trapped Ions","title":"Parameters","text":"Parameter Default Description\nN_ions 2 Number of ions\nmode_levels 5 Fock states per radial mode\nœâm_radial [5, 5, 5.1, 5.1] Radial mode frequencies (vector of length 2N)\nŒ¥ 0.2 Detuning from sideband (scalar or vector)\nŒ∑ 0.1 Lamb-Dicke parameter (scalar or N times 2N matrix)","category":"section"},{"location":"generated/systems/trapped_ions/#RadialMSGateSystemWithPhase","page":"Trapped Ions","title":"RadialMSGateSystemWithPhase","text":"","category":"section"},{"location":"generated/systems/trapped_ions/#Hamiltonian-3","page":"Trapped Ions","title":"Hamiltonian","text":"Extends RadialMSGateSystem with phase controls phi_i(t) for AC Stark shift compensation:\n\nH(t) = frac12 sum_ik eta_ki Omega_i(t)\n    left( sigma_i^+ e^iphi_i(t) + sigma_i^- e^-iphi_i(t) right)\n    left( a_k e^-i delta_k t + a_k^dagger e^i delta_k t right)\n\nOff-resonant coupling to spectator modes creates AC Stark shifts Delta E_textStark sim eta^2 Omega^2  delta_textspectator. Modulating phi_i(t) cancels this time-varying phase accumulation, enabling high-fidelity gates.\n\nControls: Omega_1 phi_1 Omega_2 phi_2 ldots (interleaved amplitudes and phases).","category":"section"},{"location":"generated/systems/trapped_ions/#Construction-3","page":"Trapped Ions","title":"Construction","text":"sys_ms_phase = RadialMSGateSystemWithPhase(\n    N_ions = 2,\n    mode_levels = 3,\n    œâm_radial = [5.0, 5.0, 5.1, 5.1],\n    Œ¥ = 0.2,\n    Œ∑ = 0.1,\n    amplitude_bounds = [1.0, 1.0],\n    phase_bounds = [(-Float64(œÄ), Float64(œÄ)), (-Float64(œÄ), Float64(œÄ))],\n)\nsys_ms_phase.n_drives  # 4: [Œ©‚ÇÅ, œÜ‚ÇÅ, Œ©‚ÇÇ, œÜ‚ÇÇ]","category":"section"},{"location":"generated/systems/trapped_ions/#Typical-Parameters","page":"Trapped Ions","title":"Typical Parameters","text":"Typical values for ^171Yb^+ ions (e.g., Q-SCOUT platform):\n\nParameter Typical Value Unit\nomega_q  2pi 12.6 GHz\nomega_m  2pi (axial) 1‚Äì3 MHz\nomega_m  2pi (radial) 3‚Äì6 MHz\nLamb-Dicke eta 0.05‚Äì0.15 ‚Äî\nGate time 50‚Äì200 Œºs\nn_textmax 3‚Äì5 ‚Äî","category":"section"},{"location":"generated/systems/trapped_ions/#Best-Practices","page":"Trapped Ions","title":"Best Practices","text":"","category":"section"},{"location":"generated/systems/trapped_ions/#1.-Truncate-Motional-Modes-Carefully","page":"Trapped Ions","title":"1. Truncate Motional Modes Carefully","text":"The phonon Fock space must be large enough to capture displaced states during the gate.  Start with mode_levels = 5 and increase if dynamics require larger excursions.","category":"section"},{"location":"generated/systems/trapped_ions/#2.-Ensure-Motional-Closure","page":"Trapped Ions","title":"2. Ensure Motional Closure","text":"For MS gates, the motional state must return to vacuum at the end of the gate: alpha_k(tau) approx 0 for all modes k.  This is a necessary condition for separating the qubit and motional degrees of freedom.","category":"section"},{"location":"generated/systems/trapped_ions/#3.-Use-Individual-Ion-Addressing","page":"Trapped Ions","title":"3. Use Individual Ion Addressing","text":"Each ion has independent Omega_xi Omega_yi controls, enabling individually optimized Rabi frequencies.","category":"section"},{"location":"generated/systems/trapped_ions/#References","page":"Trapped Ions","title":"References","text":"S√∏rensen & M√∏lmer, \"Quantum computation with ions in thermal motion,\" Phys. Rev. Lett. 82, 1971 (1999)\nS√∏rensen & M√∏lmer, \"Entanglement and quantum computation with ions in thermal motion,\" Phys. Rev. A 62, 022311 (2000)\nMizrahi et al., \"Realization and Calibration of Continuously Parameterized Two-Qubit Gates on a Trapped-Ion Quantum Processor,\" IEEE TQE (2024)","category":"section"},{"location":"generated/systems/trapped_ions/#See-Also","page":"Trapped Ions","title":"See Also","text":"Quantum Systems Overview ‚Äî General system API\nPulses ‚Äî GaussianPulse for analytical pulse shaping\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"development/contributing/#Contributing","page":"Contributing","title":"Contributing","text":"We welcome contributions to Piccolo.jl! This document outlines the guidelines for contributing to the project. If you know what you want to see but are unsure of the best way to achieve it, open an issue and start a discussion with the community.","category":"section"},{"location":"development/contributing/#Development-Setup","page":"Contributing","title":"Development Setup","text":"","category":"section"},{"location":"development/contributing/#Install-Julia","page":"Contributing","title":"Install Julia","text":"Juliaup is an installer and version manager for Julia. After installing, run julia to obtain the Julia REPL.","category":"section"},{"location":"development/contributing/#Julia-Environments","page":"Contributing","title":"Julia Environments","text":"Your project's environment is stored in Project.toml. You can interactively manage packages using the Julia REPL and package manager:\n\nStart Julia in the project folder\nType ] to enter the package manager\nType activate . to activate the environment\nRun instantiate to install dependencies","category":"section"},{"location":"development/contributing/#Development-Installation","page":"Contributing","title":"Development Installation","text":"For development, clone the repository and use dev mode:\n\nusing Pkg\nPkg.dev(\"path/to/Piccolo.jl\")","category":"section"},{"location":"development/contributing/#Using-Revise","page":"Contributing","title":"Using Revise","text":"Revise.jl automatically reloads code changes during development:\n\nusing Revise\nusing Piccolo\n\nLoad Revise before any packages you intend to edit.","category":"section"},{"location":"development/contributing/#Tips-for-Visual-Studio-Code","page":"Contributing","title":"Tips for Visual Studio Code","text":"","category":"section"},{"location":"development/contributing/#Julia-Extension","page":"Contributing","title":"Julia Extension","text":"The Julia extension provides excellent Julia support including notebooks, REPL integration, and debugging.","category":"section"},{"location":"development/contributing/#Fonts","page":"Contributing","title":"Fonts","text":"VS Code may not display all Julia characters correctly. Change the editor font family to 'JuliaMono' for full Unicode support. You can create a VS Code settings profile for Julia at File > Preferences > Profile.","category":"section"},{"location":"development/contributing/#Tests","page":"Contributing","title":"Tests","text":"Tests automatically populate in VS Code when working with Piccolo packages. Click the Testing sidebar icon to see and run tests. Sometimes you may need to restart the Julia kernel to see changes reflected in tests.","category":"section"},{"location":"development/contributing/#Writing-Tests","page":"Contributing","title":"Writing Tests","text":"Tests are implemented using TestItems.jl:\n\n@testitem \"X gate synthesis\" begin\n    H_drift = PAULIS[:Z]\n    H_drives = [PAULIS[:X], PAULIS[:Y]]\n    sys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n    T, N = 10.0, 100\n    times = collect(range(0, T, length=N))\n    pulse = ZeroOrderPulse(0.1 * randn(2, N), times)\n    qtraj = UnitaryTrajectory(sys, pulse, GATES[:X])\n\n    qcp = SmoothPulseProblem(qtraj, N)\n    solve!(qcp; max_iter=100)\n\n    @test fidelity(qcp) > 0.99\nend\n\nTests should be included in the same file as the code they test. Individual tests populate in the Testing panel in VS Code and are run in CI on each PR.","category":"section"},{"location":"development/contributing/#Building-Documentation","page":"Contributing","title":"Building Documentation","text":"Documentation is built using Documenter.jl with Literate.jl for executable examples.","category":"section"},{"location":"development/contributing/#Build-Locally","page":"Contributing","title":"Build Locally","text":"julia --project=docs docs/make.jl","category":"section"},{"location":"development/contributing/#Live-Development-Server","page":"Contributing","title":"Live Development Server","text":"For interactive documentation development:\n\njulia --project=docs\n\nusing Revise, LiveServer, Piccolo\nservedocs(\n    literate_dir=\"docs/literate\",\n    skip_dirs=[\"docs/src/generated\"],\n    skip_files=[\"docs/src/index.md\"]\n)\n\nChanges to documentation files are automatically reflected. To see source code changes (e.g., docstrings), restart the live server.","category":"section"},{"location":"development/contributing/#Reporting-Issues","page":"Contributing","title":"Reporting Issues","text":"Use the GitHub issue templates for bug reports and feature requests.","category":"section"},{"location":"reference/#API-Reference","page":"Overview","title":"API Reference","text":"This section provides complete documentation of all public types and functions in Piccolo.jl.","category":"section"},{"location":"reference/#Module-Organization","page":"Overview","title":"Module Organization","text":"Piccolo.jl is organized into three main modules:\n\nModule Contents\nQuantum Systems, trajectories, pulses, operators, isomorphisms\nControl Problems, objectives, constraints, integrators, templates\nVisualizations Plotting and animation utilities\n\nSee the Library Reference page for full docstrings of all exported types and functions.","category":"section"},{"location":"reference/#Reexported-Packages","page":"Overview","title":"Reexported Packages","text":"Piccolo.jl reexports several foundation packages. Their functionality is available when you using Piccolo:\n\nPackage Purpose Key Types/Functions\nDirectTrajOpt Trajectory optimization solve!, add_objective!, add_constraint!\nNamedTrajectories Trajectory containers NamedTrajectory, get_timesteps, plot\nTrajectoryIndexingUtils Indexing utilities Trajectory slicing and indexing","category":"section"},{"location":"reference/#Quick-Reference","page":"Overview","title":"Quick Reference","text":"","category":"section"},{"location":"reference/#Creating-Systems","page":"Overview","title":"Creating Systems","text":"# Basic system\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\n\n# From templates\nsys = TransmonSystem(levels=3, Œ¥=0.2, drive_bounds=[0.2, 0.2])","category":"section"},{"location":"reference/#Creating-Trajectories","page":"Overview","title":"Creating Trajectories","text":"# Unitary gate synthesis\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# State preparation\nqtraj = KetTrajectory(sys, pulse, œà_init, œà_goal)","category":"section"},{"location":"reference/#Creating-Problems","page":"Overview","title":"Creating Problems","text":"# Smooth pulse optimization\nqcp = SmoothPulseProblem(qtraj, N; Q=100.0)\n\n# Time-optimal control\nqcp_mintime = MinimumTimeProblem(qcp; final_fidelity=0.99)\n\n# Robust optimization\nqcp_robust = SamplingProblem(qcp, systems)","category":"section"},{"location":"reference/#Solving-and-Analysis","page":"Overview","title":"Solving and Analysis","text":"# Solve\nsolve!(qcp; max_iter=100)\n\n# Analyze\nfid = fidelity(qcp)\ntraj = get_trajectory(qcp)","category":"section"},{"location":"development/release-notes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"section"},{"location":"development/release-notes/#[v1.0.0]-Upcoming","page":"Release Notes","title":"[v1.0.0] - Upcoming","text":"","category":"section"},{"location":"development/release-notes/#Changed","page":"Release Notes","title":"Changed","text":"Complete documentation overhaul with concept-driven organization\nMigrated from PiccoloDocsTemplate to standard Documenter.jl","category":"section"},{"location":"development/release-notes/#[v0.3.1]-2024-10-17","page":"Release Notes","title":"[v0.3.1] - 2024-10-17","text":"","category":"section"},{"location":"development/release-notes/#Fixed","page":"Release Notes","title":"Fixed","text":"Fixed and added tests to RydbergChainSystem","category":"section"},{"location":"development/release-notes/#[v0.3.0]-2024-10-10","page":"Release Notes","title":"[v0.3.0] - 2024-10-10","text":"","category":"section"},{"location":"development/release-notes/#Added","page":"Release Notes","title":"Added","text":"PiccoloOptions to handle custom problem settings","category":"section"},{"location":"development/release-notes/#Changed-2","page":"Release Notes","title":"Changed","text":"Refactored trajectory initialization functions\nImproved documentation\nTypo fixes","category":"section"},{"location":"development/release-notes/#[v0.2.0]-2024-02-22","page":"Release Notes","title":"[v0.2.0] - 2024-02-22","text":"","category":"section"},{"location":"development/release-notes/#Added-2","page":"Release Notes","title":"Added","text":"EmbeddedOperator to handle subspace gate optimization and leakage suppression\nPlotting methods for unitary populations","category":"section"},{"location":"development/release-notes/#Changed-3","page":"Release Notes","title":"Changed","text":"New quantum systems interface\nTransmon system template\nRestructured the code base for easier quantum system and problem template development","category":"section"},{"location":"development/release-notes/#Removed","page":"Release Notes","title":"Removed","text":"Stale examples","category":"section"},{"location":"development/release-notes/#Fixed-2","page":"Release Notes","title":"Fixed","text":"Robustness improvements objective test fixes","category":"section"},{"location":"generated/systems/transmons/#transmon-systems","page":"Transmon Qubits","title":"Transmon Qubits","text":"Superconducting transmon qubits are charge-insensitive artificial atoms formed by a Josephson junction shunted by a large capacitance.  The transmon spectrum is weakly anharmonic, so at least one level beyond the computational subspace must be included to capture leakage.","category":"section"},{"location":"generated/systems/transmons/#Single-Transmon","page":"Transmon Qubits","title":"Single Transmon","text":"","category":"section"},{"location":"generated/systems/transmons/#Hamiltonian","page":"Transmon Qubits","title":"Hamiltonian","text":"In the rotating frame at frequency omega, the transmon Hamiltonian truncated to d levels is:\n\nH = (omega - omega_textframe) a^dagger a\n    - fracdelta2 a^dagger 2 a^2\n    + u_x(t)(a + a^dagger)\n    + u_y(t) i(a^dagger - a)\n\nwhere delta is the anharmonicity (approx 200 MHz for typical transmons) and a is the annihilation operator truncated to d levels. In the default rotating frame omega_textframe = omega, the first term vanishes.\n\nThe energy spectrum is E_n = nomega + tfracn(n-1)2delta, giving transition frequencies omega_01 = omega and omega_12 = omega + delta.","category":"section"},{"location":"generated/systems/transmons/#Construction","page":"Transmon Qubits","title":"Construction","text":"using Piccolo\n\n# 3-level transmon in the rotating frame (default)\nsys = TransmonSystem(\n    levels = 3,           # Truncation level (‚â•2)\n    Œ¥ = 0.2,              # Anharmonicity (GHz)\n    œâ = 4.0,              # Qubit frequency (GHz) ‚Äî cancels in rotating frame\n    drive_bounds = [0.2, 0.2],  # Max amplitude for X, Y drives (GHz)\n)\nsys.levels, sys.n_drives","category":"section"},{"location":"generated/systems/transmons/#Parameters","page":"Transmon Qubits","title":"Parameters","text":"Parameter Default Description\nlevels 3 Number of transmon levels\nŒ¥ 0.2 Anharmonicity (GHz)\nœâ 4.0 Qubit frequency (GHz)\ndrive_bounds [1.0, 1.0] Bounds for u_x u_y\nlab_frame false Use lab frame instead of rotating frame\nlab_frame_type :duffing Lab frame model (:duffing, :quartic, :cosine)\nmultiply_by_2œÄ true Multiply by 2pi (GHz ‚Üí rad/ns)","category":"section"},{"location":"generated/systems/transmons/#Lab-Frame-Variants","page":"Transmon Qubits","title":"Lab Frame Variants","text":"The lab_frame_type keyword selects the lab-frame Hamiltonian model:\n\nType Hamiltonian\n:duffing H = omega a^dagger a - fracdelta2 a^dagger 2 a^2\n:quartic H = omega_0 a^dagger a - fracdelta12 (a + a^dagger)^4\n:cosine H = 4 E_C hatn^2 - E_J coshatvarphi","category":"section"},{"location":"generated/systems/transmons/#Example:-X-Gate-on-a-3-Level-Transmon","page":"Transmon Qubits","title":"Example: X Gate on a 3-Level Transmon","text":"sys = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.2, 0.2])\n\n# Goal: X gate in the computational subspace {|0‚ü©, |1‚ü©}\nU_goal = EmbeddedOperator(:X, sys)\n\nT, N = 20.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.05 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0)\ncached_solve!(qcp, \"systems_transmon_X\"; max_iter = 100, print_level = 1)\nfidelity(qcp)\n\ntip: Leakage\nWith levels ‚â• 3, use EmbeddedOperator to define the gate in the computational subspace, and add leakage penalties via PiccoloOptions(leakage_cost=10.0) or PiccoloOptions(leakage_constraint=true). See Leakage Suppression.","category":"section"},{"location":"generated/systems/transmons/#Multi-Transmon-Systems","page":"Transmon Qubits","title":"Multi-Transmon Systems","text":"","category":"section"},{"location":"generated/systems/transmons/#Hamiltonian-2","page":"Transmon Qubits","title":"Hamiltonian","text":"N transmon qubits with pairwise dipole coupling in the rotating frame:\n\nH = sum_i=1^N left\n    (omega_i - omega_textframe) a_i^dagger a_i\n    - fracdelta_i2 a_i^dagger 2 a_i^2\nright\n+ sum_i  j g_ij left( a_i a_j^dagger + a_i^dagger a_j right)\n\nThe coupling g_ij(a_i a_j^dagger + a_i^dagger a_j) is the rotating-wave approximation of the transmon dipole interaction.  In the lab frame the full form g_ij(a_i + a_i^dagger)(a_j + a_j^dagger) is used instead.","category":"section"},{"location":"generated/systems/transmons/#Construction-2","page":"Transmon Qubits","title":"Construction","text":"sys_multi = MultiTransmonSystem(\n    [4.0, 4.1],               # Qubit frequencies œâ·µ¢ (GHz)\n    [0.2, 0.22],              # Anharmonicities Œ¥·µ¢ (GHz)\n    [0.0 0.01; 0.01 0.0];     # Coupling matrix g·µ¢‚±º (GHz)\n    drive_bounds = 0.2,\n    levels_per_transmon = 3,\n)\n\nReturns a CompositeQuantumSystem with tensor-product Hilbert space mathcalH = mathcalH_1 otimes mathcalH_2.","category":"section"},{"location":"generated/systems/transmons/#Parameters-2","page":"Transmon Qubits","title":"Parameters","text":"Parameter Description\nœâs Qubit frequencies (vector, GHz)\nŒ¥s Anharmonicities (vector, GHz)\ngs Symmetric coupling matrix (GHz)\nlevels_per_transmon Levels per qubit (default 3)\ndrive_bounds Scalar or vector of bounds\nsubsystems Subset of indices to include\nsubsystem_drive_indices Which qubits get drives","category":"section"},{"location":"generated/systems/transmons/#Transmon-Cavity-(Circuit-QED)","page":"Transmon Qubits","title":"Transmon-Cavity (Circuit QED)","text":"","category":"section"},{"location":"generated/systems/transmons/#Hamiltonian-3","page":"Transmon Qubits","title":"Hamiltonian","text":"A transmon dispersively coupled to a microwave cavity:\n\nH = tildeDelta hatb^dagger hatb\n    - chi hata^dagger hata hatb^dagger hatb\n    - chi hatb^dagger 2 hatb^2 hata^dagger hata\n    - K_q hata^dagger 2 hata^2\n    - K_c hatb^dagger 2 hatb^2\n\nwhere hata (hatb) annihilates a transmon (cavity) excitation, chi is the dispersive shift, K_q K_c are self-Kerr nonlinearities, and tildeDelta = chi2.\n\nThe four drives are:\n\nhata + hata^dagger ‚Äî real transmon drive\ni(hata^dagger - hata) ‚Äî imaginary transmon drive\nhatb + hatb^dagger ‚Äî real cavity drive\ni(hatb^dagger - hatb) ‚Äî imaginary cavity drive","category":"section"},{"location":"generated/systems/transmons/#Construction-3","page":"Transmon Qubits","title":"Construction","text":"sys_cqed = TransmonCavitySystem(\n    qubit_levels = 4,\n    cavity_levels = 12,\n    œá = 2œÄ * 32.8e-6,       # Dispersive shift (GHz)\n    K_q = 2œÄ * 193e-3 / 2,  # Qubit self-Kerr (GHz)\n    K_c = 2œÄ * 1e-9 / 2,    # Cavity self-Kerr (GHz)\n    drive_bounds = [0.5, 0.5, 1.0, 1.0],\n)\nsys_cqed.levels, sys_cqed.n_drives","category":"section"},{"location":"generated/systems/transmons/#Parameters-3","page":"Transmon Qubits","title":"Parameters","text":"Parameter Default Description\nqubit_levels 4 Transmon Fock states\ncavity_levels 12 Cavity Fock states\nœá 2pi times 328 kHz Dispersive shift\nœá‚Ä≤ 2pi times 15 Hz Higher-order correction\nK_q 2pi times 965 MHz Qubit self-Kerr\nK_c 2pi times 05 Hz Cavity self-Kerr","category":"section"},{"location":"generated/systems/transmons/#Best-Practices","page":"Transmon Qubits","title":"Best Practices","text":"","category":"section"},{"location":"generated/systems/transmons/#1.-Include-Enough-Levels","page":"Transmon Qubits","title":"1. Include Enough Levels","text":"For single-qubit gates: d geq 3 (captures leakage to 2rangle). For high-fidelity (F  09999): d geq 4.\n\nsys_3 = TransmonSystem(levels = 3, Œ¥ = 0.2)\nsys_4 = TransmonSystem(levels = 4, Œ¥ = 0.2)\nsys_3.levels, sys_4.levels","category":"section"},{"location":"generated/systems/transmons/#2.-Use-Realistic-Parameters","page":"Transmon Qubits","title":"2. Use Realistic Parameters","text":"Parameter Typical Value Unit\nomega  2pi 4‚Äì5 GHz\ndelta  2pi 150‚Äì250 MHz\nDrive amplitude 10‚Äì50 MHz\ng_ij  2pi 1‚Äì10 MHz","category":"section"},{"location":"generated/systems/transmons/#3.-Use-EmbeddedOperator-for-Gates","page":"Transmon Qubits","title":"3. Use EmbeddedOperator for Gates","text":"When d  2, define the gate in the computational subspace:\n\nU_goal = EmbeddedOperator(:X, sys)  # X on {|0‚ü©, |1‚ü©}, identity on |2‚ü©, ...","category":"section"},{"location":"generated/systems/transmons/#References","page":"Transmon Qubits","title":"References","text":"Koch et al., \"Charge-insensitive qubit design derived from the Cooper pair box,\" Phys. Rev. A 76, 042319 (2007)\nBlais et al., \"Circuit quantum electrodynamics,\" Rev. Mod. Phys. 93, 025005 (2021)","category":"section"},{"location":"generated/systems/transmons/#See-Also","page":"Transmon Qubits","title":"See Also","text":"Quantum Systems Overview ‚Äî General system API\nLeakage Suppression ‚Äî Handling higher levels\nOperators ‚Äî EmbeddedOperator details\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/problem-templates/minimum_time/#minimum-time","page":"MinimumTimeProblem","title":"MinimumTimeProblem","text":"MinimumTimeProblem converts an existing optimization problem into a time-optimal control problem. It minimizes the total gate duration while maintaining a minimum fidelity constraint.","category":"section"},{"location":"generated/problem-templates/minimum_time/#When-to-Use","page":"MinimumTimeProblem","title":"When to Use","text":"Use MinimumTimeProblem when:\n\nYou have a working solution and want to minimize its duration\nYou need the fastest possible gate that achieves a target fidelity\nYou're exploring the fidelity-time trade-off","category":"section"},{"location":"generated/problem-templates/minimum_time/#Key-Design:-Composition-Pattern","page":"MinimumTimeProblem","title":"Key Design: Composition Pattern","text":"MinimumTimeProblem wraps an existing QuantumControlProblem. It does not create a problem directly from a trajectory:\n\n# This does NOT work\nqcp_mintime = MinimumTimeProblem(qtraj)  # Error!\n\n# This works\nqcp_base = SmoothPulseProblem(qtraj; Œît_bounds=(0.01, 0.5))\nsolve!(qcp_base)\nqcp_mintime = MinimumTimeProblem(qcp_base; final_fidelity=0.99)","category":"section"},{"location":"generated/problem-templates/minimum_time/#Prerequisites","page":"MinimumTimeProblem","title":"Prerequisites","text":"The base problem must have Œît_bounds set to enable variable timesteps:\n\n# Enable free-time optimization in the base problem\nqcp_base = SmoothPulseProblem(qtraj; Œît_bounds=(0.01, 0.5))","category":"section"},{"location":"generated/problem-templates/minimum_time/#Constructor","page":"MinimumTimeProblem","title":"Constructor","text":"MinimumTimeProblem(\n    qcp::QuantumControlProblem;\n    goal = nothing,\n    final_fidelity = 0.99,\n    D = 100.0,\n    piccolo_options = PiccoloOptions()\n)","category":"section"},{"location":"generated/problem-templates/minimum_time/#Parameter-Reference","page":"MinimumTimeProblem","title":"Parameter Reference","text":"Parameter Type Default Description\nqcp QuantumControlProblem required Base problem to convert (must have Œît_bounds)\ngoal AbstractPiccoloOperator or AbstractVector nothing Optional new goal (uses base problem's goal if nothing)\nfinal_fidelity Float64 0.99 Minimum fidelity constraint\nD Float64 100.0 Weight on total time objective\npiccolo_options PiccoloOptions PiccoloOptions() Solver options","category":"section"},{"location":"generated/problem-templates/minimum_time/#Optimization-Problem","page":"MinimumTimeProblem","title":"Optimization Problem","text":"MinimumTimeProblem sets up:\n\nminimize:    J_original + D √ó Œ£ Œît‚Çñ\nsubject to:  Original dynamics and constraints\n             F_final ‚â• final_fidelity\n             Œît_min ‚â§ Œît‚Çñ ‚â§ Œît_max\n\nThe parameter D controls the trade-off between the original objective and time minimization. Higher D values prioritize shorter duration.","category":"section"},{"location":"generated/problem-templates/minimum_time/#Examples","page":"MinimumTimeProblem","title":"Examples","text":"","category":"section"},{"location":"generated/problem-templates/minimum_time/#Basic-Time-Optimal-Gate","page":"MinimumTimeProblem","title":"Basic Time-Optimal Gate","text":"using Piccolo\nusing Printf # hide\n\n# Setup\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\nT, N = 20.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys, pulse, GATES[:X])\n\n# Step 1: Solve base problem with free time enabled\nqcp_base = SmoothPulseProblem(qtraj, N; Q = 100.0, Œît_bounds = (0.05, 0.5))\ncached_solve!(qcp_base, \"mintime_base\"; max_iter = 100)\n\nsum(get_timesteps(get_trajectory(qcp_base)))\n\nfidelity(qcp_base)","category":"section"},{"location":"generated/problem-templates/minimum_time/#Step-2:-Minimize-Time","page":"MinimumTimeProblem","title":"Step 2: Minimize Time","text":"qcp_mintime = MinimumTimeProblem(qcp_base; final_fidelity = 0.99, D = 100.0)\ncached_solve!(qcp_mintime, \"mintime_optimal\"; max_iter = 100)\n\nsum(get_timesteps(get_trajectory(qcp_mintime)))\n\nfidelity(qcp_mintime)","category":"section"},{"location":"generated/problem-templates/minimum_time/#Exploring-Fidelity-Time-Trade-off","page":"MinimumTimeProblem","title":"Exploring Fidelity-Time Trade-off","text":"results = []\nfor target_fidelity in [0.999, 0.99, 0.95, 0.90]\n    qcp_mt = MinimumTimeProblem(qcp_base; final_fidelity = target_fidelity)\n    cached_solve!(\n        qcp_mt,\n        \"mintime_tradeoff_$(target_fidelity)\";\n        max_iter = 100,\n        verbose = false,\n        print_level = 1,\n    )\n    dur = sum(get_timesteps(get_trajectory(qcp_mt)))\n    push!(results, (target = target_fidelity, duration = dur, achieved = fidelity(qcp_mt)))\nend\n\nprintln(\"Fidelity-Time Trade-off\")\nprintln(\"‚îÄ\"^50)\nfor r in results\n    @printf(\n        \"  Target: %.3f  ‚îÇ  Duration: %.3f  ‚îÇ  Achieved: %.4f\\n\",\n        r.target,\n        r.duration,\n        r.achieved\n    )\nend","category":"section"},{"location":"generated/problem-templates/minimum_time/#With-Robust-Optimization","page":"MinimumTimeProblem","title":"With Robust Optimization","text":"Chain with SamplingProblem for robust time-optimal control:\n\n# Base problem\nqcp_base = SmoothPulseProblem(qtraj, N; Q=100.0, Œît_bounds=(0.05, 0.5))\nsolve!(qcp_base; max_iter=100)\n\n# Add robustness\nsys_perturbed = QuantumSystem(1.1 * H_drift, H_drives, [1.0, 1.0])\nqcp_robust = SamplingProblem(qcp_base, [sys, sys_perturbed])\nsolve!(qcp_robust; max_iter=100)\n\n# Minimize time while maintaining robustness\nqcp_mintime = MinimumTimeProblem(qcp_robust; final_fidelity=0.95)\nsolve!(qcp_mintime; max_iter=100)","category":"section"},{"location":"generated/problem-templates/minimum_time/#Fidelity-Constraints-by-Trajectory-Type","page":"MinimumTimeProblem","title":"Fidelity Constraints by Trajectory Type","text":"MinimumTimeProblem automatically adds the appropriate fidelity constraint based on the trajectory type:\n\nTrajectory Type Constraint Type\nUnitaryTrajectory FinalUnitaryFidelityConstraint\nKetTrajectory FinalKetFidelityConstraint\nMultiKetTrajectory FinalCoherentKetFidelityConstraint\nDensityTrajectory Not yet implemented","category":"section"},{"location":"generated/problem-templates/minimum_time/#Tips","page":"MinimumTimeProblem","title":"Tips","text":"","category":"section"},{"location":"generated/problem-templates/minimum_time/#Setting-D","page":"MinimumTimeProblem","title":"Setting D","text":"The D parameter controls the weight on total time:\n\nHigher D (e.g., 1000): Aggressively minimize time, may sacrifice fidelity margin\nLower D (e.g., 10): More conservative, maintains fidelity buffer","category":"section"},{"location":"generated/problem-templates/minimum_time/#Initial-Solution-Quality","page":"MinimumTimeProblem","title":"Initial Solution Quality","text":"MinimumTimeProblem works best when starting from a good solution. If your base problem has low fidelity, solve it first:\n\n# Ensure good initial solution\nqcp_base = SmoothPulseProblem(qtraj, N; Q=1000.0, Œît_bounds=(0.05, 0.5))\nsolve!(qcp_base; max_iter=200)\n\n# Only then minimize time\nif fidelity(qcp_base) > 0.99\n    qcp_mintime = MinimumTimeProblem(qcp_base; final_fidelity=0.99)\n    solve!(qcp_mintime; max_iter=100)\nend","category":"section"},{"location":"generated/problem-templates/minimum_time/#Changing-the-Goal","page":"MinimumTimeProblem","title":"Changing the Goal","text":"You can optimize for a different goal without recreating the base problem:\n\nqcp_y = MinimumTimeProblem(qcp_base; goal = GATES[:Y], final_fidelity = 0.99)\ncached_solve!(qcp_y, \"mintime_y_gate\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/minimum_time/#See-Also","page":"MinimumTimeProblem","title":"See Also","text":"SmoothPulseProblem - Base problem for piecewise constant controls\nBangBangPulseProblem - Base problem for bang-bang controls\nSplinePulseProblem - Base problem for spline controls\nSamplingProblem - Add robustness before minimizing time\nComposing Templates - Advanced composition patterns\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/first_gate/#first-gate-tutorial","page":"Your First Gate","title":"Your First Gate","text":"This tutorial walks through synthesizing your first quantum gate with Piccolo.jl. We'll implement an X gate (NOT gate) on a single qubit.","category":"section"},{"location":"generated/first_gate/#What-We're-Doing","page":"Your First Gate","title":"What We're Doing","text":"We want to find control pulses that implement:\n\nX = beginpmatrix 0  1  1  0 endpmatrix\n\nOur qubit has Hamiltonian:\n\nH(t) = fracomega2sigma_z + u_x(t)sigma_x + u_y(t)sigma_y\n\nThe optimizer will find u_x(t) and u_y(t) that produce the X gate.","category":"section"},{"location":"generated/first_gate/#Setup","page":"Your First Gate","title":"Setup","text":"First, load the required packages:\n\nusing Piccolo\nusing CairoMakie\nusing Random\nRandom.seed!(42)  # For reproducibility","category":"section"},{"location":"generated/first_gate/#Step-1:-Define-the-Quantum-System","page":"Your First Gate","title":"Step 1: Define the Quantum System","text":"A QuantumSystem needs:\n\nDrift Hamiltonian: Always-on terms (qubit frequency)\nDrive Hamiltonians: Controllable interactions\nDrive bounds: Maximum control amplitudes\n\n# The drift Hamiltonian: œâ/2 œÉ_z (qubit frequency)\n# We set œâ = 1.0 for simplicity\nH_drift = 0.5 * PAULIS[:Z]\n\n# The drive Hamiltonians: œÉ_x and œÉ_y controls\nH_drives = [PAULIS[:X], PAULIS[:Y]]\n\n# Maximum amplitude for each drive (in same units as H_drift)\ndrive_bounds = [1.0, 1.0]\n\n# Create the system\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\n\nLet's check what we created:\n\nsys.levels, sys.n_drives","category":"section"},{"location":"generated/first_gate/#Step-2:-Create-an-Initial-Pulse","page":"Your First Gate","title":"Step 2: Create an Initial Pulse","text":"We need an initial guess for the control pulse. ZeroOrderPulse represents piecewise constant controls - the standard choice for most problems.\n\n# Gate duration and discretization\nT = 10.0   # Total time (in units where œâ = 1)\nN = 100    # Number of timesteps\n\n# Time vector\ntimes = collect(range(0, T, length = N))\n\n# Random initial controls (small amplitude)\n# Shape: (n_drives, N) = (2, 100)\ninitial_controls = 0.1 * randn(2, N)\n\n# Create the pulse\npulse = ZeroOrderPulse(initial_controls, times)\n\nCheck the pulse:\n\nduration(pulse)\n\nn_drives(pulse)\n\npulse(5.0)","category":"section"},{"location":"generated/first_gate/#Step-3:-Define-the-Goal","page":"Your First Gate","title":"Step 3: Define the Goal","text":"A UnitaryTrajectory combines the system, pulse, and target gate.\n\n# Our target: the X gate\nU_goal = GATES[:X]\n\nU_goal\n\n# Create the trajectory\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)","category":"section"},{"location":"generated/first_gate/#Step-4:-Set-Up-the-Optimization-Problem","page":"Your First Gate","title":"Step 4: Set Up the Optimization Problem","text":"SmoothPulseProblem creates an optimization problem with:\n\nFidelity objective (weight Q)\nControl regularization (weight R)\nSmoothness via derivative bounds\n\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,       # Fidelity weight (higher = prioritize fidelity)\n    R = 1e-2,        # Regularization weight (higher = smoother controls)\n    ddu_bound = 1.0,  # Limit on control acceleration\n)","category":"section"},{"location":"generated/first_gate/#Step-5:-Solve!","page":"Your First Gate","title":"Step 5: Solve!","text":"The solve! function runs the optimizer:\n\ncached_solve!(qcp, \"first_gate\"; max_iter = 20, verbose = false, print_level = 1)","category":"section"},{"location":"generated/first_gate/#Step-6:-Analyze-the-Results","page":"Your First Gate","title":"Step 6: Analyze the Results","text":"First, check the fidelity:\n\nfidelity(qcp)\n\nGet the optimized trajectory:\n\ntraj = get_trajectory(qcp)\n\n# Check the final unitary\nU_final = iso_vec_to_operator(traj[:≈®‚Éó][:, end])\nround.(U_final, digits = 3)","category":"section"},{"location":"generated/first_gate/#Step-7:-Visualize","page":"Your First Gate","title":"Step 7: Visualize","text":"Plot the optimized control pulses:\n\nfig = Figure(size = (800, 400))\n\n# Time axis\nplot_times = cumsum([0; get_timesteps(traj)])[1:(end-1)]\n\n# Control pulses\nax1 = Axis(\n    fig[1, 1],\n    xlabel = \"Time\",\n    ylabel = \"Control Amplitude\",\n    title = \"Optimized Controls\",\n)\nlines!(ax1, plot_times, traj[:u][1, :], label = \"u_x (œÉ_x drive)\", linewidth = 2)\nlines!(ax1, plot_times, traj[:u][2, :], label = \"u_y (œÉ_y drive)\", linewidth = 2)\naxislegend(ax1, position = :rt)\n\nfig","category":"section"},{"location":"generated/first_gate/#Understanding-the-Solution","page":"Your First Gate","title":"Understanding the Solution","text":"The optimizer found control pulses that:\n\nStart and end smoothly (due to derivative regularization)\nStay within bounds (due to drive_bounds)\nAchieve high fidelity (due to the Q-weighted objective)\n\nThe X gate rotates the qubit state around the X-axis by œÄ radians. You can see the controls create the right rotation!","category":"section"},{"location":"generated/first_gate/#What's-Next?","page":"Your First Gate","title":"What's Next?","text":"Now that you've synthesized your first gate, try:\n\nDifferent gates: Change U_goal to GATES[:H] (Hadamard) or GATES[:T]\nFaster gates: Reduce T and see how fidelity changes\nSmoother pulses: Increase R or decrease ddu_bound\nTime-optimal: Add Œît_bounds and use MinimumTimeProblem\n\nContinue to the State Transfer tutorial to learn about preparing specific quantum states.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
