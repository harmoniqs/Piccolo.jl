var documenterSearchIndex = {"docs":
[{"location":"generated/multilevel_transmon/#multilevel-transmon-tutorial","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"In this example we will look at a multilevel transmon qubit with a Hamiltonian given by\n\nhatH(t) = -fracdelta2 hatn(hatn - 1) + u_1(t) (hata + hata^dagger) + u_2(t) i (hata - hata^dagger)\n\nwhere hatn = hata^dagger hata is the number operator, hata is the annihilation operator, delta is the anharmonicity, and u_1(t) and u_2(t) are control fields.\n\nWe will use the following parameter values:\n\nbeginaligned\ndelta = 02 text GHz\nabsu_i(t) leq 02 text GHz\nT_0 = 10 text ns\nendaligned\n\nFor convenience, we have defined the TransmonSystem function in the QuantumSystemTemplates module, which returns a QuantumSystem object for a transmon qubit. We will use this function to define the system.","category":"section"},{"location":"generated/multilevel_transmon/#Setting-up-the-problem","page":"Multilevel Transmon","title":"Setting up the problem","text":"To begin, let's load the necessary packages, define the system parameters, and create a QuantumSystem object using the TransmonSystem function.\n\nusing Piccolo\nusing SparseArrays\nusing Random;\nRandom.seed!(123);\n\nusing CairoMakie\n\n# define the time parameters\n\nT‚ÇÄ = 10     # total time in ns\nN = 50      # number of time steps\nŒît = T‚ÇÄ / N # time step\ntimes = collect(range(0, T‚ÇÄ, length = N))\n\n# define the system parameters\nlevels = 5\nŒ¥ = 0.2\n\n# add a bound to the controls\nu_bound = [0.2, 0.2]\nddu_bound = 1.0\n\n# create the system\nsys = TransmonSystem(drive_bounds = u_bound, levels = levels, Œ¥ = Œ¥)\n\n# let's look at the drives of the system\nget_drives(sys)[1] |> sparse\n\nSince this is a multilevel transmon and we want to implement an, let's say, X gate on the qubit subspace, i.e., the first two levels we can utilize the EmbeddedOperator type to define the target operator.\n\n# define the target operator\nop = EmbeddedOperator(:X, sys)\n\n# show the full operator\nop.operator |> sparse\n\nWe can then create a pulse, trajectory, and optimization problem using the new API:\n\n# create a random initial pulse\ninitial_controls = 0.1 * randn(2, N)\npulse = ZeroOrderPulse(initial_controls, times)\n\n# create a unitary trajectory with the embedded operator as goal\nqtraj = UnitaryTrajectory(sys, pulse, op)\n\n# create the optimization problem\nqcp = SmoothPulseProblem(qtraj, N; ddu_bound = ddu_bound, Q = 100.0, R = 1e-2)","category":"section"},{"location":"generated/multilevel_transmon/#Solving-the-problem","page":"Multilevel Transmon","title":"Solving the problem","text":"# We solve the problem using `cached_solve!`, which transparently caches the\n# optimized trajectory and solver output for docs purposes. In practice, you can use `solve!` directly.\n\ncached_solve!(qcp, \"multilevel_transmon\"; max_iter = 50)\n\nAfter optimization, we can check the fidelity in the subspace:\n\nfid = fidelity(qcp)\nprintln(\"Fidelity: \", fid)","category":"section"},{"location":"generated/multilevel_transmon/#Leakage-suppression","page":"Multilevel Transmon","title":"Leakage suppression","text":"As can be seen from multilevel systems, there can be substantial leakage into higher energy levels during the evolution. To mitigate this, Piccolo provides options to add leakage suppression via the PiccoloOptions type.\n\nTo implement leakage suppression, pass leakage_constraint=true and configure the leakage parameters:\n\n# create a leakage suppression problem\nqcp_leakage = SmoothPulseProblem(\n    qtraj,\n    N;\n    ddu_bound = ddu_bound,\n    Q = 100.0,\n    R = 1e-2,\n    piccolo_options = PiccoloOptions(\n        leakage_constraint = true,\n        leakage_constraint_value = 1e-2,\n        leakage_cost = 1e-2,\n    ),\n)\n\n# solve the problem\ncached_solve!(qcp_leakage, \"multilevel_transmon_leakage\"; max_iter = 50)\n\nThe leakage suppression adds:\n\nAn L1-norm cost on populating leakage levels (drives populations toward zero)\nA constraint that keeps leakage below the specified threshold\n\nfid_leakage = fidelity(qcp_leakage)\nprintln(\"Fidelity with leakage suppression: \", fid_leakage)","category":"section"},{"location":"generated/multilevel_transmon/#Visualizing-Results","page":"Multilevel Transmon","title":"Visualizing Results","text":"Piccolo provides plotting utilities to visualize the unitary evolution. First, without leakage suppression:\n\nplot_unitary_populations(get_trajectory(qcp); fig_size = (900, 700))\n\nAnd with leakage suppression ‚Äî you should see the population staying mostly within the computational subspace (first two levels):\n\nplot_unitary_populations(get_trajectory(qcp_leakage); fig_size = (900, 700))","category":"section"},{"location":"generated/multilevel_transmon/#Summary","page":"Multilevel Transmon","title":"Summary","text":"This tutorial demonstrated:\n\nUsing TransmonSystem to create a realistic multilevel transmon system\nUsing EmbeddedOperator to define gates on a subspace\nCreating UnitaryTrajectory with ZeroOrderPulse\nUsing SmoothPulseProblem to set up the optimization\nAdding leakage suppression via PiccoloOptions\n\nFor more details on:\n\nProblem templates: See SmoothPulseProblem\nLeakage suppression: See Leakage Suppression\nSystem templates: See System Templates\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"lib/#Library-Reference","page":"Library","title":"Library Reference","text":"Full docstring reference for all public types and functions in Piccolo.jl.","category":"section"},{"location":"lib/#lib-quantum-systems","page":"Library","title":"Quantum Systems","text":"","category":"section"},{"location":"lib/#lib-quantum-system-templates","page":"Library","title":"Quantum System Templates","text":"","category":"section"},{"location":"lib/#lib-quantum-system-utils","page":"Library","title":"Quantum System Utilities","text":"","category":"section"},{"location":"lib/#lib-gates","page":"Library","title":"Gates and Pauli Matrices","text":"","category":"section"},{"location":"lib/#lib-quantum-object-utils","page":"Library","title":"Quantum Object Utilities","text":"","category":"section"},{"location":"lib/#lib-trajectories","page":"Library","title":"Trajectories","text":"","category":"section"},{"location":"lib/#lib-pulses","page":"Library","title":"Pulses","text":"","category":"section"},{"location":"lib/#lib-rollouts","page":"Library","title":"Rollouts","text":"","category":"section"},{"location":"lib/#lib-embedded-operators","page":"Library","title":"Embedded Operators","text":"","category":"section"},{"location":"lib/#lib-lifted-operators","page":"Library","title":"Lifted Operators","text":"","category":"section"},{"location":"lib/#lib-direct-sums","page":"Library","title":"Direct Sums","text":"","category":"section"},{"location":"lib/#lib-isomorphisms","page":"Library","title":"Isomorphisms","text":"","category":"section"},{"location":"lib/#lib-quantum-control-problems","page":"Library","title":"Quantum Control Problems","text":"","category":"section"},{"location":"lib/#lib-problem-templates","page":"Library","title":"Problem Templates","text":"","category":"section"},{"location":"lib/#lib-objectives","page":"Library","title":"Objectives","text":"","category":"section"},{"location":"lib/#lib-constraints","page":"Library","title":"Constraints","text":"","category":"section"},{"location":"lib/#lib-options","page":"Library","title":"Options","text":"","category":"section"},{"location":"lib/#lib-visualizations","page":"Library","title":"Visualizations","text":"","category":"section"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.AbstractQuantumSystem","page":"Library","title":"Piccolo.Quantum.QuantumSystems.AbstractQuantumSystem","text":"AbstractQuantumSystem\n\nAbstract type for defining systems.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem","page":"Library","title":"Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem <: AbstractQuantumSystem\n\nA composite quantum system consisting of multiple subsystems with optional coupling terms.\n\nComposite systems represent multiple quantum subsystems (e.g., multiple qubits or oscillators) that may be coupled together. Each subsystem's Hamiltonians are automatically lifted to the  full tensor product space, and subsystem drives are appended to any coupling drives.\n\nFields\n\nH::Function: The total Hamiltonian function: (u, t) -> H(u, t)\nG::Function: The isomorphic generator function: (u, t) -> G(u, t)\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The total drift Hamiltonian including subsystem drifts and couplings\nH_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}: All drive Hamiltonians (coupling drives + subsystem drives)\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds for each control\nn_drives::Int: Total number of control drives\nlevels::Int: Total dimension of the composite system (product of subsystem dimensions)\nsubsystem_levels::Vector{Int}: Dimensions of each subsystem\nsubsystems::Vector{QuantumSystem}: The individual quantum subsystems\n\nSee also Lifted Operators, lift_operator.\n\nExample\n\n# Two qubits with ZZ coupling\nsys1 = QuantumSystem([PAULIS[:X]], [(-1.0, 1.0)])\nsys2 = QuantumSystem([PAULIS[:Y]], [(-1.0, 1.0)])\nH_coupling = 0.1 * kron(PAULIS[:Z], PAULIS[:Z])\ncsys = CompositeQuantumSystem(H_coupling, [sys1, sys2], Float64[])\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}, AbstractVector{<:QuantumSystem}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    H_drift::AbstractMatrix,\n    H_drives::AbstractVector{<:AbstractMatrix},\n    subsystems::AbstractVector{<:QuantumSystem},\n    drive_bounds::DriveBounds\n)\n\nConstruct a CompositeQuantumSystem with coupling drift and drive terms.\n\nArguments\n\nH_drift::AbstractMatrix: Coupling drift Hamiltonian (in full tensor product space)\nH_drives::AbstractVector{<:AbstractMatrix}: Coupling drive Hamiltonians\nsubsystems::AbstractVector{<:QuantumSystem}: Vector of subsystems to compose\ndrive_bounds::DriveBounds: Drive bounds for the coupling drives (subsystem bounds are inherited). Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nThe total drift includes both the coupling drift and all subsystem drifts (automatically lifted). The total drives include coupling drives followed by all subsystem drives (automatically lifted).\n\nExample\n\nsys1 = QuantumSystem(PAULIS[:Z], [PAULIS[:X]], [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], [1.0])\ng12 = 0.1 * kron(PAULIS[:X], PAULIS[:X])  # coupling drift\ncsys = CompositeQuantumSystem(g12, Matrix{ComplexF64}[], [sys1, sys2], Float64[])\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Tuple{AbstractVector{<:QuantumSystem}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    subsystems::AbstractVector{<:QuantumSystem},\n    drive_bounds::DriveBounds\n)\n\nConvenience constructor for a composite system with no coupling terms (neither drift nor drives).\n\nUse this when you have independent subsystems that you want to represent in a single composite space, but without any direct coupling between them.\n\nArguments\n\nsubsystems::AbstractVector{<:QuantumSystem}: Vector of subsystems to compose\ndrive_bounds::DriveBounds: Drive bounds for the coupling drives (typically empty). Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], [1.0])\ncsys = CompositeQuantumSystem([sys1, sys2], Float64[])\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{<:QuantumSystem}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where T<:Number","page":"Library","title":"Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    H_drift::AbstractMatrix,\n    subsystems::AbstractVector{<:QuantumSystem},\n    drive_bounds::DriveBounds\n)\n\nConvenience constructor for a composite system with coupling drift but no coupling drives.\n\nArguments\n\nH_drift::AbstractMatrix: Coupling drift Hamiltonian\nsubsystems::AbstractVector{<:QuantumSystem}: Vector of subsystems to compose\ndrive_bounds::DriveBounds: Drive bounds for the coupling drives (typically empty). Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], [1.0])\nH_coupling = 0.1 * kron(PAULIS[:Z], PAULIS[:Z])  # coupling drift\ncsys = CompositeQuantumSystem(H_coupling, [sys1, sys2], Float64[])\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem-Union{Tuple{T}, Tuple{AbstractVector{<:AbstractMatrix{T}}, AbstractVector{<:QuantumSystem}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where T<:Number","page":"Library","title":"Piccolo.Quantum.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    H_drives::AbstractVector{<:AbstractMatrix},\n    subsystems::AbstractVector{<:QuantumSystem},\n    drive_bounds::DriveBounds\n)\n\nConvenience constructor for a composite system with coupling drives but no coupling drift.\n\nArguments\n\nH_drives::AbstractVector{<:AbstractMatrix}: Coupling drive Hamiltonians\nsubsystems::AbstractVector{<:QuantumSystem}: Vector of subsystems to compose\ndrive_bounds::DriveBounds: Drive bounds for the coupling drives. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], [1.0])\ng12 = 0.1 * kron(PAULIS[:X], PAULIS[:X])  # coupling drive\ncsys = CompositeQuantumSystem([g12], [sys1, sys2], [1.0])  # symmetric bound\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.DriveBounds","page":"Library","title":"Piccolo.Quantum.QuantumSystems.DriveBounds","text":"DriveBounds\n\nType alias for drive amplitude bounds input. Bounds can be specified as:\n\nA tuple (lower, upper) for asymmetric bounds\nA scalar value which is interpreted as symmetric bounds (-value, value)\n\nExamples\n\ndrive_bounds = [(-1.0, 1.0), 0.5, (-0.3, 0.7)]\n# Interpreted as: [(-1.0, 1.0), (-0.5, 0.5), (-0.3, 0.7)]\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","page":"Library","title":"Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem <: AbstractQuantumSystem\n\nA struct for storing open quantum dynamics.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t)\nùí¢::Function: The Lindbladian generator function: u -> ùí¢(u)\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The drift Hamiltonian\nH_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}: The drive Hamiltonians\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds\nn_drives::Int: The number of control drives\nlevels::Int: The number of levels in the system\ndissipation_operators::Vector{SparseMatrixCSC{ComplexF64, Int}}: The dissipation operators\ntime_dependent::Bool: Whether the Hamiltonian has explicit time dependence\n\nSee also QuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Tuple{AbstractMatrix{<:Number}, Vector{<:AbstractMatrix{<:Number}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::AbstractVector{<:AbstractMatrix{<:Number}},\n    drive_bounds::DriveBounds;\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],\n    time_dependent::Bool=false\n)\nOpenQuantumSystem(\n    H_drift::AbstractMatrix{<:Number};\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],\n    time_dependent::Bool=false\n)\nOpenQuantumSystem(\n    H_drives::Vector{<:AbstractMatrix{<:Number}},\n    drive_bounds::DriveBounds;\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],\n    time_dependent::Bool=false\n)\nOpenQuantumSystem(\n    H::Function, \n    drive_bounds::DriveBounds;\n    dissipation_operators::Vector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],\n    time_dependent::Bool=false\n)\nOpenQuantumSystem(\n    system::QuantumSystem; \n    dissipation_operators::Vector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[]\n)\n\nConstructs an OpenQuantumSystem object from the drift and drive Hamiltonian terms and dissipation operators.\n\nDrive Bounds\n\nThe drive_bounds parameter can be:\n\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Tuple{QuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(system::QuantumSystem; dissipation_operators=[])\n\nConstruct an OpenQuantumSystem from a QuantumSystem by adding dissipation operators.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(H_drift; dissipation_operators=[], time_dependent=false)\n\nConstruct an OpenQuantumSystem with only drift (no drives).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{F}, Tuple{F, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where {F<:Function, ‚ÑÇ<:Number}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(H::Function, drive_bounds; dissipation_operators=[], time_dependent=false)\n\nConstruct an OpenQuantumSystem from a Hamiltonian function.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.OpenQuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{Vector{<:AbstractMatrix{‚ÑÇ}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where ‚ÑÇ<:Number","page":"Library","title":"Piccolo.Quantum.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(H_drives, drive_bounds; dissipation_operators=[], time_dependent=false)\n\nConstruct an OpenQuantumSystem with no drift.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.QuantumSystem","page":"Library","title":"Piccolo.Quantum.QuantumSystems.QuantumSystem","text":"QuantumSystem <: AbstractQuantumSystem\n\nA struct for storing quantum dynamics.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t), where u is the control vector and t is time\nG::Function: The isomorphic generator function: (u, t) -> G(u, t), including the Hamiltonian mapped to superoperator space\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The drift Hamiltonian (time-independent component)\nH_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}: The drive Hamiltonians (control-dependent components)\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds for each control (lower, upper)\nn_drives::Int: The number of control drives in the system\nlevels::Int: The number of levels (dimension) in the system\ntime_dependent::Bool: Whether the Hamiltonian has explicit time dependence beyond control modulation\nglobal_params::NamedTuple: Global parameters that the Hamiltonian may depend on (e.g., (Œ¥=0.5, Œ©=1.0))\n\nSee also OpenQuantumSystem, VariationalQuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.QuantumSystem-Tuple{AbstractMatrix{<:Number}, Vector{<:AbstractMatrix{<:Number}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.QuantumSystem","text":"QuantumSystem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::Vector{<:AbstractMatrix{<:Number}},\n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}};\n    time_dependent::Bool=false\n)\n\nConstruct a QuantumSystem from drift and drive Hamiltonian terms.\n\nArguments\n\nH_drift::AbstractMatrix: The drift (time-independent) Hamiltonian\nH_drives::Vector{<:AbstractMatrix}: Vector of drive Hamiltonians, one for each control\ndrive_bounds::DriveBounds: Drive amplitude bounds for each control. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nKeyword Arguments\n\ntime_dependent::Bool=false: Set to true if using time-dependent modulation (typically handled at a higher level)\nglobal_params::NamedTuple=NamedTuple(): Global parameters stored with the system. Note: for matrix-based systems, matrices are fixed at construction, so globalparams are mainly for storage/bookkeeping and later updates via `updateglobal_params!`\n\nThe resulting Hamiltonian is: H(u, t) = Hdrift + Œ£·µ¢ u·µ¢ * Hdrives[i]\n\nExample\n\nsys = QuantumSystem(\n    PAULIS[:Z],                    # drift\n    [PAULIS[:X], PAULIS[:Y]],      # drives\n    [1.0, 1.0]                     # symmetric bounds: [(-1.0, 1.0), (-1.0, 1.0)]\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.QuantumSystem-Tuple{Function, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.QuantumSystem","text":"QuantumSystem(H::Function, drive_bounds::Vector; time_dependent::Bool=false)\n\nConstruct a QuantumSystem from a Hamiltonian function.\n\nArguments\n\nH::Function: Hamiltonian function with signature (u, t) -> H(u, t) where:\nu is a vector containing [controls..., globals...] (if system has global parameters)\nFor matrix-based systems, only the first n_drives elements are used for controls\nFor function-based systems, handle globals via closure or by accessing u beyond control indices\nt is time\ndrive_bounds::DriveBounds: Drive amplitude bounds for each control. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nKeyword Arguments\n\ntime_dependent::Bool=false: Set to true if the Hamiltonian has explicit time dependence (e.g., cos(œât) modulation)\nglobal_params::NamedTuple=NamedTuple(): Global parameters stored with the system for bookkeeping\n\nExample\n\n# Define a time-dependent Hamiltonian\nH = (u, t) -> PAULIS[:Z] + u[1] * cos(œâ * t) * PAULIS[:X]\nsys = QuantumSystem(H, [(-1.0, 1.0)]; time_dependent=true)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.QuantumSystem-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"Piccolo.Quantum.QuantumSystems.QuantumSystem","text":"QuantumSystem(H_drift::AbstractMatrix; time_dependent::Bool=false)\n\nConvenience constructor for a system with only a drift Hamiltonian (no drives).\n\nExample\n\nsys = QuantumSystem(PAULIS[:Z])\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.QuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{Vector{<:AbstractMatrix{‚ÑÇ}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where ‚ÑÇ<:Number","page":"Library","title":"Piccolo.Quantum.QuantumSystems.QuantumSystem","text":"QuantumSystem(H_drives::Vector{<:AbstractMatrix}, drive_bounds::Vector; time_dependent::Bool=false)\n\nConvenience constructor for a system with no drift Hamiltonian (H_drift = 0).\n\nArguments\n\nH_drives::Vector{<:AbstractMatrix}: Vector of drive Hamiltonians\ndrive_bounds::DriveBounds: Drive amplitude bounds for each control. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nExample\n\n# Using scalars for symmetric bounds\nsys = QuantumSystem([PAULIS[:X], PAULIS[:Y]], [1.0, 1.0])\n# Equivalent to: drive_bounds = [(-1.0, 1.0), (-1.0, 1.0)]\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem","page":"Library","title":"Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem","text":"VariationalQuantumSystem <: AbstractQuantumSystem\n\nA struct for storing variational quantum dynamics, used for sensitivity and robustness analysis.\n\nVariational systems allow exploring how the dynamics change under perturbations to the Hamiltonian. The variational operators represent directions of uncertainty or perturbation in the system.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t)\nG::Function: The isomorphic generator function: (u, t) -> G(u, t)\nG_vars::AbstractVector{<:Function}: Variational generator functions, one for each perturbation direction\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds\nn_drives::Int: The number of control drives in the system\nlevels::Int: The number of levels (dimension) in the system\n\nSee also QuantumSystem, OpenQuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}, AbstractVector{<:AbstractMatrix{<:Number}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.VariationalQuantumSystem","text":"VariationalQuantumSystem(\n    H_drift::AbstractMatrix,\n    H_drives::AbstractVector{<:AbstractMatrix},\n    H_vars::AbstractVector{<:AbstractMatrix},\n    drive_bounds::DriveBounds\n)\n\nConstruct a VariationalQuantumSystem from drift, drive, and variational Hamiltonian terms.\n\nArguments\n\nH_drift::AbstractMatrix: The drift (time-independent) Hamiltonian\nH_drives::AbstractVector{<:AbstractMatrix}: Vector of drive Hamiltonians for control\nH_vars::AbstractVector{<:AbstractMatrix}: Vector of variational Hamiltonians representing perturbation directions\ndrive_bounds::DriveBounds: Drive amplitude bounds for each control. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nThe variational operators allow sensitivity analysis by exploring how dynamics change under perturbations: Hperturbed = H + Œ£·µ¢ Œµ·µ¢ * Hvars[i]\n\nExample\n\nvarsys = VariationalQuantumSystem(\n    PAULIS[:Z],                    # drift\n    [PAULIS[:X], PAULIS[:Y]],      # drives\n    [PAULIS[:X]],                  # variational perturbations\n    [1.0, 1.0]                     # symmetric bounds: [(-1.0, 1.0), (-1.0, 1.0)]\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.get_drift-Tuple{AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.get_drift","text":"get_drift(sys::AbstractQuantumSystem)\n\nReturns the drift Hamiltonian of the system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.get_drives-Tuple{AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.get_drives","text":"get_drives(sys::AbstractQuantumSystem)\n\nReturns the drive Hamiltonians of the system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.is_hermitian-Tuple{AbstractMatrix}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.is_hermitian","text":"is_hermitian(H::AbstractMatrix; tol=1e-10)\n\nCheck if a matrix is Hermitian within a tolerance.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystems.normalize_drive_bounds-Tuple{Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystems.normalize_drive_bounds","text":"normalize_drive_bounds(bounds::DriveBounds)\n\nConvert drive bounds to a consistent tuple format. Scalar values are converted to  symmetric bounds around zero: b becomes (-b, b).\n\nArguments\n\nbounds::DriveBounds: Input bounds, can be tuples or scalars\n\nReturns\n\nVector{Tuple{Float64, Float64}}: Normalized bounds as tuples\n\nExamples\n\n# All scalars (symmetric bounds)\nnormalize_drive_bounds([1.0, 1.5, 0.5])\n# Returns: [(-1.0, 1.0), (-1.5, 1.5), (-0.5, 0.5)]\n\n# All tuples (asymmetric bounds)\nnormalize_drive_bounds([(-2.0, 3.0), (-1.0, 1.0)])\n# Returns: [(-2.0, 3.0), (-1.0, 1.0)]\n\n# Mixed types (requires explicit type annotation)\nnormalize_drive_bounds(Union{Float64, Tuple{Float64,Float64}}[1.0, (-2.0, 3.0)])\n# Returns: [(-1.0, 1.0), (-2.0, 3.0)]\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.CatSystem-Tuple{}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.CatSystem","text":"CatSystem(;\n    g2::Real=0.36,\n    œá_aa::Real=-7e-3,\n    œá_bb::Real=-32,\n    œá_ab::Real=0.79,\n    Œ∫a::Real=53e-3,\n    Œ∫b::Real=13,\n    cat_levels::Int=13,\n    buffer_levels::Int=3,\n    prefactor::Real=1,\n)::OpenQuantumSystem\n\nReturns an OpenQuantumSystem for a quantum cat.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.IonChainSystem-Tuple{}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.IonChainSystem","text":"IonChainSystem(;\n    N_ions::Int=2,\n    ion_levels::Int=2,\n    N_modes::Int=1,\n    mode_levels::Int=10,\n    œâq::Union{Float64, Vector{Float64}}=1.0,\n    œâm::Union{Float64, Vector{Float64}}=0.1,\n    Œ∑::Union{Float64, Matrix{Float64}}=0.1,\n    lab_frame::Bool=false,\n    frame_œâ::Float64=lab_frame ? 0.0 : (œâq isa Vector ? œâq[1] : œâq),\n    multiply_by_2œÄ::Bool=true,\n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}}=fill(1.0, 2*N_ions),\n) -> QuantumSystem\n\nReturns a QuantumSystem object for a chain of trapped ions coupled via motional modes.\n\nThe system consists of N_ions ions, each with ion_levels internal states, coupled to  N_modes shared motional modes with mode_levels Fock states each.\n\nHamiltonian\n\nIn the lab frame:\n\nH = sum_i=1^N_textions omega_qi sigma_i^+ sigma_i^- \n    + sum_m=1^N_textmodes omega_m a_m^dagger a_m\n    + sum_im eta_im (sigma_i^+ + sigma_i^-)(a_m + a_m^dagger)\n    + sum_i Omega_xi(t) sigma_i^x + sum_i Omega_yi(t) sigma_i^y\n\nIn the rotating frame at frequency frame_œâ:\n\nH = sum_i=1^N_textions (omega_qi - omega_textframe) sigma_i^+ sigma_i^- \n    + sum_m=1^N_textmodes omega_m a_m^dagger a_m\n    + sum_im eta_im (sigma_i^+ + sigma_i^-)(a_m + a_m^dagger)\n    + sum_i Omega_xi(t) sigma_i^x + sum_i Omega_yi(t) sigma_i^y\n\nwhere:\n\nsigma_i^+ sigma_i^- are raising/lowering operators for ion i\nsigma_i^x sigma_i^y are Pauli operators for ion i\na_m a_m^dagger are annihilation/creation operators for mode m\nomega_qi is the transition frequency of ion i\nomega_m is the frequency of motional mode m\neta_im is the Lamb-Dicke parameter coupling ion i to mode m\n\nKeyword Arguments\n\nN_ions: Number of ions in the chain\nion_levels: Number of internal levels per ion (typically 2 for qubit)\nN_modes: Number of motional modes to include\nmode_levels: Number of Fock states per motional mode\nœâq: Ion transition frequency (or frequencies). Scalar or vector of length N_ions. In GHz.\nœâm: Motional mode frequency (or frequencies). Scalar or vector of length N_modes. In GHz.\nŒ∑: Lamb-Dicke parameter(s). Scalar (uniform coupling), or N_ions √ó N_modes matrix.\nlab_frame: If true, use lab frame Hamiltonian. If false, use rotating frame.\nframe_œâ: Rotating frame frequency in GHz. Defaults to first ion frequency.\nmultiply_by_2œÄ: Whether to multiply Hamiltonian by 2œÄ (default true, since frequencies are in GHz).\ndrive_bounds: Control bounds. Vector of length 2*N_ions for [Œ©x‚ÇÅ, Œ©y‚ÇÅ, Œ©x‚ÇÇ, Œ©y‚ÇÇ, ...].\n\nExample\n\n# Two ions, one motional mode, M√∏lmer-S√∏rensen setup\nsys = IonChainSystem(\n    N_ions=2,\n    N_modes=1,\n    œâq=1.0,      # 1 GHz qubit frequency\n    œâm=0.1,      # 100 MHz mode frequency  \n    Œ∑=0.1,       # Lamb-Dicke parameter\n    mode_levels=5,\n)\n\nReferences\n\nS√∏rensen, A. & M√∏lmer, K. \"Quantum computation with ions in thermal motion.\"  Phys. Rev. Lett. 82, 1971 (1999).\nS√∏rensen, A. & M√∏lmer, K. \"Entanglement and quantum computation with ions in thermal motion.\" Phys. Rev. A 62, 022311 (2000).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.MolmerSorensenCoupling-Tuple{Int64, Int64, Int64, Int64, Union{Float64, Matrix{Float64}}, Union{Float64, Vector{Float64}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.MolmerSorensenCoupling","text":"MolmerSorensenCoupling(\n    N_ions::Int,\n    N_modes::Int,\n    ion_levels::Int,\n    mode_levels::Int,\n    Œ∑::Union{Float64, Matrix{Float64}},\n    œâm::Union{Float64, Vector{Float64}},\n) -> Matrix{ComplexF64}\n\nReturns the M√∏lmer-S√∏rensen coupling term for an ion chain, which mediates  effective ion-ion interactions via the motional modes.\n\nIn the Lamb-Dicke regime with appropriate drive detunings, the effective Hamiltonian is:\n\nH_textMS = sum_ij J_ij sigma_i^x sigma_j^x\n\nwhere the coupling strength is:\n\nJ_ij = sum_m fraceta_im eta_jm Omega_i Omega_j4 Delta_m\n\nwith Delta_m being the detuning from mode m.\n\nArguments\n\nN_ions: Number of ions\nN_modes: Number of motional modes\nion_levels: Internal levels per ion\nmode_levels: Fock states per mode\nŒ∑: Lamb-Dicke parameters (scalar or Nions √ó Nmodes matrix)\nœâm: Mode frequencies (scalar or vector)\n\nReturns\n\nMatrix representing the œÉÀ£·µ¢ œÉÀ£‚±º interaction for use in building MS gates.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.MultiTransmonSystem-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.MultiTransmonSystem","text":"MultiTransmonSystem(\n    œâs::AbstractVector{Float64},\n    Œ¥s::AbstractVector{Float64},\n    gs::AbstractMatrix{Float64};\n    drive_bounds::Union{Float64, Vector{<:Union{Tuple{Float64, Float64}, Float64}}}=1.0,\n    levels_per_transmon::Int = 3,\n    subsystem_levels::AbstractVector{Int} = fill(levels_per_transmon, length(œâs)),\n    lab_frame=false,\n    subsystems::AbstractVector{Int} = 1:length(œâs),\n    subsystem_drive_indices::AbstractVector{Int} = 1:length(œâs),\n    kwargs...\n) -> CompositeQuantumSystem\n\nReturns a CompositeQuantumSystem object for a multi-transmon system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.RadialMSGateSystem-Tuple{}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.RadialMSGateSystem","text":"RadialMSGateSystem(;\n    N_ions::Int=2,\n    mode_levels::Int=5,\n    œâm_radial::Vector{Float64}=[5.0, 5.0, 5.1, 5.1],  # 4 radial modes for 2 ions\n    Œ¥::Union{Float64, Vector{Float64}}=0.2,           # Detuning(s) from mode(s)\n    Œ∑::Union{Float64, Matrix{Float64}}=0.1,           # Lamb-Dicke parameters\n    multiply_by_2œÄ::Bool=true,\n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}}=fill(1.0, N_ions),\n) -> QuantumSystem\n\nReturns a time-dependent QuantumSystem for the radial-mode M√∏lmer-S√∏rensen gate  as described in the paper:\n\n\"Realization and Calibration of Continuously Parameterized Two-Qubit Gates on a  Trapped-Ion Quantum Processor\" (IEEE TQE 2024)\n\nThis implements the MS gate using only radial motional modes (not axial modes), which provides 2N modes for N ions (N modes along each of two transverse axes).\n\nHamiltonian (Equation 2 from paper)\n\nIn the interaction picture:\n\nH(t) = -fracihbar2 sum_ik sigma_xi eta_ki Omega_i a_k e^-idelta_k t + texthc\n\nExpanding the Hermitian conjugate:\n\nH(t) = -fraci2 sum_ik eta_ki Omega_i sigma_xi left(a_k e^-idelta_k t - a_k^dagger e^idelta_k tright)\n\nwhere:\n\nk\nindexes the 2N radial modes (N along x, N along y)\nsigma_xi\nis Pauli-X on ion i \neta_ki\nis the Lamb-Dicke parameter for ion i, mode k\nOmega_i(t)\nis the control amplitude (Rabi frequency) for ion i\ndelta_k\nis the detuning from motional sideband of mode k\na_k a_k^dagger\nare phonon operators for radial mode k\n\nRadial Mode Structure\n\nFor N ions in a linear trap with radial confinement:\n\nAxial modes (along trap axis): Not used for this gate\nRadial modes: 2N modes total\nN modes along transverse x-direction  \nN modes along transverse y-direction\n\nFor N=2 ions: 4 radial modes participate in the gate dynamics.\n\nTypical Parameters (Q-SCOUT platform at Sandia, ¬π‚Å∑¬πYb‚Å∫)\n\nRadial frequencies: omega_r  2pi sim 5 MHz (higher than axial ~2 MHz)\nLamb-Dicke: eta sim 005 - 015\nDetuning: delta  2pi sim 100 - 500 kHz\nGate time: 50 - 200 Œºs\nPhonon states: n_max = 3-5 typically sufficient\n\nKeyword Arguments\n\nN_ions: Number of ions (default: 2)\nmode_levels: Fock states per radial mode (default: 5)\nœâm_radial: Radial mode frequencies in GHz. Vector of length 2N.  Example for 2 ions: [5.0, 5.0, 5.1, 5.1] (nearly degenerate pairs)\nŒ¥: Detuning(s) from sideband in GHz. Scalar (uniform) or vector per mode.\nŒ∑: Lamb-Dicke parameter(s). Scalar (uniform) or N_ions √ó 2N matrix.\nmultiply_by_2œÄ: Multiply by 2œÄ (default true, since frequencies in GHz)\ndrive_bounds: Control amplitude bounds for each ion (length N_ions)\n\nExample: Two-Ion Radial MS Gate\n\nsys = RadialMSGateSystem(\n    N_ions=2,\n    mode_levels=5,\n    œâm_radial=[5.0, 5.0, 5.1, 5.1],  # Two nearly-degenerate pairs\n    Œ¥=0.2,                            # 200 kHz detuning\n    Œ∑=0.1,                            # Lamb-Dicke parameter\n    drive_bounds=[1.0, 1.0]           # Amplitude bounds (GHz)\n)\n\n# Create trajectory for XX gate\nU_goal = exp(-im * œÄ/4 * kron([0 1; 1 0], [0 1; 1 0]))  # XX(œÄ/2)\nqtraj = UnitaryTrajectory(sys, U_goal, 100e-6)  # 100 Œºs gate\n\nOptimization Considerations\n\nMotional closure: All 2N modes must satisfy alpha_k(tau) approx 0\nTarget mode: Choose one mode (e.g., k=1) as primary entangling mode\nSpectator modes: Other modes should remain minimally excited\nControl strategy: Individual ion addressing via Omega_i(t)\n\nReferences\n\nS√∏rensen & M√∏lmer, \"Quantum computation with ions in thermal motion,\" PRL 82, 1971 (1999)\nMizrahi et al., \"Realization and Calibration of Continuously Parameterized Two-Qubit  Gates...,\" IEEE TQE (2024)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.RadialMSGateSystemWithPhase-Tuple{}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.RadialMSGateSystemWithPhase","text":"RadialMSGateSystemWithPhase(;\n    N_ions::Int=2,\n    mode_levels::Int=5,\n    œâm_radial::Vector{Float64}=[5.0, 5.0, 5.1, 5.1],\n    Œ¥::Union{Float64, Vector{Float64}}=0.2,\n    Œ∑::Union{Float64, Matrix{Float64}}=0.1,\n    multiply_by_2œÄ::Bool=true,\n    amplitude_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}}=fill(1.0, N_ions),\n    phase_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}}=fill((-œÄ, œÄ), N_ions),\n) -> QuantumSystem\n\nReturns a time-dependent QuantumSystem for the radial-mode MS gate with phase controls to enable AC Stark shift compensation.\n\nHamiltonian (with phase modulation)\n\nInstead of sigma_x = sigma^+ + sigma^-, we use phase-modulated drives:\n\nH(t) = frac12 sum_ik eta_ki Omega_i(t) left(sigma^+_i e^iphi_i(t) + sigma^-_i e^-iphi_i(t)right) \n       left(a_k e^-idelta_k t + a_k^dagger e^idelta_k tright)\n\nwhere Omega_i(t) and phi_i(t) are independent controls.\n\nWhy Phase Controls?\n\nOff-resonant coupling to spectator modes creates AC Stark shifts:\n\nDelta E_textStark sim fraceta^2 Omega^2(t)delta_textspectator\n\nThis causes time-varying phase accumulation that sigma_x control alone cannot compensate. The solution: actively modulate phi_i(t) to cancel the Stark-induced phase, typically using:\n\nphi(t) sim int_0^t fraceta^2 Omega^2(t)delta dt sim texterf(sqrt2t) text for Gaussian pulses\n\nThis enables loop closure in phase space and high-fidelity gates (F  099).\n\nControl Structure\n\nControls: Omega_1 phi_1 Omega_2 phi_2 ldots for N_textions ions.\n\nEven indices (1, 3, 5, ...): Amplitudes Omega_i(t) (Rabi frequency)\nOdd indices (2, 4, 6, ...): Phases phi_i(t) (laser phase)\n\nExample\n\nsys = RadialMSGateSystemWithPhase(\n    N_ions=2,\n    mode_levels=3,\n    œâm_radial=[5.0, 5.0, 5.1, 5.1],\n    Œ¥=0.2,\n    Œ∑=0.1,\n    amplitude_bounds=[1.0, 1.0],\n    phase_bounds=[(-Float64(œÄ), Float64(œÄ)), (-Float64(œÄ), Float64(œÄ))]\n)\n\n# sys.n_drives == 4 (Œ©‚ÇÅ, œÜ‚ÇÅ, Œ©‚ÇÇ, œÜ‚ÇÇ)\n\nSee Also\n\nRadialMSGateSystem: Amplitude-only version (simpler but limited fidelity)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.RydbergChainSystem-Tuple{}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.RydbergChainSystem","text":"RydbergChainSystem(;\n    N::Int=3, # number of atoms\n    C::Float64=862690*2œÄ,\n    distance::Float64=10.0, # Œºm\n    cutoff_order::Int=2, # 1 is nearest neighbor, 2 is next-nearest neighbor, etc.\n    local_detune::Bool=false, # If true, include one local detuning pattern.\n    all2all::Bool=true, # If true, include all-to-all interactions.\n    ignore_Y_drive::Bool=false, # If true, ignore the Y drive. (In the experiments, X&Y drives are implemented by Rabi amplitude and its phase.)\n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}}=[1.0, 1.0, 1.0], # Bounds for [Œ©x, Œ©y, Œî] or [Œ©x, Œî] if ignore_Y_drive\n) -> QuantumSystem\n\nReturns a QuantumSystem object for the Rydberg atom chain in the spin basis     |g‚ü© = |0‚ü© = [1, 0], |r‚ü© = |1‚ü© = [0, 1].\n\nH = sum_i 05*Omega_i(t)cos(phi_i(t)) sigma_i^x - 05*Omega_i(t)sin(phi_i(t)) sigma_i^y - sum_i Delta_i(t)n_i + sum_ij fracCi-j^6 n_i n_j\n\nKeyword Arguments\n\nN: Number of atoms.\nC: The Rydberg interaction strength in MHz*Œºm^6.\ndistance: The distance between atoms in Œºm.\ncutoff_order: Interaction range cutoff, 1 is nearest neighbor, 2 is next nearest neighbor.\nlocal_detune: If true, include one local detuning pattern.\nall2all: If true, include all-to-all interactions.\nignore_Y_drive: If true, ignore the Y drive. (In the experiments, X&Y drives are implemented by Rabi amplitude and its phase.)\ndrive_bounds: Bounds for drive amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.TransmonCavitySystem-Tuple{}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.TransmonCavitySystem","text":"TransmonCavitySystem(;\n    qubit_levels::Int=4,\n    cavity_levels::Int=12,\n    œá::Float64=2œÄ * 32.8e-6,    # Dispersive shift (GHz)\n    œá‚Ä≤::Float64=2œÄ * 1.5e-9,    # Higher-order dispersive shift (GHz)\n    K_c::Float64=2œÄ * 1e-9 / 2, # Cavity self-Kerr (GHz)\n    K_q::Float64=2œÄ * 193e-3 / 2, # Qubit self-Kerr (GHz)\n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}}=fill(1.0, 4),\n    multiply_by_2œÄ::Bool=false, # Already in GHz with 2œÄ factors\n) -> QuantumSystem\n\nReturns a QuantumSystem for a transmon qubit dispersively coupled to a cavity mode.\n\nThis system models circuit QED architectures where a transmon (artificial atom) is coupled  to a microwave resonator in the dispersive regime, enabling quantum state manipulation and  readout.\n\nHamiltonian\n\nH = tildeDelta hatb^dagger hatb \n    - chi hata^dagger hata hatb^dagger hatb\n    - chi hatb^dagger 2 hatb^2 hata^dagger hata\n    - K_q hata^dagger 2 hata^2\n    - K_c hatb^dagger 2 hatb^2\n\nwhere:\n\nhata, hata^dagger are the transmon annihilation/creation operators\nhatb, hatb^dagger are the cavity annihilation/creation operators  \ntildeDelta = chi2 is the shifted cavity frequency\nchi is the dispersive shift (qubit-cavity coupling)\nchi is a higher-order dispersive correction\nK_q, K_c are self-Kerr nonlinearities\n\nThe drives are:\n\nhata^dagger + hata - Real transmon drive\ni(hata^dagger - hata) - Imaginary transmon drive\nhatb^dagger + hatb - Real cavity drive\ni(hatb^dagger - hatb) - Imaginary cavity drive\n\nKeyword Arguments\n\nqubit_levels: Number of transmon Fock states (typically 3-5)\ncavity_levels: Number of cavity Fock states (typically 10-20)\nœá: Dispersive shift in GHz (with 2œÄ). Typical: ~2œÄ √ó 30-50 kHz\nœá‚Ä≤: Higher-order dispersive shift in GHz. Typically small (~2œÄ √ó 1-2 Hz)\nK_c: Cavity self-Kerr in GHz. Typically ~2œÄ √ó 1 Hz\nK_q: Qubit self-Kerr (anharmonicity/2) in GHz. Typical: ~2œÄ √ó 100-200 MHz\ndrive_bounds: Control bounds for [Œ©·µ£(qubit), Œ©·µ¢(qubit), Œ±·µ£(cavity), Œ±·µ¢(cavity)]\nmultiply_by_2œÄ: Whether to multiply by 2œÄ (default false, assuming parameters already include it)\n\nExample\n\n# Standard cQED parameters\nsys = TransmonCavitySystem(\n    qubit_levels=4,\n    cavity_levels=15,\n    œá=2œÄ * 32.8e-6,   # 32.8 kHz dispersive shift\n    K_q=2œÄ * 193e-3/2, # ~193 MHz anharmonicity\n)\n\nReferences\n\nBlais et al., \"Circuit quantum electrodynamics,\" Rev. Mod. Phys. 93, 025005 (2021)\nKoch et al., \"Charge-insensitive qubit design derived from Cooper pair box,\"  Phys. Rev. A 76, 042319 (2007)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.TransmonDipoleCoupling","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.TransmonDipoleCoupling","text":"TransmonDipoleCoupling(\n    g_ij::Float64,\n    pair::Tuple{Int, Int},\n    subsystem_levels::Vector{Int};\n    lab_frame::Bool=false,\n) -> QuantumSystemCoupling\n\nTransmonDipoleCoupling(\n    g_ij::Float64,\n    pair::Tuple{Int, Int},\n    sub_systems::Vector{QuantumSystem};\n    kwargs...\n) -> QuantumSystemCoupling\n\nReturns a QuantumSystemCoupling object for a transmon qubit. In the lab frame, the Hamiltonian coupling term is\n\nH = g_ij (a_i + a_i^dagger) (a_j + a_j^dagger)\n\nIn the rotating frame, the Hamiltonian coupling term is\n\nH = g_ij (a_i a_j^dagger + a_i^dagger a_j)\n\nwhere a_i is the annihilation operator for the ith transmon.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.TransmonSystem-Tuple{}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.TransmonSystem","text":"TransmonSystem(;\n    œâ::Float64=4.4153,  # GHz\n    Œ¥::Float64=0.17215, # GHz\n    levels::Int=3,\n    lab_frame::Bool=false,\n    frame_œâ::Float64=œâ,\n) -> QuantumSystem\n\nReturns a QuantumSystem object for a transmon qubit, with the Hamiltonian\n\nH = omega a^dagger a - fracdelta2 a^dagger a^dagger a a\n\nwhere a is the annihilation operator.\n\nKeyword Arguments\n\nœâ: The frequency of the transmon, in GHz.\nŒ¥: The anharmonicity of the transmon, in GHz.\nlevels: The number of levels in the transmon.\nlab_frame: Whether to use the lab frame Hamiltonian, or an œâ-rotating frame.\nframe_œâ: The frequency of the rotating frame, in GHz.\nmutiply_by_2œÄ: Whether to multiply the Hamiltonian by 2œÄ, set to true by default because the frequency is in GHz.\nlab_frame_type: The type of lab frame Hamiltonian to use, one of (:duffing, :quartic, :cosine).\ndrives: Whether to include drives in the Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemTemplates.lift-Tuple{Char, Int64, Int64}","page":"Library","title":"Piccolo.Quantum.QuantumSystemTemplates.lift","text":"lift(x::Char, i::Int, N::Int)::String\n\nEmbed a character into a string of the form 'I' * N at a specific position (meant for use with Piccolo.QuantumObjectUtils.operator_from_string).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemUtils.is_linearly_dependent-Tuple{AbstractMatrix}","page":"Library","title":"Piccolo.Quantum.QuantumSystemUtils.is_linearly_dependent","text":"is_linearly_dependent(M::AbstractMatrix; eps=eps(Float32), verbose=true)\n\nCheck if the columns of the matrix M are linearly dependent.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumSystemUtils.is_reachable","text":"is_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...)\n\nCheck if the gate is reachable using the given system.\n\nKeyword Arguments\n\nuse_drift::Bool=true: include drift Hamiltonian in the generators\nkwargs...: keyword arguments for is_reachable\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}}","page":"Library","title":"Piccolo.Quantum.QuantumSystemUtils.is_reachable","text":"is_reachable(gate, hamiltonians; kwargs...)\n\nCheck if the gate is reachable using the given hamiltonians.\n\nArguments\n\ngate::AbstractMatrix: target gate\nhamiltonians::AbstractVector{<:AbstractMatrix}: generators of the Lie algebra\n\nKeyword Arguments\n\nsubspace::AbstractVector{<:Int}=1:size(gate, 1): subspace indices\ncompute_basis::Bool=true: compute the basis or use the Hamiltonians directly\nremove_trace::Bool=true: remove trace from generators\nverbose::Bool=true: print information about the operator algebra\natol::Float32=eps(Float32): absolute tolerance\n\nSee also QuantumSystemUtils.operator_algebra.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumSystemUtils.operator_algebra-Union{Tuple{Vector{<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","page":"Library","title":"Piccolo.Quantum.QuantumSystemUtils.operator_algebra","text":"operator_algebra(generators; kwargs...)\n\nCompute the Lie algebra basis for the given generators.\n\nArguments\n\ngenerators::Vector{<:AbstractMatrix}: generators of the Lie algebra\n\nKeyword Arguments\n\nreturn_layers::Bool=false: return the Lie tree layers\nnormalize::Bool=false: normalize the basis\nverbose::Bool=false: print information\nremove_trace::Bool=true: remove trace from generators\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Gates.GATES","page":"Library","title":"Piccolo.Quantum.Gates.GATES","text":"A constant dictionary GATES containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix.\n\nGATES[:I] - Identity: Leaves the state unchanged.\nGATES[:X] - Pauli-X (NOT): Flips the qubit state.\nGATES[:Y] - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere.\nGATES[:Z] - Pauli-Z: Flips the phase of the qubit state.\nGATES[:H] - Hadamard: Creates superposition by transforming basis states.\nGATES[:CX] - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1‚ü©.\nGATES[:CZ] - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1‚ü©.\nGATES[:XI] - Complex: A gate for complex operations.\nGATES[:sqrtiSWAP] - Square root of iSWAP: Partially swaps two qubits with a phase.\n\n\n\n\n\n","category":"constant"},{"location":"lib/#Piccolo.Quantum.Gates.PAULIS","page":"Library","title":"Piccolo.Quantum.Gates.PAULIS","text":"The 2√ó2 Pauli matrics and identity.\n\n\n\n\n\n","category":"constant"},{"location":"lib/#Piccolo.Quantum.QuantumObjectUtils.annihilate-Tuple{Int64}","page":"Library","title":"Piccolo.Quantum.QuantumObjectUtils.annihilate","text":"annihilate(levels::Int)\n\nGet the annihilation operator for a system with levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumObjectUtils.create-Tuple{Int64}","page":"Library","title":"Piccolo.Quantum.QuantumObjectUtils.create","text":"create(levels::Int)\n\nGet the creation operator for a system with levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumObjectUtils.haar_identity-Tuple{Int64, Number}","page":"Library","title":"Piccolo.Quantum.QuantumObjectUtils.haar_identity","text":"haar_identity(n::Int, radius::Number)\n\nGenerate a random unitary matrix close to the identity matrix using the Haar measure for an n-dimensional system with a given radius. The smaller the radius, the closer the matrix will be to the identity.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumObjectUtils.haar_random-Tuple{Int64}","page":"Library","title":"Piccolo.Quantum.QuantumObjectUtils.haar_random","text":"haar_random(n::Int)\n\nGenerate a random unitary matrix using the Haar measure for an n-dimensional system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumObjectUtils.ket_from_bitstring-Tuple{String}","page":"Library","title":"Piccolo.Quantum.QuantumObjectUtils.ket_from_bitstring","text":"ket_from_bitstring(ket::String)\n\nGet the state vector for a qubit system given a ket string ket of 0s and 1s.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumObjectUtils.ket_from_string-Tuple{String, Vector{Int64}}","page":"Library","title":"Piccolo.Quantum.QuantumObjectUtils.ket_from_string","text":"ket_from_string(\n    ket::String,\n    levels::Vector{Int};\n    level_dict=Dict(:g => 0, :e => 1, :f => 2, :h => 3, :i => 4, :j => 5, :k => 6, :l => 7),\n    return_states=false\n)\n\nConstruct a quantum state from a string ket representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumObjectUtils.operator_from_string-Tuple{String}","page":"Library","title":"Piccolo.Quantum.QuantumObjectUtils.operator_from_string","text":"operator_from_string(operator::String; lookup=PAULIS)\n\nReduce the string (each character is one key) via operators from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(qtraj::DensityTrajectory; kwargs...)\nNamedTrajectory(qtraj::DensityTrajectory, N::Int; kwargs...)\nNamedTrajectory(qtraj::DensityTrajectory, times::AbstractVector; kwargs...)\n\nConvert a DensityTrajectory to a NamedTrajectory for optimization.\n\nStored Variables\n\nœÅ‚ÉóÃÉ: Vectorized isomorphism of the density matrix\nu (or custom drive_name): Control values sampled at times\ndu: Control derivatives (only for CubicSplinePulse)\nt: Times\n\nArguments\n\nN_or_times: One of:\nnothing (default): Use native knot times from spline pulse\nN::Int: Number of uniformly spaced time points\ntimes::AbstractVector: Specific times to sample at\n\nKeyword Arguments\n\nŒît_bounds: Optional tuple (lower, upper) for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: nothing (no bounds).\n\n\n\n\n\n","category":"type"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-2","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(qtraj::UnitaryTrajectory; kwargs...)\nNamedTrajectory(qtraj::UnitaryTrajectory, N::Int; kwargs...)\nNamedTrajectory(qtraj::UnitaryTrajectory, times::AbstractVector; kwargs...)\n\nConvert a UnitaryTrajectory to a NamedTrajectory for optimization.\n\nThe trajectory stores actual times :t (not timesteps :Œît), which is required for time-dependent integrators used with SplinePulseProblem.\n\nStored Variables\n\n≈®‚Éó: Isomorphism of unitary (vectorized real representation)\nu (or custom drive_name): Control values sampled at times\ndu: Control derivatives (only for CubicSplinePulse)\nt: Times\n\nArguments\n\nqtraj: The quantum trajectory to convert\nN_or_times: One of:\nnothing (default): Use native knot times from spline pulse (error for non-spline pulses)\nN::Int: Number of uniformly spaced time points\ntimes::AbstractVector: Specific times to sample at\n\nKeyword Arguments\n\nŒît_bounds: Optional tuple (lower, upper) for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: nothing (no bounds).\nglobal_data: Optional Dict mapping global variable names to initial values (as vectors). Note: global variables are optimization variables without explicit box constraints.\n\nReturns\n\nA NamedTrajectory suitable for direct collocation optimization.\n\n\n\n\n\n","category":"type"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-3","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(qtraj::KetTrajectory; kwargs...)\nNamedTrajectory(qtraj::KetTrajectory, N::Int; kwargs...)\nNamedTrajectory(qtraj::KetTrajectory, times::AbstractVector; kwargs...)\n\nConvert a KetTrajectory to a NamedTrajectory for optimization.\n\nStored Variables\n\nœàÃÉ: Isomorphism of ket state (real representation)\nu (or custom drive_name): Control values sampled at times\ndu: Control derivatives (only for CubicSplinePulse)\nt: Times\n\nArguments\n\nN_or_times: One of:\nnothing (default): Use native knot times from spline pulse\nN::Int: Number of uniformly spaced time points\ntimes::AbstractVector: Specific times to sample at\n\nKeyword Arguments\n\nŒît_bounds: Optional tuple (lower, upper) for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: nothing (no bounds).\nglobal_data: Optional Dict mapping global variable names to initial values (as vectors). Note: global variables are optimization variables without explicit box constraints.\n\n\n\n\n\n","category":"type"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-4","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(qtraj::MultiKetTrajectory; kwargs...)\nNamedTrajectory(qtraj::MultiKetTrajectory, N::Int; kwargs...)\nNamedTrajectory(qtraj::MultiKetTrajectory, times::AbstractVector; kwargs...)\n\nConvert an MultiKetTrajectory to a NamedTrajectory for optimization.\n\nStored Variables\n\nœàÃÉ1, œàÃÉ2, ...: Isomorphisms of each ket state\nu (or custom drive_name): Control values sampled at times\ndu: Control derivatives (only for CubicSplinePulse)\nt: Times\n\nArguments\n\nN_or_times: One of:\nnothing (default): Use native knot times from spline pulse\nN::Int: Number of uniformly spaced time points\ntimes::AbstractVector: Specific times to sample at\n\nKeyword Arguments\n\nŒît_bounds: Optional tuple (lower, upper) for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: nothing (no bounds).\nglobal_data: Optional Dict mapping global variable names to initial values (as vectors). Note: global variables are optimization variables without explicit box constraints.\n\n\n\n\n\n","category":"type"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{P}, Tuple{SamplingTrajectory{P, <:UnitaryTrajectory{P}}, Union{Int64, AbstractVector{<:Real}}}} where P<:AbstractPulse","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(sampling::SamplingTrajectory, N::Int)\nNamedTrajectory(sampling::SamplingTrajectory, times::AbstractVector)\n\nConvert a SamplingTrajectory to a NamedTrajectory for optimization.\n\nCreates a trajectory with multiple state variables (one per system),  all sharing the same control pulse. Each state gets a numeric suffix:\n\nUnitaryTrajectory base ‚Üí :≈®‚Éó1, :≈®‚Éó2, ...\nKetTrajectory base ‚Üí :œàÃÉ1, :œàÃÉ2, ...\n\nFor robust optimization, each state variable represents the evolution under a different system (e.g., parameter variations), but all share the same controls.\n\nExample\n\n# Create sampling trajectory with 3 system variations\nsampling = SamplingTrajectory(base_qtraj, [sys1, sys2, sys3])\n\n# Convert to NamedTrajectory with 51 timesteps\ntraj = NamedTrajectory(sampling, 51)\n# Result has: :≈®‚Éó1, :≈®‚Éó2, :≈®‚Éó3, :u, :Œît, :t\n\nKeyword Arguments\n\nŒît_bounds: Optional tuple (lower, upper) for timestep bounds. If provided, enables free-time optimization (minimum-time problems). Default: nothing (no bounds).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.AbstractQuantumTrajectory","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.AbstractQuantumTrajectory","text":"AbstractQuantumTrajectory{P<:AbstractPulse}\n\nAbstract type for quantum trajectories that wrap physics (system, pulse, solution, goal). Parametric on pulse type P to enable dispatch in problem templates.\n\nAll concrete subtypes should implement:\n\nstate_name(traj) - Get the state variable symbol (fixed per type)\ndrive_name(traj) - Get the drive variable symbol (from pulse)\ntime_name(traj) - Get the time variable symbol (fixed :t)\ntimestep_name(traj) - Get the timestep variable symbol (fixed :Œît)\nduration(traj) - Get the duration (from pulse)\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.DensityTrajectory","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.DensityTrajectory","text":"DensityTrajectory{P<:AbstractPulse, S<:ODESolution} <: AbstractQuantumTrajectory{P}\n\nTrajectory for open quantum systems (Lindblad dynamics).\n\nFields\n\nsystem::OpenQuantumSystem: The open quantum system\npulse::P: The control pulse\ninitial::Matrix{ComplexF64}: Initial density matrix œÅ‚ÇÄ\ngoal::Matrix{ComplexF64}: Target density matrix œÅ_goal\nsolution::S: Pre-computed ODE solution\n\nCallable\n\ntraj(t) returns the density matrix at time t.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.DensityTrajectory-Tuple{OpenQuantumSystem, AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Real}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.DensityTrajectory","text":"DensityTrajectory(system, initial, goal, T::Real; drive_name=:u, algorithm=Tsit5())\n\nConvenience constructor that creates a zero pulse of duration T.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.DensityTrajectory-Tuple{OpenQuantumSystem, AbstractPulse, AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.DensityTrajectory","text":"DensityTrajectory(system, pulse, initial, goal; algorithm=Tsit5())\n\nCreate a density matrix trajectory by solving the Lindblad master equation.\n\nArguments\n\nsystem::OpenQuantumSystem: The open quantum system\npulse::AbstractPulse: The control pulse\ninitial::Matrix: Initial density matrix œÅ‚ÇÄ\ngoal::Matrix: Target density matrix œÅ_goal\n\nKeyword Arguments\n\nalgorithm: ODE solver algorithm (default: Tsit5())\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.KetTrajectory","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.KetTrajectory","text":"KetTrajectory{P<:AbstractPulse, S<:ODESolution} <: AbstractQuantumTrajectory{P}\n\nTrajectory for quantum state transfer. The ODE solution is computed at construction.\n\nFields\n\nsystem::QuantumSystem: The quantum system\npulse::P: The control pulse\ninitial::Vector{ComplexF64}: Initial state |œà‚ÇÄ‚ü©\ngoal::Vector{ComplexF64}: Target state |œà_goal‚ü©\nsolution::S: Pre-computed ODE solution\n\nCallable\n\ntraj(t) returns the state at time t by interpolating the solution.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.KetTrajectory-Tuple{QuantumSystem, AbstractPulse, AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.KetTrajectory","text":"KetTrajectory(system, pulse, initial, goal; algorithm=MagnusGL4())\n\nCreate a ket trajectory by solving the Schr√∂dinger equation.\n\nArguments\n\nsystem::QuantumSystem: The quantum system\npulse::AbstractPulse: The control pulse\ninitial::Vector: Initial state |œà‚ÇÄ‚ü©\ngoal::Vector: Target state |œà_goal‚ü©\n\nKeyword Arguments\n\nalgorithm: ODE solver algorithm (default: MagnusGL4())\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.KetTrajectory-Tuple{QuantumSystem, AbstractVector{<:Number}, AbstractVector{<:Number}, Real}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.KetTrajectory","text":"KetTrajectory(system, initial, goal, T::Real; drive_name=:u, algorithm=MagnusGL4())\n\nConvenience constructor that creates a zero pulse of duration T.\n\nArguments\n\nsystem::QuantumSystem: The quantum system\ninitial::Vector: Initial state |œà‚ÇÄ‚ü©\ngoal::Vector: Target state |œà_goal‚ü©\nT::Real: Duration of the pulse\n\nKeyword Arguments\n\ndrive_name::Symbol: Name of the drive variable (default: :u)\nalgorithm: ODE solver algorithm (default: MagnusGL4())\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory","text":"MultiKetTrajectory{P<:AbstractPulse, S} <: AbstractQuantumTrajectory{P}\n\nTrajectory for multi-state transfer with a shared pulse. Useful for state-to-state problems with multiple initial/goal pairs.\n\nFields\n\nsystem::QuantumSystem: The quantum system\npulse::P: The shared control pulse\ninitials::Vector{Vector{ComplexF64}}: Initial states\ngoals::Vector{Vector{ComplexF64}}: Target states\nweights::Vector{Float64}: Weights for fidelity calculation\nsolution::S: Pre-computed ensemble solution\n\nCallable\n\ntraj(t) returns a vector of states at time t. traj[i] returns the i-th trajectory's solution.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory-Tuple{QuantumSystem, AbstractPulse, Vector{<:AbstractVector{<:Number}}, Vector{<:AbstractVector{<:Number}}}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory","text":"MultiKetTrajectory(system, pulse, initials, goals; weights=..., algorithm=MagnusGL4())\n\nCreate a multi-ket trajectory by solving multiple Schr√∂dinger equations.\n\nArguments\n\nsystem::QuantumSystem: The quantum system\npulse::AbstractPulse: The shared control pulse\ninitials::Vector{Vector}: Initial states\ngoals::Vector{Vector}: Target states\n\nKeyword Arguments\n\nweights: Weights for fidelity (default: uniform)\nalgorithm: ODE solver algorithm (default: MagnusGL4())\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory-Tuple{QuantumSystem, Vector{<:AbstractVector{<:Number}}, Vector{<:AbstractVector{<:Number}}, Real}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.MultiKetTrajectory","text":"MultiKetTrajectory(system, initials, goals, T::Real; weights=..., drive_name=:u, algorithm=MagnusGL4())\n\nConvenience constructor that creates a zero pulse of duration T.\n\nArguments\n\nsystem::QuantumSystem: The quantum system\ninitials::Vector{Vector}: Initial states\ngoals::Vector{Vector}: Target states\nT::Real: Duration of the pulse\n\nKeyword Arguments\n\nweights: Weights for fidelity (default: uniform)\ndrive_name::Symbol: Name of the drive variable (default: :u)\nalgorithm: ODE solver algorithm (default: MagnusGL4())\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.SamplingTrajectory","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.SamplingTrajectory","text":"SamplingTrajectory{QT<:AbstractQuantumTrajectory} <: AbstractQuantumTrajectory\n\nWrapper for robust optimization over multiple systems with shared controls.\n\nUsed for sampling-based robust optimization where:\n\nAll systems share the same control pulse\nEach system has different dynamics (e.g., parameter variations)\nOptimization minimizes weighted fidelity across all systems\n\nThis type does NOT store a NamedTrajectory - use NamedTrajectory(sampling, N) for conversion.\n\nFields\n\nbase_trajectory::QT: Base quantum trajectory (defines pulse, initial, goal)\nsystems::Vector{<:AbstractQuantumSystem}: Multiple systems to optimize over\nweights::Vector{Float64}: Weights for each system in objective\n\nExample\n\nsys_nom = QuantumSystem(...)\nsys_variations = [QuantumSystem(...) for _ in 1:3]  # Parameter variations\nqtraj = UnitaryTrajectory(sys_nom, pulse, U_goal)\nsampling = SamplingTrajectory(qtraj, sys_variations, [0.5, 0.3, 0.2])\n\n# Convert to NamedTrajectory for optimization\ntraj = NamedTrajectory(sampling, 51)  # Creates :≈®‚Éó1, :≈®‚Éó2, :≈®‚Éó3\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.SamplingTrajectory-Union{Tuple{QT}, Tuple{P}, Tuple{QT, Vector{<:AbstractQuantumSystem}}} where {P<:AbstractPulse, QT<:AbstractQuantumTrajectory{P}}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.SamplingTrajectory","text":"SamplingTrajectory(base_trajectory, systems; weights=nothing)\n\nCreate a SamplingTrajectory for robust optimization.\n\nArguments\n\nbase_trajectory: Base quantum trajectory (defines pulse, initial, goal)\nsystems: Vector of systems with parameter variations\n\nKeyword Arguments\n\nweights: Optional weights for each system (default: equal weights)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory","text":"UnitaryTrajectory{P<:AbstractPulse, S<:ODESolution, G} <: AbstractQuantumTrajectory{P}\n\nTrajectory for unitary gate synthesis. The ODE solution is computed at construction.\n\nFields\n\nsystem::QuantumSystem: The quantum system\npulse::P: The control pulse (stores drive_name)\ninitial::Matrix{ComplexF64}: Initial unitary (default: identity)\ngoal::G: Target unitary operator (AbstractPiccoloOperator or Matrix)\nsolution::S: Pre-computed ODE solution\n\nCallable\n\ntraj(t) returns the unitary at time t by interpolating the solution.\n\nConversion to NamedTrajectory\n\nUse NamedTrajectory(traj, N) or NamedTrajectory(traj, times) for optimization.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory-Union{Tuple{G}, Tuple{QuantumSystem, AbstractPulse, G}} where G","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory","text":"UnitaryTrajectory(system, pulse, goal; initial=I, algorithm=MagnusGL4())\n\nCreate a unitary trajectory by solving the Schr√∂dinger equation.\n\nArguments\n\nsystem::QuantumSystem: The quantum system\npulse::AbstractPulse: The control pulse\ngoal: Target unitary (Matrix or AbstractPiccoloOperator)\n\nKeyword Arguments\n\ninitial: Initial unitary (default: identity matrix)\nalgorithm: ODE solver algorithm (default: MagnusGL4())\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory-Union{Tuple{G}, Tuple{QuantumSystem, G, Real}} where G","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.UnitaryTrajectory","text":"UnitaryTrajectory(system, goal, T::Real; drive_name=:u, algorithm=MagnusGL4())\n\nConvenience constructor that creates a zero pulse of duration T.\n\nArguments\n\nsystem::QuantumSystem: The quantum system\ngoal: Target unitary (Matrix or AbstractPiccoloOperator)\nT::Real: Duration of the pulse\n\nKeyword Arguments\n\ndrive_name::Symbol: Name of the drive variable (default: :u)\nalgorithm: ODE solver algorithm (default: MagnusGL4())\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.drive_name-Tuple{AbstractQuantumTrajectory}","page":"Library","title":"Piccolo.Quantum.Pulses.drive_name","text":"drive_name(traj::AbstractQuantumTrajectory)\n\nGet the drive/control variable name from the trajectory's pulse.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.duration-Tuple{AbstractQuantumTrajectory}","page":"Library","title":"Piccolo.Quantum.Pulses.duration","text":"duration(traj)\n\nGet the duration of a trajectory (from its pulse).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._add_global_data_to_kwargs-Tuple{Any, Any}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._add_global_data_to_kwargs","text":"_add_global_data_to_kwargs(nt_kwargs, global_data)\n\nHelper function to process global variables and add them to NamedTrajectory kwargs. Converts Dict{Symbol, Vector} to flat vector and components NamedTuple.\n\nArguments\n\nnt_kwargs: Existing NamedTuple of kwargs to merge with\nglobal_data: Dict mapping global variable names to vectors of values\n\nReturns\n\nMerged NamedTuple with globaldata and globalcomponents added\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._get_control_data-Tuple{CubicSplinePulse, AbstractVector, AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._get_control_data","text":"_get_control_data(pulse::CubicSplinePulse, times, sys)\n\nFor CubicSplinePulse: return u and du data with system bounds and boundary conditions. Uses the pulse's drive_name to determine variable naming.\n\nWhen times matches the pulse's native knot times, extracts stored u and du directly. When resampling to different times, samples u via interpolation and computes du via ForwardDiff to get the true spline derivative.\n\nReturns\n\ndata: NamedTuple with control data\ncontrol_names: Tuple of control variable names\nbounds: NamedTuple with control bounds\ninitial_constraints: NamedTuple with initial value constraints\nfinal_constraints: NamedTuple with final value constraints\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._get_control_data-Tuple{GaussianPulse, AbstractVector, AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._get_control_data","text":"_get_control_data(pulse::GaussianPulse, times, sys)\n\nFor GaussianPulse: sample as u values with system bounds and boundary conditions. Uses the pulse's drive_name to determine variable naming.\n\nReturns\n\ndata: NamedTuple with control data\ncontrol_names: Tuple of control variable names\nbounds: NamedTuple with control bounds\ninitial_constraints: NamedTuple with initial value constraints (empty for parametric pulses)\nfinal_constraints: NamedTuple with final value constraints (empty for parametric pulses)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._get_control_data-Tuple{Union{LinearSplinePulse, ZeroOrderPulse}, AbstractVector, AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._get_control_data","text":"_get_control_data(pulse::Union{ZeroOrderPulse, LinearSplinePulse}, times, sys)\n\nFor ZeroOrderPulse and LinearSplinePulse: return u data with system bounds and boundary conditions. Uses the pulse's drive_name to determine variable naming.\n\nReturns\n\ndata: NamedTuple with control data\ncontrol_names: Tuple of control variable names\nbounds: NamedTuple with control bounds\ninitial_constraints: NamedTuple with initial value constraints\nfinal_constraints: NamedTuple with final value constraints\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._get_drive_bounds-Tuple{AbstractQuantumSystem}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._get_drive_bounds","text":"_get_drive_bounds(sys::QuantumSystem)\n\nExtract drive bounds from system as tuple of (lower, upper) vectors.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._named_tuple-Tuple{Vararg{Pair{Symbol}}}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._named_tuple","text":"_named_tuple(pairs...)\n\nCreate a NamedTuple from pairs of (Symbol, value). This is needed when keys are  dynamic (stored in variables).\n\nExample:     name = :x     namedtuple(name => 1, :y => 2)  # Returns (x = 1, y = 2)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._sample_times-Tuple{Any, AbstractVector{<:Real}}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._sample_times","text":"_sample_times(traj, times::AbstractVector)\n\nReturn times as a Float64 vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._sample_times-Tuple{Any, Int64}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._sample_times","text":"_sample_times(traj, N::Int)\n\nGenerate N uniformly spaced times for sampling.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories._sample_times-Tuple{Any, Nothing}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories._sample_times","text":"_sample_times(traj, ::Nothing)\n\nFor spline pulses, extract native knot times. For other pulses, error.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.extract_pulse","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.extract_pulse","text":"extract_pulse(qtraj::AbstractQuantumTrajectory, traj::NamedTrajectory)\n\nExtract an optimized pulse from a NamedTrajectory.\n\nThis function extracts the control values from the optimized trajectory and creates a new pulse object of the same type as the original pulse in qtraj.\n\nThe extraction process depends on the pulse type:\n\nZeroOrderPulse, LinearSplinePulse: Extracts u (drive variable)\nCubicSplinePulse: Extracts both u and du (derivative variable)\n\nArguments\n\nqtraj: Original quantum trajectory (provides pulse type and drive names)\ntraj: Optimized NamedTrajectory with new control values\n\nReturns\n\nA new pulse of the same type as qtraj.pulse with optimized control values.\n\nExample\n\n# After optimization\nsolve!(prob)\nnew_pulse = extract_pulse(qtraj, prob.trajectory)\nrollout!(qtraj, new_pulse)\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_goal-Tuple{UnitaryTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_goal","text":"get_goal(traj)\n\nGet the goal state/operator from a trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_initial-Tuple{UnitaryTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_initial","text":"get_initial(traj)\n\nGet the initial state/operator from a trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_pulse-Tuple{AbstractQuantumTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_pulse","text":"get_pulse(traj)\n\nGet the control pulse from a trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_solution-Tuple{AbstractQuantumTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_solution","text":"get_solution(traj)\n\nGet the ODE solution from a trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_system-Tuple{AbstractQuantumTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_system","text":"get_system(traj)\n\nGet the quantum system from a trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_systems-Tuple{SamplingTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_systems","text":"get_systems(sampling::SamplingTrajectory)\n\nGet all systems in the sampling trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_weights-Tuple{SamplingTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_weights","text":"get_weights(sampling::SamplingTrajectory)\n\nGet the weights for each system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.state_name-Tuple{UnitaryTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.state_name","text":"state_name(::AbstractQuantumTrajectory)\n\nGet the fixed state variable name for a trajectory type.\n\nUnitaryTrajectory ‚Üí :≈®‚Éó\nKetTrajectory ‚Üí :œàÃÉ\nMultiKetTrajectory ‚Üí :œàÃÉ (with index appended: :œàÃÉ1, :œàÃÉ2, etc.)\nDensityTrajectory ‚Üí :œÅ‚ÉóÃÉ\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.state_names-Tuple{MultiKetTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.state_names","text":"state_names(traj::MultiKetTrajectory)\n\nGet all state names for an ensemble trajectory (:œàÃÉ1, :œàÃÉ2, etc.)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.state_names-Tuple{SamplingTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.state_names","text":"state_names(sampling::SamplingTrajectory)\n\nGet the state variable names for all systems (e.g., [:≈®‚Éó1, :≈®‚Éó2, :≈®‚Éó3]).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.time_name-Tuple{AbstractQuantumTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.time_name","text":"time_name(::AbstractQuantumTrajectory)\n\nGet the time variable name (always :t).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.timestep_name-Tuple{AbstractQuantumTrajectory}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.timestep_name","text":"timestep_name(::AbstractQuantumTrajectory)\n\nGet the timestep variable name (always :Œît).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts._update_system!-Tuple{DensityTrajectory, OpenQuantumSystem}","page":"Library","title":"Piccolo.Quantum.Rollouts._update_system!","text":"Rollouts._update_system!(qtraj::DensityTrajectory, sys::OpenQuantumSystem)\n\nUpdate the system field in a DensityTrajectory with a new OpenQuantumSystem (typically with updated global parameters after optimization).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts._update_system!-Tuple{KetTrajectory, QuantumSystem}","page":"Library","title":"Piccolo.Quantum.Rollouts._update_system!","text":"Rollouts._update_system!(qtraj::KetTrajectory, sys::QuantumSystem)\n\nUpdate the system field in a KetTrajectory with a new QuantumSystem (typically with updated global parameters after optimization).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts._update_system!-Tuple{MultiKetTrajectory, QuantumSystem}","page":"Library","title":"Piccolo.Quantum.Rollouts._update_system!","text":"Rollouts._update_system!(qtraj::MultiKetTrajectory, sys::QuantumSystem)\n\nUpdate the system field in a MultiKetTrajectory with a new QuantumSystem (typically with updated global parameters after optimization).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts._update_system!-Tuple{SamplingTrajectory, QuantumSystem}","page":"Library","title":"Piccolo.Quantum.Rollouts._update_system!","text":"Rollouts._update_system!(qtraj::SamplingTrajectory, sys::QuantumSystem)\n\nUpdate the system in the base_trajectory of a SamplingTrajectory. Note: This only updates the base trajectory's system, not the systems array. For updating parameter variations in the systems array, that should be done through the SamplingTrajectory constructor or direct modification.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts._update_system!-Tuple{UnitaryTrajectory, QuantumSystem}","page":"Library","title":"Piccolo.Quantum.Rollouts._update_system!","text":"Rollouts._update_system!(qtraj::UnitaryTrajectory, sys::QuantumSystem)\n\nUpdate the system field in a UnitaryTrajectory with a new QuantumSystem (typically with updated global parameters after optimization).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{DensityTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(traj::DensityTrajectory)\n\nCompute the fidelity between the final density matrix and the goal. Uses trace fidelity: F = tr(œÅfinal * œÅgoal)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{KetTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(traj::KetTrajectory)\n\nCompute the fidelity between the final state and the goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{MultiKetTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(traj::MultiKetTrajectory)\n\nCompute the weighted average fidelity across all state transfers.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{SamplingTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(traj::SamplingTrajectory; kwargs...)\n\nCompute the fidelity for each system in the sampling trajectory.\n\nReturns a vector of fidelities, one per system, by rolling out the current pulse with each system and computing the fidelity against the goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{UnitaryTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(traj::UnitaryTrajectory; subspace=nothing)\n\nCompute the fidelity between the final unitary and the goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{DensityTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::DensityTrajectory, pulse::AbstractPulse; algorithm=Tsit5(), n_points=101)\n\nUpdate density trajectory in-place with a new pulse. Note: Default algorithm is Tsit5() since density evolution uses standard ODE solvers. See rollout!(::UnitaryTrajectory, ::AbstractPulse) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{DensityTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::DensityTrajectory; algorithm=Tsit5(), n_points=101, kwargs...)\n\nUpdate density trajectory in-place with same pulse but different ODE parameters. Note: Default algorithm is Tsit5() since density evolution uses standard ODE solvers. See rollout!(::UnitaryTrajectory; kwargs...) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{KetTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::KetTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)\n\nUpdate ket trajectory in-place with a new pulse. See rollout!(::UnitaryTrajectory, ::AbstractPulse) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{KetTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::KetTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)\n\nUpdate ket trajectory in-place with same pulse but different ODE parameters. See rollout!(::UnitaryTrajectory; kwargs...) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{MultiKetTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::MultiKetTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)\n\nUpdate multi-ket trajectory in-place with a new pulse. See rollout!(::UnitaryTrajectory, ::AbstractPulse) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{MultiKetTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::MultiKetTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)\n\nUpdate multi-ket trajectory in-place with same pulse but different ODE parameters. See rollout!(::UnitaryTrajectory; kwargs...) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{SamplingTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::SamplingTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)\n\nUpdate sampling trajectory's base trajectory in-place with a new pulse. Delegates to the base trajectory's rollout! method.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{SamplingTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::SamplingTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)\n\nUpdate sampling trajectory's base trajectory in-place with new ODE parameters. Delegates to the base trajectory's rollout! method.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{UnitaryTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::UnitaryTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)\n\nUpdate quantum trajectory in-place with a new pulse by re-solving the ODE. Mutates qtraj.pulse and qtraj.solution.\n\nArguments\n\nqtraj::UnitaryTrajectory: The trajectory to update\npulse::AbstractPulse: The new control pulse\n\nKeyword Arguments\n\nalgorithm: ODE solver algorithm (default: MagnusGL4())\nn_points::Int: Number of time points to sample (default: 101)\n\nExample\n\nqtraj = UnitaryTrajectory(sys, old_pulse, goal)\nrollout!(qtraj, new_pulse)  # Updates qtraj in-place\nfid = fidelity(qtraj)  # Uses new solution\n\nSee also: rollout\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!-Tuple{UnitaryTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj::UnitaryTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)\n\nUpdate quantum trajectory in-place by re-solving with same pulse but different ODE parameters. Mutates qtraj.solution.\n\nUseful for comparing different solvers or tolerances.\n\nKeyword Arguments\n\nalgorithm: ODE solver algorithm (default: MagnusGL4())\nn_points::Int: Number of time points to sample (default: 101)\nAdditional kwargs passed to solve (e.g., abstol, reltol)\n\nExample\n\nqtraj = UnitaryTrajectory(sys, pulse, goal)\n\n# Compare Magnus vs Runge-Kutta\nrollout!(qtraj; algorithm=Tsit5(), abstol=1e-10)\nfid_rk = fidelity(qtraj)\n\nSee also: rollout\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{DensityTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::DensityTrajectory, pulse::AbstractPulse; algorithm=Tsit5(), n_points=101)\n\nCreate a new density trajectory by rolling out a new pulse. Note: Default algorithm is Tsit5() since density evolution uses standard ODE solvers. See rollout(::UnitaryTrajectory, ::AbstractPulse) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{DensityTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::DensityTrajectory; algorithm=Tsit5(), n_points=101, kwargs...)\n\nRe-solve density trajectory with same pulse but different ODE parameters. Note: Default algorithm is Tsit5() since density evolution uses standard ODE solvers. See rollout(::UnitaryTrajectory; kwargs...) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{KetTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::KetTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)\n\nCreate a new ket trajectory by rolling out a new pulse. See rollout(::UnitaryTrajectory, ::AbstractPulse) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{KetTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::KetTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)\n\nRe-solve ket trajectory with same pulse but different ODE parameters. See rollout(::UnitaryTrajectory; kwargs...) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{MultiKetTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::MultiKetTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)\n\nCreate a new multi-ket trajectory by rolling out a new pulse. See rollout(::UnitaryTrajectory, ::AbstractPulse) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{MultiKetTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::MultiKetTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)\n\nRe-solve multi-ket trajectory with same pulse but different ODE parameters. See rollout(::UnitaryTrajectory; kwargs...) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{UnitaryTrajectory, AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::UnitaryTrajectory, pulse::AbstractPulse; algorithm=MagnusGL4(), n_points=101)\n\nCreate a new quantum trajectory by rolling out a new pulse through the system. Returns a new UnitaryTrajectory with the updated pulse and solution.\n\nArguments\n\nqtraj::UnitaryTrajectory: The base trajectory (provides system, initial, goal)\npulse::AbstractPulse: The new control pulse to roll out\n\nKeyword Arguments\n\nalgorithm: ODE solver algorithm (default: MagnusGL4())\nn_points::Int: Number of time points to sample (default: 101)\n\nExample\n\nqtraj = UnitaryTrajectory(sys, old_pulse, goal)\n\n# Roll out a new pulse\nqtraj_new = rollout(qtraj, new_pulse)\n\n# Check fidelity\nfid = fidelity(qtraj_new)\n\nSee also: extract_pulse, rollout!, fidelity\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout-Tuple{UnitaryTrajectory}","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj::UnitaryTrajectory; algorithm=MagnusGL4(), n_points=101, kwargs...)\n\nRe-solve the trajectory with the same pulse but different ODE parameters. Returns a new UnitaryTrajectory with the updated solution.\n\nUseful for comparing different solvers or tolerances.\n\nKeyword Arguments\n\nalgorithm: ODE solver algorithm (default: MagnusGL4())\nn_points::Int: Number of time points to sample (default: 101)\nAdditional kwargs passed to solve (e.g., abstol, reltol)\n\nExample\n\nqtraj = UnitaryTrajectory(sys, pulse, goal)\n\n# Compare Magnus vs Runge-Kutta\nqtraj_rk = rollout(qtraj; algorithm=Tsit5(), abstol=1e-10)\nfid_magnus = fidelity(qtraj)\nfid_rk = fidelity(qtraj_rk)\n\nSee also: rollout!\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.AbstractPulse","page":"Library","title":"Piccolo.Quantum.Pulses.AbstractPulse","text":"AbstractPulse\n\nAbstract type for all pulse types. All pulses are callable: pulse(t) returns the control vector at time t.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.AbstractSplinePulse","page":"Library","title":"Piccolo.Quantum.Pulses.AbstractSplinePulse","text":"AbstractSplinePulse <: AbstractPulse\n\nAbstract type for spline-based pulses (linear and cubic interpolation). These pulses use the spline coefficients as optimization variables.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.CompositePulse","page":"Library","title":"Piccolo.Quantum.Pulses.CompositePulse","text":"CompositePulse(pulses::Vector{<:AbstractPulse}, mode::Symbol=:interleave)\n\nCreate a composite pulse from multiple component pulses.\n\nArguments\n\npulses: Vector of pulse objects to combine\nmode: How to combine the drives\n:interleave - Interleave drives: [p1d1, p2d1, p1d2, p2d2, ...]\n:concatenate - Concatenate drives: [p1d1, p1d2, ..., p2d1, p2d2, ...]\n\nExample\n\n# For MS gate with 2 ions: [Œ©‚ÇÅ, œÜ‚ÇÅ, Œ©‚ÇÇ, œÜ‚ÇÇ]\nŒ©_pulse = GaussianPulse([Œ©‚ÇÅ, Œ©‚ÇÇ], œÉ, T)  # 2 drives\nœÜ_pulse = ErfPulse([œÜ‚ÇÅ, œÜ‚ÇÇ], œÉ, T)        # 2 drives\npulse = CompositePulse([Œ©_pulse, œÜ_pulse], :interleave)\n# Result: pulse(t) = [Œ©‚ÇÅ(t), œÜ‚ÇÅ(t), Œ©‚ÇÇ(t), œÜ‚ÇÇ(t)]\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.CompositePulse-2","page":"Library","title":"Piccolo.Quantum.Pulses.CompositePulse","text":"CompositePulse{F<:Function} <: AbstractPulse\n\nComposite pulse that combines multiple pulse objects by interleaving their drives.\n\nUseful for creating pulses with different shapes for different control types, such as Gaussian amplitude + erf phase for trapped ion gates.\n\nFields\n\nf::F: Function that evaluates the composite pulse\npulses::Vector{<:AbstractPulse}: Component pulses\ndrive_mapping::Vector{Vector{Int}}: Maps pulse i, drive j to composite drive index\nduration::Float64: Total pulse duration (must match for all components)\nn_drives::Int: Total number of drives across all pulses\n\nExample\n\n# Amplitude: Gaussian (2 drives for 2 ions)\nŒ©_pulse = GaussianPulse([Œ©_max, Œ©_max], œÉ, T)\n\n# Phase: Error function (2 drives for 2 ions)\nœÜ_pulse = ErfPulse([œÜ_max, œÜ_max], œÉ, T)\n\n# Composite: [Œ©‚ÇÅ, œÜ‚ÇÅ, Œ©‚ÇÇ, œÜ‚ÇÇ] - interleaved\npulse = CompositePulse([Œ©_pulse, œÜ_pulse], :interleave)\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.CubicSplinePulse","page":"Library","title":"Piccolo.Quantum.Pulses.CubicSplinePulse","text":"CubicSplinePulse{I<:CubicHermiteSpline} <: AbstractPulse\n\nPulse with cubic Hermite spline interpolation. Uses both control values AND  derivatives for exact reconstruction after optimization.\n\nFields\n\ncontrols::I: CubicHermiteSpline from DataInterpolations\nduration::Float64: Total pulse duration\nn_drives::Int: Number of control drives\ndrive_name::Symbol: Name of the drive variable (default :u)\ninitial_value::Vector{Float64}: Initial boundary condition (default: zeros)\nfinal_value::Vector{Float64}: Final boundary condition (default: zeros)\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector}","page":"Library","title":"Piccolo.Quantum.Pulses.CubicSplinePulse","text":"CubicSplinePulse(controls::AbstractMatrix, derivatives::AbstractMatrix, times::AbstractVector; drive_name=:u, initial_value=nothing, final_value=nothing)\n\nCreate a cubic Hermite spline pulse from control values, derivatives, and times.\n\nArguments\n\ncontrols: Matrix of size (n_drives, n_times) with control values\nderivatives: Matrix of size (n_drives, n_times) with control derivatives\ntimes: Vector of sample times (must start at 0)\n\nKeyword Arguments\n\ndrive_name: Name of the drive variable (default :u)\ninitial_value: Initial boundary condition (default: zeros(n_drives))\nfinal_value: Final boundary condition (default: zeros(n_drives))\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{AbstractMatrix, AbstractVector}","page":"Library","title":"Piccolo.Quantum.Pulses.CubicSplinePulse","text":"CubicSplinePulse(controls::AbstractMatrix, times::AbstractVector; drive_name=:u, initial_value=nothing, final_value=nothing)\n\nCreate a cubic Hermite spline pulse with zero derivatives at all knot points. Useful for initial guesses where smoothness constraints will be enforced by optimizer.\n\nArguments\n\ncontrols: Matrix of size (n_drives, n_times) with control values\ntimes: Vector of sample times (must start at 0)\n\nKeyword Arguments\n\ndrive_name: Name of the drive variable (default :u)\ninitial_value: Initial boundary condition (default: zeros(n_drives))\nfinal_value: Final boundary condition (default: zeros(n_drives))\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{AbstractPulse, Int64}","page":"Library","title":"Piccolo.Quantum.Pulses.CubicSplinePulse","text":"CubicSplinePulse(pulse::AbstractPulse, n_samples::Int; kwargs...)\nCubicSplinePulse(pulse::AbstractPulse, times::AbstractVector; kwargs...)\n\nConvert any pulse to a CubicSplinePulse by sampling at specified times. Derivatives are computed using ForwardDiff for automatic differentiation.\n\nUseful for initializing optimization problems with smooth analytic pulse shapes.\n\nArguments\n\npulse: Source pulse (GaussianPulse, ErfPulse, CompositePulse, etc.)\nn_samples: Number of uniformly spaced samples (alternative to times)\ntimes: Specific sample times (alternative to n_samples)\n\nKeyword Arguments\n\ndrive_name: Name for the drive variable (default: :du)\ninitial_value: Initial boundary condition (default: pulse(0.0))\nfinal_value: Final boundary condition (default: pulse(duration))\n\nExample\n\ngaussian = GaussianPulse([1.0, 2.0], 0.1, 1.0)\ncubic = CubicSplinePulse(gaussian, 50)  # 50 samples with ForwardDiff derivatives\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.CubicSplinePulse-Tuple{NamedTrajectory}","page":"Library","title":"Piccolo.Quantum.Pulses.CubicSplinePulse","text":"CubicSplinePulse(traj::NamedTrajectory; drive_name=:u, derivative_name=:du)\n\nConstruct a CubicSplinePulse (Hermite) from a NamedTrajectory using both  control values and derivatives.\n\nArguments\n\ntraj: NamedTrajectory with control and derivative data\n\nKeyword Arguments\n\ndrive_name: Name of the drive component (default: :u)\nderivative_name: Name of the derivative component (default: :du)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.ErfPulse","page":"Library","title":"Piccolo.Quantum.Pulses.ErfPulse","text":"ErfPulse{F<:Function} <: AbstractPulse\n\nAnalytic error function pulse for phase compensation in trapped ion gates.\n\nThe error function profile is commonly used to compensate AC Stark shifts in  M√∏lmer-S√∏rensen gates, where œÜ(t) ‚àù erf(‚àö2 (t - t‚ÇÄ)/œÉ) cancels time-varying phases from off-resonant spectator modes.\n\nu_i(t) = amplitudes[i] * erf(‚àö2 * (t - centers[i]) / sigmas[i])\n\nTypically scaled to range [0, 1] or [-1, 1] by adjusting amplitude.\n\nFields\n\nf::F: Function that evaluates the pulse\namplitudes::Vector{Float64}: Peak amplitude for each drive\nsigmas::Vector{Float64}: Width parameter for each drive\ncenters::Vector{Float64}: Center time for each drive\nduration::Float64: Total pulse duration\nn_drives::Int: Number of control drives\n\nReferences\n\nMizrahi et al., \"Realization and Calibration of Continuously Parameterized  Two-Qubit Gates...\", IEEE TQE (2024), Figure 7b\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.ErfPulse-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, Real}","page":"Library","title":"Piccolo.Quantum.Pulses.ErfPulse","text":"ErfPulse(amplitudes, sigmas, centers, duration)\n\nCreate an error function pulse with per-drive parameters.\n\nArguments\n\namplitudes: Peak amplitude for each drive\nsigmas: Width parameter for each drive (controls steepness)\ncenters: Center time for each drive (inflection point)\nduration: Total pulse duration\n\nExample\n\nusing SpecialFunctions: erf\n\n# Phase compensation for MS gate\nœÜ_max = œÄ/4  # Maximum phase shift\nT = 50.0     # Gate duration\nœÉ = T/4      # Width parameter\n\npulse = ErfPulse([œÜ_max], [œÉ], [T/2], T)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.ErfPulse-Tuple{AbstractVector{<:Real}, Real, Real}","page":"Library","title":"Piccolo.Quantum.Pulses.ErfPulse","text":"ErfPulse(amplitudes, sigma, duration; center=duration/2)\n\nCreate an error function pulse with shared sigma and center across all drives.\n\nArguments\n\namplitudes: Peak amplitude for each drive\nsigma: Shared width parameter for all drives\nduration: Total pulse duration\n\nKeyword Arguments\n\ncenter: Shared center time (default: duration/2)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.GaussianPulse","page":"Library","title":"Piccolo.Quantum.Pulses.GaussianPulse","text":"GaussianPulse{F<:Function} <: AbstractPulse\n\nAnalytic Gaussian pulse. Each drive has its own amplitude, width (sigma), and center.\n\nu_i(t) = amplitudes[i] * exp(-(t - centers[i])¬≤ / (2 * sigmas[i]¬≤))\n\nFields\n\nf::F: Function that evaluates the pulse\namplitudes::Vector{Float64}: Peak amplitude for each drive\nsigmas::Vector{Float64}: Gaussian width for each drive\ncenters::Vector{Float64}: Center time for each drive\nduration::Float64: Total pulse duration\nn_drives::Int: Number of control drives\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.GaussianPulse-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, Real}","page":"Library","title":"Piccolo.Quantum.Pulses.GaussianPulse","text":"GaussianPulse(amplitudes, sigmas, centers, duration)\n\nCreate a Gaussian pulse with per-drive parameters.\n\nArguments\n\namplitudes: Peak amplitude for each drive\nsigmas: Gaussian width (standard deviation) for each drive\ncenters: Center time for each drive\nduration: Total pulse duration\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.GaussianPulse-Tuple{AbstractVector{<:Real}, Real, Real}","page":"Library","title":"Piccolo.Quantum.Pulses.GaussianPulse","text":"GaussianPulse(amplitudes, sigma, duration; center=duration/2)\n\nCreate a Gaussian pulse with shared sigma and center across all drives.\n\nArguments\n\namplitudes: Peak amplitude for each drive\nsigma: Shared Gaussian width for all drives\nduration: Total pulse duration\n\nKeyword Arguments\n\ncenter: Shared center time (default: duration/2)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.LinearSplinePulse","page":"Library","title":"Piccolo.Quantum.Pulses.LinearSplinePulse","text":"LinearSplinePulse{I<:LinearInterpolation} <: AbstractSplinePulse\n\nPulse with linear interpolation between sample points.\n\nFields\n\ncontrols::I: LinearInterpolation from DataInterpolations\nduration::Float64: Total pulse duration\nn_drives::Int: Number of control drives\ndrive_name::Symbol: Name of the drive variable (default :u)\ninitial_value::Vector{Float64}: Initial boundary condition (default: zeros)\nfinal_value::Vector{Float64}: Final boundary condition (default: zeros)\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.LinearSplinePulse-Tuple{AbstractMatrix, AbstractVector}","page":"Library","title":"Piccolo.Quantum.Pulses.LinearSplinePulse","text":"LinearSplinePulse(controls::AbstractMatrix, times::AbstractVector; drive_name=:u, initial_value=nothing, final_value=nothing)\n\nCreate a linearly interpolated pulse from control samples and times.\n\nArguments\n\ncontrols: Matrix of size (n_drives, n_times) with control values\ntimes: Vector of sample times (must start at 0)\n\nKeyword Arguments\n\ndrive_name: Name of the drive variable (default :u)\ninitial_value: Initial boundary condition (default: zeros(n_drives))\nfinal_value: Final boundary condition (default: zeros(n_drives))\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.LinearSplinePulse-Tuple{AbstractPulse, Int64}","page":"Library","title":"Piccolo.Quantum.Pulses.LinearSplinePulse","text":"LinearSplinePulse(pulse::AbstractPulse, n_samples::Int; kwargs...)\nLinearSplinePulse(pulse::AbstractPulse, times::AbstractVector; kwargs...)\n\nConvert any pulse to a LinearSplinePulse by sampling at specified times.\n\nUseful for initializing optimization problems with analytic pulse shapes.\n\nArguments\n\npulse: Source pulse (GaussianPulse, ErfPulse, CompositePulse, etc.)\nn_samples: Number of uniformly spaced samples (alternative to times)\ntimes: Specific sample times (alternative to n_samples)\n\nKeyword Arguments\n\ndrive_name: Name for the drive variable (default: :u)\ninitial_value: Initial boundary condition (default: pulse(0.0))\nfinal_value: Final boundary condition (default: pulse(duration))\n\nExample\n\ngaussian = GaussianPulse([1.0, 2.0], 0.1, 1.0)\nlinear = LinearSplinePulse(gaussian, 50)  # 50 samples\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.LinearSplinePulse-Tuple{NamedTrajectory}","page":"Library","title":"Piccolo.Quantum.Pulses.LinearSplinePulse","text":"LinearSplinePulse(traj::NamedTrajectory; drive_name=:u)\n\nConstruct a LinearSplinePulse from a NamedTrajectory.\n\nArguments\n\ntraj: NamedTrajectory with control data\n\nKeyword Arguments\n\ndrive_name: Name of the drive component (default: :u)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.ZeroOrderPulse","page":"Library","title":"Piccolo.Quantum.Pulses.ZeroOrderPulse","text":"ZeroOrderPulse{I<:ConstantInterpolation} <: AbstractPulse\n\nPiecewise constant pulse (zero-order hold). The control value at time t is the value at the most recent sample point.\n\nFields\n\ncontrols::I: ConstantInterpolation from DataInterpolations\nduration::Float64: Total pulse duration\nn_drives::Int: Number of control drives\ndrive_name::Symbol: Name of the drive variable (default :u)\ninitial_value::Vector{Float64}: Initial boundary condition (default: zeros)\nfinal_value::Vector{Float64}: Final boundary condition (default: zeros)\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.Pulses.ZeroOrderPulse-Tuple{AbstractMatrix, AbstractVector}","page":"Library","title":"Piccolo.Quantum.Pulses.ZeroOrderPulse","text":"ZeroOrderPulse(controls::AbstractMatrix, times::AbstractVector; drive_name=:u, initial_value=nothing, final_value=nothing)\n\nCreate a zero-order hold pulse from control samples and times.\n\nArguments\n\ncontrols: Matrix of size (n_drives, n_times) with control values\ntimes: Vector of sample times (must start at 0)\n\nKeyword Arguments\n\ndrive_name: Name of the drive variable (default :u)\ninitial_value: Initial boundary condition (default: zeros(n_drives))\nfinal_value: Final boundary condition (default: zeros(n_drives))\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.ZeroOrderPulse-Tuple{NamedTrajectory}","page":"Library","title":"Piccolo.Quantum.Pulses.ZeroOrderPulse","text":"ZeroOrderPulse(traj::NamedTrajectory; drive_name=:u)\n\nConstruct a ZeroOrderPulse from a NamedTrajectory.\n\nArguments\n\ntraj: NamedTrajectory with control data\n\nKeyword Arguments\n\ndrive_name: Name of the drive component (default: :u)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.drive_name-Tuple{AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Pulses.drive_name","text":"drive_name(pulse::AbstractPulse)\n\nReturn the name of the drive variable for this pulse.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.duration-Tuple{AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Pulses.duration","text":"duration(pulse::AbstractPulse)\n\nReturn the duration of the pulse.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.get_knot_count-Tuple{AbstractSplinePulse}","page":"Library","title":"Piccolo.Quantum.Pulses.get_knot_count","text":"get_knot_count(pulse::AbstractSplinePulse)\n\nReturn the number of knots in the spline pulse.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.get_knot_derivatives-Tuple{CubicSplinePulse}","page":"Library","title":"Piccolo.Quantum.Pulses.get_knot_derivatives","text":"get_knot_derivatives(pulse::CubicSplinePulse)\n\nReturn the Hermite tangents at knot points (the du matrix). Only available for CubicSplinePulse.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.get_knot_times-Tuple{LinearSplinePulse}","page":"Library","title":"Piccolo.Quantum.Pulses.get_knot_times","text":"get_knot_times(pulse::AbstractSplinePulse)\n\nReturn the knot times stored in the spline pulse interpolant.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.get_knot_values-Tuple{LinearSplinePulse}","page":"Library","title":"Piccolo.Quantum.Pulses.get_knot_values","text":"get_knot_values(pulse::CubicSplinePulse)\n\nReturn the control values at knot points (the u matrix).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.n_drives-Tuple{AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Pulses.n_drives","text":"n_drives(pulse::AbstractPulse)\n\nReturn the number of control drives in the pulse.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.sample-Tuple{AbstractPulse, AbstractVector}","page":"Library","title":"Piccolo.Quantum.Pulses.sample","text":"sample(pulse::AbstractPulse, times::AbstractVector)\n\nSample the pulse at the given times. Returns a matrix of size (n_drives, length(times)).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.sample-Tuple{AbstractPulse}","page":"Library","title":"Piccolo.Quantum.Pulses.sample","text":"sample(pulse::AbstractPulse; n_samples::Int=100)\n\nSample the pulse uniformly with n_samples points. Returns (controls, times).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts._update_system!","page":"Library","title":"Piccolo.Quantum.Rollouts._update_system!","text":"_update_system!(qtraj, sys::QuantumSystem)\n\nInternal method to update the system field in a quantum trajectory. Extended in quantum_trajectories module for specific trajectory types.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.Rollouts.extract_globals","page":"Library","title":"Piccolo.Quantum.Rollouts.extract_globals","text":"extract_globals(traj::NamedTrajectory, names::Vector{Symbol}=Symbol[])\n\nExtract global variables from trajectory as a NamedTuple for easy access. If names is empty, extracts all global variables.\n\nExample\n\ntraj = NamedTrajectory(...; global_data=[0.5, 1.0], global_components=(Œ¥=1:1, Œ©=2:2))\ng = extract_globals(traj)  # (Œ¥ = 0.5, Œ© = 1.0)\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(œÅ::AbstractMatrix{<:Number}, œÅ_goal::AbstractMatrix{<:Number})\n\nCalculate the fidelity between two density matrices œÅ and œÅ_goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(œà::AbstractVector{<:Number}, œà_goal::AbstractVector{<:Number})\n\nCalculate the fidelity between two quantum states œà and œà_goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout","text":"rollout(qtraj, args...; kwargs...)\n\nRoll out a quantum trajectory with new pulse or ODE parameters. Extended in quantum_trajectories module for specific trajectory types.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.Rollouts.rollout!","page":"Library","title":"Piccolo.Quantum.Rollouts.rollout!","text":"rollout!(qtraj, args...; kwargs...)\n\nIn-place rollout of quantum trajectory with new pulse or ODE parameters. Extended in quantum_trajectories module for specific trajectory types.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.Rollouts.unitary_fidelity-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Library","title":"Piccolo.Quantum.Rollouts.unitary_fidelity","text":"unitary_fidelity(U::AbstractMatrix{<:Number}, U_goal::AbstractMatrix{<:Number})\n\nCalculate the fidelity between unitary operators U and U_goal in the subspace.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.update_global_params!-Tuple{Any, Any}","page":"Library","title":"Piccolo.Quantum.Rollouts.update_global_params!","text":"update_global_params!(qtraj, traj::NamedTrajectory)\n\nUpdate the global parameters in the quantum trajectory's system with the optimized values from the NamedTrajectory after optimization. Handles immutable QuantumSystem by reconstructing with updated global_params NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.AbstractPiccoloOperator","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.AbstractPiccoloOperator","text":"AbstractPiccoloOperator\n\nUnion type for operators.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator\n\nEmbedded operator type to represent an operator embedded in a subspace of a larger quantum system.\n\nFields\n\noperator::Matrix{<:Number}: Embedded operator of size   prod(subsystem_levels) x prod(subsystem_levels).\nsubspace::Vector{Int}: Indices of the subspace the operator is embedded in.\nsubsystem_levels::Vector{Int}: Levels of the subsystems in the composite system.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n)\n\nEmbed the subspace_operator into the provided subspaces of a composite system, where the subsystem_indices list the subspaces at which the operator is defined, and the subsystem_levels list the levels of the subsystems in which the operator is embedded.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, CompositeQuantumSystem}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    composite_system::CompositeQuantumSystem\n)\n\nEmbed the subspace_operator into the provided subspaces of a composite system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, QuantumSystem}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(subspace_operator::AbstractMatrix{<:Number}, system::QuantumSystem; kwargs...)\n\nEmbed the subspace_operator into a quantum system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{Int64}}} where T<:Number","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\n\nCreate an embedded operator. The operator is embedded at the subspace of the system spanned by the subsystem_levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.embed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.embed","text":"embed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator)\n\nEmbed the subspace_operator in the subspace of a larger embedded_operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.embed-Union{Tuple{R}, Tuple{AbstractMatrix{R}, AbstractVector{Int64}, Int64}} where R<:Number","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.embed","text":"embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int)\n\nEmbed an operator in the subspace of a larger matrix of size levels x levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.get_enr_subspace_indices-Tuple{Int64, AbstractVector{Int64}}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.get_enr_subspace_indices","text":"get_enr_subspace_indices(excitation_restriction::Int, subsystem_levels::AbstractVector{Int})\n\nGet the indices for the subspace of the quantum system with an excitation restriction.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.get_iso_vec_leakage_indices","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.get_iso_vec_leakage_indices","text":"get_iso_vec_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_iso_vec_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_iso_vec_leakage_indices(op::EmbeddedOperator)\n\nGet the indices for the leakage in the isomorphic vector space for operators.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.get_iso_vec_subspace_indices","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.get_iso_vec_subspace_indices","text":"get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the subspace in the isomorphic vector space for operators.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.get_leakage_indices","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.get_leakage_indices","text":"get_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_leakage_indices(op::EmbeddedOperator)\n\nGet the indices for the states that are outside of the provided subspace of the quantum system.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.get_subspace_indices","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.get_subspace_indices","text":"get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)\nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the provided subspace of the quantum system.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.unembed","text":"unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int})\n\nUnembed a subspace operator from the matrix. This is equivalent to calling matrix[subspace, subspace].\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.unembed","text":"unembed(op::AbstractMatrix, embedded_op::EmbeddedOperator)\n\nUnembed a sub-matrix from the op at the subspace defined by embedded_op.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.EmbeddedOperators.unembed-Tuple{EmbeddedOperator}","page":"Library","title":"Piccolo.Quantum.EmbeddedOperators.unembed","text":"unembed(embedded_op::EmbeddedOperator)\n\nUnembed an embedded operator, returning the original operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.LiftedOperators.lift_operator","page":"Library","title":"Piccolo.Quantum.LiftedOperators.lift_operator","text":"lift_operator(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift_operator(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift_operator(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift_operator(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\n\nLift an operator acting on the i-th subsystem within subsystem_levels to an operator acting on the entire system spanning subsystem_levels.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Quantum.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}","page":"Library","title":"Piccolo.Quantum.DirectSums.direct_sum","text":"direct_sum(A::AbstractMatrix, B::AbstractMatrix)\n\nReturns the direct sum of two matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}","page":"Library","title":"Piccolo.Quantum.DirectSums.direct_sum","text":"direct_sum(AÃÉ‚Éó::AbstractVector, BÃÉ‚Éó::AbstractVector)\n\nReturns the direct sum of two iso_vec operators.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}","page":"Library","title":"Piccolo.Quantum.DirectSums.direct_sum","text":"direct_sum(sys1::QuantumSystem, sys2::QuantumSystem)\n\nReturns the direct sum of two QuantumSystem objects.\n\nConstructs a new system where the Hilbert space is the direct sum of the two input systems: H = H‚ÇÅ ‚äï H‚ÇÇ = [H‚ÇÅ  0 ]                [0   H‚ÇÇ]\n\nBoth systems must have the same number of drives. The resulting system uses sys1's drive_bounds.\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], [(-1.0, 1.0)])\nsys2 = QuantumSystem([PAULIS[:Y]], [(-1.0, 1.0)])\nsys_combined = direct_sum(sys1, sys2)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}","page":"Library","title":"Piccolo.Quantum.DirectSums.direct_sum","text":"direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC)\n\nReturns the direct sum of two sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.G-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.G","text":"G(H::AbstractMatrix)::Matrix{Float64}\n\nReturns the isomorphism of -iH, i.e. G(H) = textiso(-iH).\n\nSee also Isomorphisms.iso, Isomorphisms.H.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.H-Tuple{AbstractMatrix{<:Real}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.H","text":"H(G::AbstractMatrix{<:Real})\n\nReturns the inverse of G(H) = iso(-iH), i.e. returns H.\n\nSee also Isomorphisms.iso, Isomorphisms.G.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.ad_vec-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"Piccolo.Quantum.Isomorphisms.ad_vec","text":"ad_vec(H::AbstractMatrix{‚ÑÇ}; anti::Bool=false) where ‚ÑÇ <: Number\n\nReturns the vectorized adjoint action of a matrix H:\n\ntextad_vec(H) = mqty(1  0  0  1) otimes H - (-1)^textanti mqty(0  1  1  0) otimes H^*\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.bloch_to_ket-Union{Tuple{AbstractVector{R}}, Tuple{R}} where R<:Real","page":"Library","title":"Piccolo.Quantum.Isomorphisms.bloch_to_ket","text":"bloch_to_ket(v::AbstractVector{<:Real}; digits=6)\n\nConvert a Bloch vector to a ket (up to global phase).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.density_to_iso_vec-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.density_to_iso_vec","text":"density_to_iso_vec(œÅ::AbstractMatrix{<:Number})\n\nReturns the isomorphism œÅ‚ÉóÃÉ = ket_to_iso(vec(œÅ)) of a density matrix œÅ\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso","text":"iso(H::AbstractMatrix{<:Number})\n\nReturns the isomorphism of H:\n\niso(H) = widetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\nwhere Im(H) and Re(H) are the imaginary and real parts of H and the tilde  indicates the standard isomorphism of a complex valued matrix:\n\nwidetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\nSee also Isomorphisms.G, Isomorphisms.H.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso_D-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso_D","text":"iso_D(L::AbstractMatrix{‚ÑÇ}) where ‚ÑÇ <: Number\n\nReturns the isomorphic representation of the Lindblad dissipator L.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso_operator_to_iso_vec-Union{Tuple{AbstractMatrix{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù<:Real","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso_operator_to_iso_vec","text":"iso_operator_to_iso_vec(UÃÉ::AbstractMatrix{‚Ñù}) where ‚Ñù <: Real\n\nConvert a real matrix UÃÉ representing an isomorphism operator into a real vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso_operator_to_operator-Tuple{Any}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso_operator_to_operator","text":"iso_operator_to_operator(UÃÉ)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso_to_ket-Tuple{AbstractVector{<:Real}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso_to_ket","text":"iso_to_ket(œàÃÉ::AbstractVector{<:Real})\n\nConvert a real isomorphism vector œàÃÉ into a ket vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso_vec_to_density-Tuple{AbstractVector{<:Real}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso_vec_to_density","text":"iso_vec_to_density(œÅ‚ÉóÃÉ::AbstractVector{<:Real})\n\nReturns the density matrix œÅ from its isomorphism œÅ‚ÉóÃÉ\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso_vec_to_iso_operator-Union{Tuple{AbstractVector{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù<:Real","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso_vec_to_iso_operator","text":"iso_vec_to_iso_operator(UÃÉ‚Éó::AbstractVector{‚Ñù}) where ‚Ñù <: Real\n\nConvert a real vector UÃÉ‚Éó into a real matrix representing an isomorphism operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.iso_vec_to_operator-Union{Tuple{AbstractVector{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù<:Real","page":"Library","title":"Piccolo.Quantum.Isomorphisms.iso_vec_to_operator","text":"iso_vec_to_operator(UÃÉ‚Éó::AbstractVector{‚Ñù}) where ‚Ñù <: Real\n\nConvert a real vector UÃÉ‚Éó into a complex matrix representing an operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.ket_to_bloch-Tuple{AbstractVector{<:Number}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.ket_to_bloch","text":"ket_to_bloch(œà::AbstractVector{<:Number})\n\nConvert a ket to a Bloch vector representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.ket_to_iso-Tuple{AbstractVector{<:Number}}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.ket_to_iso","text":"ket_to_iso(œà::AbstractVector{<:Number})\n\nConvert a ket vector œà into a complex vector with real and imaginary parts.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.mat-Tuple{AbstractVector}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.mat","text":"mat(x::AbstractVector)\n\nConvert a vector x into a square matrix. The length of x must be a perfect square.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.operator_to_iso_operator-Tuple{Any}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.operator_to_iso_operator","text":"operator_to_iso_operator(U)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.operator_to_iso_vec-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"Piccolo.Quantum.Isomorphisms.operator_to_iso_vec","text":"operator_to_iso_vec(U::AbstractMatrix{‚ÑÇ}) where ‚ÑÇ <: Number\n\nConvert a complex matrix U representing an operator into a real vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Isomorphisms.var_G-Union{Tuple{‚Ñù2}, Tuple{‚Ñù1}, Tuple{AbstractMatrix{‚Ñù1}, AbstractVector{<:AbstractMatrix{‚Ñù2}}}} where {‚Ñù1<:Real, ‚Ñù2<:Real}","page":"Library","title":"Piccolo.Quantum.Isomorphisms.var_G","text":"var_G(G::AbstractMatrix{<:Real}, G_vars::AbstractVector{<:AbstractMatrix{<:Real}})\n\nReturns the variational generator of G with variational derivatives, G_vars.\n\nThe variational generator is \n\ntextvar_G(G G_a G_b) = mqty( G  0  0  G_a  G  0  G_b  0  G )\n\nwhere G is the isomorphism of a Hamiltonian and G_a and G_b are the variational  derivatives of G for parameters a and b, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumControlProblems.QuantumControlProblem","page":"Library","title":"Piccolo.Control.QuantumControlProblems.QuantumControlProblem","text":"QuantumControlProblem{QT<:AbstractQuantumTrajectory}\n\nWrapper combining quantum trajectory information with trajectory optimization problem.\n\nThis type enables:\n\nType-stable dispatch on quantum trajectory type (Unitary, Ket, Density)\nClean separation of quantum information (system, goal) from optimization details\nComposable problem transformations (e.g., SmoothPulseProblem ‚Üí MinimumTimeProblem)\n\nFields\n\nqtraj::QT: Quantum trajectory containing system, goal, and quantum state information\nprob::DirectTrajOptProblem: Direct trajectory optimization problem with objective, dynamics, constraints\n\nConstruction\n\nTypically created via problem templates:\n\nqtraj = UnitaryTrajectory(sys, U_goal, N)\nqcp = SmoothPulseProblem(qtraj; Q=100.0, R=1e-2)\n\nAccessors\n\nget_trajectory(qcp): Get the NamedTrajectory\nget_system(qcp): Get the QuantumSystem\nget_goal(qcp): Get the goal state/unitary\nstate_name(qcp): Get the state variable name\ndrive_name(qcp): Get the control variable name\n\nSolving\n\nsolve!(qcp; max_iter=100, verbose=true)\n\n\n\n\n\n","category":"type"},{"location":"lib/#DirectTrajOpt.Solvers.solve!-Tuple{QuantumControlProblem}","page":"Library","title":"DirectTrajOpt.Solvers.solve!","text":"solve!(qcp::QuantumControlProblem; sync::Bool=true, kwargs...)\n\nSolve the quantum control problem by forwarding to the inner DirectTrajOptProblem.\n\nArguments\n\nsync::Bool=true: If true, call sync_trajectory! after solving to update qtraj.trajectory with physical control values. Set to false to skip synchronization (e.g., for debugging).\n\nAll other keyword arguments are passed to the DirectTrajOpt solver.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumControlProblems.get_trajectory-Tuple{QuantumControlProblem}","page":"Library","title":"Piccolo.Control.QuantumControlProblems.get_trajectory","text":"get_trajectory(qcp::QuantumControlProblem)\n\nGet the NamedTrajectory from the optimization problem.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumControlProblems.sync_trajectory!-Tuple{QuantumControlProblem}","page":"Library","title":"Piccolo.Control.QuantumControlProblems.sync_trajectory!","text":"sync_trajectory!(qcp::QuantumControlProblem)\n\nUpdate the quantum trajectory in-place from the optimized control values.\n\nAfter optimization, this function:\n\nExtracts the optimized controls from prob.trajectory (unadapting if needed)\nCreates a new pulse with those controls via extract_pulse\nRe-solves the ODE to get the updated quantum evolution\nReplaces qtraj with the new quantum trajectory\n\nThis gives you access to the continuous-time ODE solution with the optimized controls, allowing you to:\n\nEvaluate the fidelity via fidelity(qcp.qtraj)\nSample the quantum state at any time via qcp.qtraj(t)\nGet the optimized pulse via get_pulse(qcp.qtraj)\n\nExample\n\nsolve!(qcp; max_iter=100)  # Automatically calls sync_trajectory!\nfid = fidelity(qcp.qtraj)  # Evaluate fidelity with continuous-time solution\npulse = get_pulse(qcp.qtraj)  # Get the optimized pulse\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Pulses.drive_name-Tuple{QuantumControlProblem}","page":"Library","title":"Piccolo.Quantum.Pulses.drive_name","text":"drive_name(qcp::QuantumControlProblem)\n\nGet the control variable name from the quantum trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_goal-Tuple{QuantumControlProblem}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_goal","text":"get_goal(qcp::QuantumControlProblem)\n\nGet the goal state/operator from the quantum trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.get_system-Tuple{QuantumControlProblem}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.get_system","text":"get_system(qcp::QuantumControlProblem)\n\nGet the QuantumSystem from the quantum trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.QuantumTrajectories.state_name-Tuple{QuantumControlProblem}","page":"Library","title":"Piccolo.Quantum.QuantumTrajectories.state_name","text":"state_name(qcp::QuantumControlProblem)\n\nGet the state variable name from the quantum trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Quantum.Rollouts.fidelity-Tuple{QuantumControlProblem}","page":"Library","title":"Piccolo.Quantum.Rollouts.fidelity","text":"fidelity(qcp::QuantumControlProblem; kwargs...)\n\nCompute the fidelity of the quantum trajectory.\n\nThis is a convenience wrapper that forwards to fidelity(qcp.qtraj; kwargs...).\n\nExample\n\nsolve!(qcp)\nfid = fidelity(qcp)  # Equivalent to fidelity(qcp.qtraj)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.MinimumTimeProblem-Union{Tuple{QuantumControlProblem{QT}}, Tuple{QT}} where QT<:AbstractQuantumTrajectory","page":"Library","title":"Piccolo.Control.ProblemTemplates.MinimumTimeProblem","text":"MinimumTimeProblem(qcp::QuantumControlProblem; kwargs...)\n\nConvert an existing quantum control problem to minimum-time optimization.\n\nIMPORTANT: This function requires an existing QuantumControlProblem (e.g., from SmoothPulseProblem). It cannot be created directly from a quantum trajectory. The workflow is:\n\nCreate base problem with SmoothPulseProblem (or similar)\nSolve base problem to get feasible solution\nConvert to minimum-time with MinimumTimeProblem\n\nThis ensures the problem starts from a good initialization and maintains solution quality through the final fidelity constraint.\n\nType Dispatch\n\nAutomatically handles different quantum trajectory types through the type parameter:\n\nQuantumControlProblem{UnitaryTrajectory} ‚Üí Uses FinalUnitaryFidelityConstraint\nQuantumControlProblem{KetTrajectory} ‚Üí Uses FinalKetFidelityConstraint\nQuantumControlProblem{DensityTrajectory} ‚Üí Not yet implemented\n\nThe optimization problem is:\n\nbeginaligned\nundersetvectildeq u Delta ttextminimize  quad\nJ_textoriginal(vectildeq u) + D sum_t Delta t_t \ntext subject to   quad textoriginal dynamics  constraints \n F_textfinal geq F_textthreshold \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere q represents the quantum state (unitary, ket, or density matrix).\n\nArguments\n\nqcp::QuantumControlProblem: Existing quantum control problem to convert\n\nKeyword Arguments\n\nfinal_fidelity::Float64=0.99: Minimum fidelity constraint at final time\nD::Float64=100.0: Weight on minimum-time objective ‚àëŒît\npiccolo_options::PiccoloOptions=PiccoloOptions(): Piccolo solver options\n\nReturns\n\nQuantumControlProblem: New problem with minimum-time objective and fidelity constraint\n\nExamples\n\n# Standard workflow\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\npulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# Step 1: Create and solve base smooth pulse problem (with Œît_bounds for free time)\nqcp_smooth = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2, Œît_bounds=(0.01, 0.5))\nsolve!(qcp_smooth; max_iter=100)\n\n# Step 2: Convert to minimum-time\nqcp_mintime = MinimumTimeProblem(qcp_smooth; final_fidelity=0.99, D=100.0)\nsolve!(qcp_mintime; max_iter=100)\n\n# Compare durations\nduration_before = sum(get_timesteps(get_trajectory(qcp_smooth)))\nduration_after = sum(get_timesteps(get_trajectory(qcp_mintime)))\n@assert duration_after <= duration_before\n\n# Nested transformations also work\nqcp_final = MinimumTimeProblem(\n    RobustnessProblem(qcp_smooth);  # Future feature\n    final_fidelity=0.95\n)\n\nConvenience Constructors\n\nYou can also update the goal when creating minimum-time problem:\n\n# Different goal for minimum-time optimization\nqcp_mintime = MinimumTimeProblem(qcp_smooth; goal=U_goal_new, final_fidelity=0.98)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.SamplingProblem-Tuple{QuantumControlProblem, Vector{<:AbstractQuantumSystem}}","page":"Library","title":"Piccolo.Control.ProblemTemplates.SamplingProblem","text":"SamplingProblem(qcp::QuantumControlProblem, systems::Vector{<:AbstractQuantumSystem}; kwargs...)\n\nConstruct a SamplingProblem from an existing QuantumControlProblem and a list of systems.\n\nThis creates a robust optimization problem where the controls are shared across all systems, but each system evolves according to its own dynamics. The objective is the weighted sum of fidelity objectives for each system.\n\nArguments\n\nqcp::QuantumControlProblem: The base problem (defines nominal trajectory, objective, etc.)\nsystems::Vector{<:AbstractQuantumSystem}: List of systems to optimize over\n\nKeyword Arguments\n\nweights::Vector{Float64}=fill(1.0, length(systems)): Weights for each system\nQ::Float64=100.0: Weight on infidelity objective (explicit, not extracted from base problem)\npiccolo_options::PiccoloOptions=PiccoloOptions(): Options for the solver\n\nReturns\n\nQuantumControlProblem{SamplingTrajectory}: A new problem with the sampling trajectory\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.SmoothPulseProblem-Tuple{AbstractQuantumTrajectory{<:ZeroOrderPulse}, Int64}","page":"Library","title":"Piccolo.Control.ProblemTemplates.SmoothPulseProblem","text":"SmoothPulseProblem(qtraj::AbstractQuantumTrajectory{<:ZeroOrderPulse}, N::Int; kwargs...)\n\nConstruct a QuantumControlProblem for smooth pulse optimization with piecewise constant controls.\n\nNote: This problem template is for ZeroOrderPulse only. For spline-based pulses (LinearSplinePulse, CubicSplinePulse), use SplinePulseProblem instead.\n\nThe problem adds discrete derivative variables (du, ddu) that:\n\nRegularize control changes between timesteps\nEnforce smoothness via DerivativeIntegrator constraints\n\nArguments\n\nqtraj::AbstractQuantumTrajectory{<:ZeroOrderPulse}: Quantum trajectory with piecewise constant pulse\nN::Int: Number of timesteps for discretization\n\nKeyword Arguments\n\nintegrator::Union{Nothing, AbstractIntegrator, Vector{<:AbstractIntegrator}}=nothing: Optional custom integrator(s). If not provided, uses BilinearIntegrator (which does not support global variables). A custom integrator is required when global_names is specified.\nglobal_names::Union{Nothing, Vector{Symbol}}=nothing: Names of global variables to optimize. Requires a custom integrator (e.g., HermitianExponentialIntegrator from Piccolissimo) that supports global variables.\nglobal_bounds::Union{Nothing, Dict{Symbol, Union{Float64, Tuple{Float64, Float64}}}}=nothing: Bounds for global variables. Keys are variable names, values are either a scalar (symmetric bounds ¬±value) or a tuple (lower, upper).\ndu_bound::Float64=Inf: Bound on discrete first derivative (controls jump rate)\nddu_bound::Float64=1.0: Bound on discrete second derivative (controls acceleration)\nQ::Float64=100.0: Weight on infidelity/objective\nR::Float64=1e-2: Weight on regularization terms (u, uÃá, √º)\nR_u::Union{Float64, Vector{Float64}}=R: Weight on control regularization\nR_du::Union{Float64, Vector{Float64}}=R: Weight on first derivative regularization\nR_ddu::Union{Float64, Vector{Float64}}=R: Weight on second derivative regularization\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: Additional constraints\npiccolo_options::PiccoloOptions=PiccoloOptions(): Piccolo solver options\n\nReturns\n\nQuantumControlProblem: Wrapper containing quantum trajectory and optimization problem\n\nExamples\n\n# Unitary gate synthesis with piecewise constant pulse\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\npulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2)\nsolve!(qcp; max_iter=100)\n\n# Quantum state transfer\npulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))\nqtraj = KetTrajectory(sys, pulse, œà_init, œà_goal)\nqcp = SmoothPulseProblem(qtraj, N; Q=50.0, R=1e-3)\nsolve!(qcp)\n\nSee also: SplinePulseProblem for spline-based pulses.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.SmoothPulseProblem-Tuple{MultiKetTrajectory{<:ZeroOrderPulse}, Int64}","page":"Library","title":"Piccolo.Control.ProblemTemplates.SmoothPulseProblem","text":"SmoothPulseProblem(qtraj::MultiKetTrajectory{<:ZeroOrderPulse}, N::Int; kwargs...)\n\nConstruct a QuantumControlProblem for smooth pulse optimization over an ensemble of ket state transfers with piecewise constant controls.\n\nThis handles the case where you want to optimize a single pulse that achieves multiple  state transfers simultaneously (e.g., |0‚ü©‚Üí|1‚ü© and |1‚ü©‚Üí|0‚ü© for an X gate via state transfer).\n\nNote: This problem template is for ZeroOrderPulse only. For spline-based pulses, use SplinePulseProblem instead.\n\nArguments\n\nqtraj::MultiKetTrajectory{<:ZeroOrderPulse}: Ensemble of ket state transfers with piecewise constant pulse\nN::Int: Number of timesteps for the discretization\n\nKeyword Arguments\n\nintegrator::Union{Nothing, AbstractIntegrator, Vector{<:AbstractIntegrator}}=nothing: Optional custom integrator(s). If not provided, the default BilinearIntegrator is used. When global_names is specified, you must supply a custom integrator here (i.e., do not rely on the default BilinearIntegrator) that supports global variables.\nglobal_names::Union{Nothing, Vector{Symbol}}=nothing: Names of global variables to optimize. Requires a custom integrator provided via integrator (e.g., HermitianExponentialIntegrator from Piccolissimo) that supports global variables.\nglobal_bounds::Union{Nothing, Dict{Symbol, Union{Float64, Tuple{Float64, Float64}}}}=nothing: Bounds for global variables. Keys are variable names, values are either a scalar (symmetric bounds ¬±value) or a tuple (lower, upper).\ndu_bound::Float64=Inf: Bound on discrete first derivative\nddu_bound::Float64=1.0: Bound on discrete second derivative\nQ::Float64=100.0: Weight on infidelity/objective\nR::Float64=1e-2: Weight on regularization terms (u, uÃá, √º)\nR_u::Union{Float64, Vector{Float64}}=R: Weight on control regularization\nR_du::Union{Float64, Vector{Float64}}=R: Weight on first derivative regularization\nR_ddu::Union{Float64, Vector{Float64}}=R: Weight on second derivative regularization\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: Additional constraints\npiccolo_options::PiccoloOptions=PiccoloOptions(): Piccolo solver options\n\nReturns\n\nQuantumControlProblem{MultiKetTrajectory}: Wrapper containing ensemble trajectory and optimization problem\n\nExamples\n\n# Create ensemble for X gate via state transfer\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\npulse = ZeroOrderPulse(0.1 * randn(n_drives, N), collect(range(0.0, T, length=N)))\n\nœà0 = ComplexF64[1.0, 0.0]\nœà1 = ComplexF64[0.0, 1.0]\n\nensemble_qtraj = MultiKetTrajectory(sys, pulse, [œà0, œà1], [œà1, œà0])\nqcp = SmoothPulseProblem(ensemble_qtraj, N; Q=100.0, R=1e-2)\nsolve!(qcp; max_iter=100)\n\nSee also: SplinePulseProblem for spline-based pulses.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.SmoothPulseProblem-Union{Tuple{P}, Tuple{AbstractQuantumTrajectory{P}, Int64}} where P<:AbstractPulse","page":"Library","title":"Piccolo.Control.ProblemTemplates.SmoothPulseProblem","text":"SmoothPulseProblem(qtraj::AbstractQuantumTrajectory, N::Int; kwargs...)\n\nFallback method that provides helpful error for non-ZeroOrderPulse types.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.SplinePulseProblem","page":"Library","title":"Piccolo.Control.ProblemTemplates.SplinePulseProblem","text":"SplinePulseProblem(qtraj::MultiKetTrajectory{<:AbstractSplinePulse}; kwargs...)\nSplinePulseProblem(qtraj::MultiKetTrajectory{<:AbstractSplinePulse}, N::Int; kwargs...)\nSplinePulseProblem(qtraj::MultiKetTrajectory{<:AbstractSplinePulse}, times::AbstractVector; kwargs...)\n\nCreate a spline-based trajectory optimization problem for ensemble ket state transfers.\n\nUses coherent fidelity objective (phases must align) for gate implementation.\n\nArguments\n\nqtraj::MultiKetTrajectory{<:AbstractSplinePulse}: Ensemble trajectory with spline pulse\nN_or_times: One of:\nnothing (default): Use native knot times from spline pulse\nN::Int: Number of uniformly spaced timesteps\ntimes::AbstractVector: Specific sample times\n\nKeyword Arguments\n\nSame as the base SplinePulseProblem method.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Control.ProblemTemplates.SplinePulseProblem-2","page":"Library","title":"Piccolo.Control.ProblemTemplates.SplinePulseProblem","text":"SplinePulseProblem(qtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}; kwargs...)\nSplinePulseProblem(qtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}, N::Int; kwargs...)\nSplinePulseProblem(qtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}, times::AbstractVector; kwargs...)\n\nConstruct a QuantumControlProblem for spline-based pulse optimization.\n\nUnlike SmoothPulseProblem (which uses piecewise constant controls with discrete smoothing  variables), this problem template is designed for spline-based pulses where the derivative  variables (du) are the actual spline coefficients or slopes.\n\nPulse Type Semantics\n\nLinearSplinePulse: The du variable represents the slope between knots. A DerivativeIntegrator constraint enforces du[k] = (u[k+1] - u[k]) / Œît, making the slopes consistent with the linear interpolation. This constraint ensures mathematical rigor while allowing slope regularization/bounds.\n\nCubicSplinePulse (Hermite spline): The du variable is the tangent/derivative at each  knot point, which is a true independent degree of freedom in Hermite interpolation. No  DerivativeIntegrator is added - the optimizer can adjust both :u and :du independently.\n\nMathematical Notes\n\nLinearSplinePulse: Always adds :du and DerivativeIntegrator to enforce slope consistency\nCubicSplinePulse: :du values are Hermite tangents (unconstrained, only regularized)\n\nBoth pulse types always have :du components in the trajectory, simplifying integrator implementations.\n\nArguments\n\nqtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}: Quantum trajectory with spline pulse\nN_or_times: One of:\nnothing (default): Use native knot times from spline pulse (ideal for warm-starting)\nN::Int: Number of uniformly spaced timesteps\ntimes::AbstractVector: Specific sample times\n\nKeyword Arguments\n\nintegrator::Union{Nothing, AbstractIntegrator, Vector{<:AbstractIntegrator}}=nothing: Optional custom integrator(s). If not provided, uses BilinearIntegrator (which does not support global variables). A custom integrator is required when global_names is specified.\nglobal_names::Union{Nothing, Vector{Symbol}}=nothing: Names of global variables to optimize. Requires a custom integrator (e.g., SplineIntegrator from Piccolissimo) that supports global variables.\nglobal_bounds::Union{Nothing, Dict{Symbol, Union{Float64, Tuple{Float64, Float64}}}}=nothing: Bounds for global variables. Keys are variable names, values are either a scalar (symmetric bounds ¬±value) or a tuple (lower, upper).\ndu_bound::Float64=Inf: Bound on derivative (slope) magnitude\nQ::Float64=100.0: Weight on infidelity/objective\nR::Float64=1e-2: Weight on regularization terms\nR_u::Union{Float64, Vector{Float64}}=R: Weight on control regularization\nR_du::Union{Float64, Vector{Float64}}=R: Weight on derivative regularization  \nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: Additional constraints\npiccolo_options::PiccoloOptions=PiccoloOptions(): Piccolo solver options\n\nReturns\n\nQuantumControlProblem{<:AbstractQuantumTrajectory}: Wrapper containing trajectory and optimization problem\n\nExamples\n\n# Create system and initial pulse\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\npulse = CubicSplinePulse(u_init, du_init, times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# Use native knot structure (best for warm-starting from saved pulse)\nqcp = SplinePulseProblem(qtraj; Q=100.0, du_bound=10.0)\n\n# Or resample to different number of knots\nqcp = SplinePulseProblem(qtraj, 50; Q=100.0, du_bound=10.0)\n\nsolve!(qcp; max_iter=100)\n\nSee also: SmoothPulseProblem for piecewise constant pulses with discrete smoothing.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Piccolo.Control.ProblemTemplates.SplinePulseProblem-Union{Tuple{AbstractQuantumTrajectory{P}}, Tuple{P}, Tuple{AbstractQuantumTrajectory{P}, Union{Nothing, Int64, AbstractVector{<:Real}}}} where P<:AbstractPulse","page":"Library","title":"Piccolo.Control.ProblemTemplates.SplinePulseProblem","text":"SplinePulseProblem(qtraj::AbstractQuantumTrajectory, N_or_times; kwargs...)\n\nFallback method that provides helpful error for non-spline pulse types.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates._ensemble_ket_objective-Tuple{MultiKetTrajectory, NamedTrajectory, Vector{Symbol}, Vector{Float64}, Vector, Float64}","page":"Library","title":"Piccolo.Control.ProblemTemplates._ensemble_ket_objective","text":"_ensemble_ket_objective(qtraj::MultiKetTrajectory, traj, state_names, weights, goals, Q)\n\nCreate a coherent fidelity objective for ensemble state transfers.\n\nFor ensemble trajectories (implementing a gate via multiple state transfers), we use coherent fidelity:     Fcoherent = |1/n ‚àë·µ¢ ‚ü®œà·µ¢goal|œà·µ¢‚ü©|¬≤\n\nThis requires all state overlaps to have aligned phases, which is essential for gate implementation (the gate should have a single global phase).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates._final_fidelity_constraint-Tuple{MultiKetTrajectory, Float64, NamedTrajectory}","page":"Library","title":"Piccolo.Control.ProblemTemplates._final_fidelity_constraint","text":"_final_fidelity_constraint(qtraj::MultiKetTrajectory, final_fidelity, traj)\n\nCreate a coherent fidelity constraint for an MultiKetTrajectory.\n\nUses coherent fidelity: F = |1/n ‚àë·µ¢ ‚ü®œà·µ¢_goal|œà·µ¢‚ü©|¬≤\n\nThis enforces that all state transfers have aligned global phases, which is  essential when implementing a gate via state transfer (e.g., X gate via  |0‚ü©‚Üí|1‚ü© and |1‚ü©‚Üí|0‚ü©).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.add_global_bounds_constraints!-Tuple{AbstractVector{<:AbstractConstraint}, Any, NamedTrajectory}","page":"Library","title":"Piccolo.Control.ProblemTemplates.add_global_bounds_constraints!","text":"add_global_bounds_constraints!(constraints, global_bounds, traj; verbose=false)\n\nAdd GlobalBoundsConstraint entries for each global variable specified in global_bounds.\n\nConverts bounds from user-friendly formats to the format expected by GlobalBoundsConstraint:\n\nFloat64: Symmetric scalar bounds (applied symmetrically to all dimensions)\nTuple{Float64, Float64}: Asymmetric scalar bounds (expanded to vectors)\nVector or Tuple{Vector, Vector}: Already in correct format (passed through)\n\nModifies constraints in place.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.extract_regularization-Tuple{Any, Symbol, NamedTrajectory}","page":"Library","title":"Piccolo.Control.ProblemTemplates.extract_regularization","text":"extract_regularization(objective, state_sym::Symbol, new_traj::NamedTrajectory) -> AbstractObjective\n\nExtract regularization terms (non-state-dependent objectives) from a composite objective, filtering to only include terms for variables that exist in the new trajectory.\n\nUsed by SamplingProblem to extract shared regularizers (e.g., control penalty) from the base problem while excluding regularizers for variables that don't exist in the sampling trajectory (e.g., :du, :ddu which are added by SmoothPulseProblem).\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.ProblemTemplates.sampling_state_objective-Tuple{UnitaryTrajectory, NamedTrajectory, Symbol, Float64}","page":"Library","title":"Piccolo.Control.ProblemTemplates.sampling_state_objective","text":"sampling_state_objective(qtraj, traj, state_sym, Q)\n\nCreate the state-dependent objective for a sampling member. Dispatches on quantum trajectory type.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumObjectives.CoherentKetInfidelityObjective-Tuple{Vector{<:AbstractVector{<:Complex}}, Vector{Symbol}, NamedTrajectory}","page":"Library","title":"Piccolo.Control.QuantumObjectives.CoherentKetInfidelityObjective","text":"CoherentKetInfidelityObjective(œà_goals, œàÃÉ_names, traj; Q=100.0)\n\nCreate a terminal objective for coherent ket state infidelity across multiple states.\n\nCoherent fidelity is defined as:     Fcoherent = |1/n ‚àë·µ¢ ‚ü®œà·µ¢goal|œà·µ¢‚ü©|¬≤\n\nUnlike incoherent fidelity (average of individual |‚ü®œà·µ¢_goal|œà·µ¢‚ü©|¬≤), coherent fidelity  requires all state overlaps to have aligned phases. This is essential when implementing a gate via multiple state transfers - the gate should have a single global phase, not independent phases per state.\n\nArguments\n\nœà_goals::Vector{<:AbstractVector{<:Complex}}: Target ket states\nœàÃÉ_names::Vector{Symbol}: Names of isomorphic state variables in trajectory\ntraj::NamedTrajectory: The trajectory\n\nKeyword Arguments\n\nQ::Float64=100.0: Weight on the infidelity objective\n\nExample\n\n# For implementing X gate via |0‚ü©‚Üí|1‚ü© and |1‚ü©‚Üí|0‚ü©\ngoals = [ComplexF64[0, 1], ComplexF64[1, 0]]\nnames = [:œàÃÉ1, :œàÃÉ2]\nobj = CoherentKetInfidelityObjective(goals, names, traj; Q=100.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumObjectives.KetInfidelityObjective-Tuple{AbstractVector{<:Complex}, Symbol, NamedTrajectory}","page":"Library","title":"Piccolo.Control.QuantumObjectives.KetInfidelityObjective","text":"KetInfidelityObjective(œà_goal, œàÃÉ_name, traj; Q=100.0)\n\nCreate a terminal objective for ket state infidelity with an explicit goal state.\n\nThis variant is useful for SamplingProblem and EnsembleTrajectory where the goal is shared across multiple state variables that don't have individual goals in traj.goal.\n\nArguments\n\nœà_goal::AbstractVector{<:Complex}: The target ket state (complex vector)\nœàÃÉ_name::Symbol: Name of the isomorphic state variable in the trajectory\ntraj::NamedTrajectory: The trajectory\n\nKeyword Arguments\n\nQ::Float64=100.0: Weight on the infidelity objective\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumObjectives.KetInfidelityObjective-Tuple{Symbol, NamedTrajectory}","page":"Library","title":"Piccolo.Control.QuantumObjectives.KetInfidelityObjective","text":"KetInfidelityObjective(œàÃÉ_name, traj; Q=100.0)\n\nCreate a terminal objective for ket state infidelity, using the goal from traj.goal[œàÃÉ_name].\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumObjectives.LeakageObjective-Tuple{AbstractVector{Int64}, Symbol, NamedTrajectory}","page":"Library","title":"Piccolo.Control.QuantumObjectives.LeakageObjective","text":"LeakageObjective(indices, name, traj::NamedTrajectory)\n\nConstruct a KnotPointObjective that penalizes leakage of name at the knot points specified by times at any indices that are outside the computational subspace.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumObjectives.coherent_ket_fidelity-Tuple{Any, Vector{<:AbstractVector{<:ComplexF64}}}","page":"Library","title":"Piccolo.Control.QuantumObjectives.coherent_ket_fidelity","text":"coherent_ket_fidelity(œàÃÉs, œà_goals)\n\nCompute coherent fidelity across multiple ket states:\n\nF_coherent = |1/n ‚àë·µ¢ ‚ü®œà·µ¢_goal|œà·µ¢‚ü©|¬≤\n\nThis requires all overlaps to have consistent phases (global phase alignment), which is necessary for implementing gates via state transfer.\n\nArguments\n\nœàÃÉs::Vector{<:AbstractVector}: List of isomorphic state vectors\nœà_goals::Vector{<:AbstractVector{<:Complex}}: List of goal states\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumConstraints.FinalCoherentKetFidelityConstraint-Tuple{Vector{<:AbstractVector{<:Complex}}, Vector{Symbol}, Float64, NamedTrajectory}","page":"Library","title":"Piccolo.Control.QuantumConstraints.FinalCoherentKetFidelityConstraint","text":"FinalCoherentKetFidelityConstraint(œà_goals, œàÃÉ_names, final_fidelity, traj)\n\nCreate a final fidelity constraint using coherent ket fidelity across multiple states.\n\nCoherent fidelity: F = |1/n ‚àë·µ¢ ‚ü®œà·µ¢_goal|œà·µ¢‚ü©|¬≤\n\nThis constraint enforces that all state overlaps have aligned phases, which is  essential when implementing a gate via multiple state transfers (e.g., MultiKetTrajectory).\n\nArguments\n\nœà_goals::Vector{<:AbstractVector{<:Complex}}: Target ket states\nœàÃÉ_names::Vector{Symbol}: Names of isomorphic state variables in trajectory\nfinal_fidelity::Float64: Minimum fidelity threshold (constraint: F ‚â• final_fidelity)\ntraj::NamedTrajectory: The trajectory\n\nExample\n\n# For implementing X gate via |0‚ü©‚Üí|1‚ü© and |1‚ü©‚Üí|0‚ü©\ngoals = [ComplexF64[0, 1], ComplexF64[1, 0]]\nnames = [:œàÃÉ1, :œàÃÉ2]\nconstraint = FinalCoherentKetFidelityConstraint(goals, names, 0.99, traj)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.QuantumConstraints.LeakageConstraint-Tuple{Float64, AbstractVector{Int64}, Symbol, NamedTrajectory}","page":"Library","title":"Piccolo.Control.QuantumConstraints.LeakageConstraint","text":"LeakageConstraint(value, indices, name, traj::NamedTrajectory)\n\nConstruct a KnotPointConstraint that bounds leakage of name at the knot points specified by times at any indices that are outside the computational subspace.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Control.Options.PiccoloOptions","page":"Library","title":"Piccolo.Control.Options.PiccoloOptions","text":"PiccoloOptions\n\nOptions for the Piccolo quantum optimal control library.\n\nFields\n\nverbose::Bool = true: Print verbose output\ntimesteps_all_equal::Bool = true: Use equal timesteps\nrollout_integrator::Function = expv: Integrator to use for rollout\ngeodesic = true: Use the geodesic to initialize the optimization.\nzero_initial_and_final_derivative::Bool=false: Zero the initial and final control pulse derivatives.\ncomplex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing: Name of the complex control norm constraint.\ncomplex_control_norm_constraint_radius::Float64 = 1.0: Radius of the complex control norm constraint.\nbound_state::Bool = false: Bound the state variables <= 1.0.\nleakage_constraint::Bool = false: Suppress leakage with constraint and cost.\nleakage_constraint_value::Float64 = 1e-2: Value for the leakage constraint.\nleakage_cost::Float64 = 1e-2: Leakage suppression parameter.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Piccolo.Visualizations.QuantumObjectPlots.plot_state_populations-Tuple{NamedTrajectory}","page":"Library","title":"Piccolo.Visualizations.QuantumObjectPlots.plot_state_populations","text":"plot_state_populations(\n    traj::NamedTrajectory;\n    state_name::Symbol=:œàÃÉ,\n    state_indices::Union{Nothing, AbstractVector{Int}}=nothing,\n    control_name::Symbol=:u,\n    subspace::Union{Nothing, AbstractVector{Int}}=nothing,\n    kwargs...\n)\n\nPlot populations for multiple quantum states stored in a trajectory.\n\nThis function visualizes the time evolution of quantum state populations for trajectories containing multiple state trajectories (e.g., from sampling problems where multiple initial states are evolved). States are identified by a common prefix and numeric suffix pattern (e.g., :œàÃÉ1_system_1, :œàÃÉ2_system_1, etc.).\n\nMathematical Background\n\nFor a quantum state psi(t)rangle in mathcalH evolving under the Schr√∂dinger equation, the population in computational basis state irangle is given by\n\nP_i(t) = langle ipsi(t)rangle^2 = psi_i(t)^2\n\nwhere psi_i(t) is the i-th component of the state vector in the computational basis.\n\nFor a normalized state, we have the conservation property:\n\nsum_i=1^n P_i(t) = langlepsi(t)psi(t)rangle = 1\n\nWhen multiple states are being optimized simultaneously (as in sampling problems), this function plots the populations for each state, allowing comparison of how different initial conditions evolve under the same control protocol.\n\nKey Properties:\n\nPopulations are real and bounded: P_i(t) in 01\nTotal probability is conserved: sum_i P_i(t) = 1\nCan optionally restrict to a subspace (e.g., computational subspace excluding leakage states)\n\nArguments\n\ntraj::NamedTrajectory: A trajectory containing one or more quantum states in isomorphism representation.\n\nKeyword Arguments\n\nstate_name::Symbol: The base name for state components. The function will find all trajectory components matching this prefix (e.g., :œàÃÉ matches :œàÃÉ1_system_1, :œàÃÉ2_system_1, etc.). Default is :œàÃÉ.\nstate_indices::Union{Nothing, AbstractVector{Int}}: If provided, only plot states with these indices (e.g., [1, 3] plots only the 1st and 3rd states). If nothing, plots all states matching the prefix. Default is nothing.\ncontrol_name::Symbol: The name of the control signal component to include in the plot. Default is :u.\nsubspace::Union{Nothing, AbstractVector{Int}}: If provided, only plot populations for these basis states (e.g., 1:2 for a qubit subspace). Useful for excluding leakage levels. Default is nothing (plot all levels).\nkwargs...: Additional keyword arguments passed to NamedTrajectories.plot.\n\nReturns\n\nA Makie Figure object containing the population plots for all selected states.\n\nExample\n\nusing NamedTrajectories\nusing Piccolo\nusing Piccolo\n\n# Example: Two initial states evolving under the same controls\nN = 100\nŒît = 0.1\n\n# Initial states\nœà1_init = ComplexF64[1, 0, 0]  # |0‚ü©\nœà2_init = ComplexF64[0, 1, 0]  # |1‚ü©\n\n# Create trajectory with multiple states\ntraj = NamedTrajectory(\n    (\n        œàÃÉ1_system_1 = hcat([ket_to_iso(œà1_init) for _ in 1:N]...),\n        œàÃÉ2_system_1 = hcat([ket_to_iso(œà2_init) for _ in 1:N]...),\n        u = randn(2, N),\n        Œît = fill(Œît, N),\n    );\n    controls = :u,\n    timestep = :Œît,\n)\n\n# Plot populations for all states\nplot_state_populations(traj)\n\n# Plot only computational subspace (excluding 3rd level)\nplot_state_populations(traj; subspace=1:2)\n\n# Plot only first state\nplot_state_populations(traj; state_indices=[1])\n\nSee also: plot_unitary_populations, NamedTrajectories.plot\n\n\n\n\n\n","category":"method"},{"location":"lib/#Piccolo.Visualizations.QuantumObjectPlots.plot_unitary_populations-Tuple{NamedTrajectory}","page":"Library","title":"Piccolo.Visualizations.QuantumObjectPlots.plot_unitary_populations","text":"plot_unitary_populations(\n    traj::NamedTrajectory;\n    unitary_columns::AbstractVector{Int}=1:2,\n    unitary_name::Symbol=:≈®‚Éó,\n    control_name::Symbol=:u,\n    kwargs...\n)\n\nPlot the state populations for specified columns of a unitary operator trajectory.\n\nThis function visualizes how the populations (squared magnitudes) of quantum states evolve over time for selected columns of a unitary matrix stored in a NamedTrajectory.\n\nMathematical Background\n\nFor a unitary operator U(t) in mathcalU(n) evolving under a time-dependent Hamiltonian, this function plots the populations\n\nP_ij(t) = U_ij(t)^2\n\nwhere U_ij(t) is the (ij)-th element of the unitary matrix at time t.\n\nFor a quantum system evolving according to the Schr√∂dinger equation\n\nfracddtU(t) = -iH(t)U(t) quad U(0) = I\n\neach column j of U(t) represents the time evolution of the initial basis state jrangle:\n\npsi_j(t)rangle = U(t)jrangle = sum_i=1^n U_ij(t)irangle\n\nThe population P_ij(t) = U_ij(t)^2 gives the probability of finding the system in state irangle at time t given that it started in state jrangle.\n\nKey Properties:\n\nUnitarity ensures sum_i=1^n P_ij(t) = 1 for all j and t (probability conservation)\nP_ij(0) = delta_ij (initially in definite state)\nPopulations are real and bounded: P_ij(t) in 01\n\nThe trajectory stores U(t) in isomorphism representation tildeU(t), a vectorized form that preserves the operator structure while enabling efficient optimization algorithms.\n\nArguments\n\ntraj::NamedTrajectory: A trajectory containing a unitary operator in isomorphism representation.\n\nKeyword Arguments\n\nunitary_columns::AbstractVector{Int}: Indices of unitary matrix columns to plot. Each column j corresponds to the evolution of basis state jrangle. Default is 1:2.\nunitary_name::Symbol: The name of the unitary operator component in the trajectory, stored as an isomorphism vector (tildeU). Default is :≈®‚Éó.\ncontrol_name::Symbol: The name of the control signal component to include in the plot, typically the time-dependent control parameters u(t) in H(t) = H_0 + sum_k u_k(t) H_k. Default is :u.\nkwargs...: Additional keyword arguments passed to NamedTrajectories.plot, such as xlims, ylims, or Makie-specific plotting options.\n\nReturns\n\nA Makie Figure object containing the population plots.\n\nExample\n\nusing NamedTrajectories\nusing Piccolo\nusing Piccolo\n\n# Define Hamiltonian: H = X + a‚ÇÅ(t)Z + a‚ÇÇ(t)Y\nH_drift = PAULIS[:X]\nH_drives = [PAULIS[:Z], PAULIS[:Y]]\n\n# Generate control trajectory\nN = 100\nŒît = 0.1\nts = collect(0:Œît:Œît*(N-1))\nu = 0.1 * randn(2, length(ts))\n\n# Generate unitaries\nUs = exp.(-im * [(H_drift + sum(u[:, k] .* H_drives)) * ts[k] for k = 1:N])\n\n# Create trajectory\ntraj = NamedTrajectory(\n    (\n        ≈®‚Éó = hcat(operator_to_iso_vec.(Us)...),\n        u = u,\n        Œît = ts,\n    );\n    controls = :u,\n    timestep = :Œît,\n)\n\n# Plot populations for first two columns\nplot_unitary_populations(traj)\n\n# Plot only the first column\nplot_unitary_populations(traj; unitary_columns=[1])\n\nSee also: NamedTrajectories.plot\n\n\n\n\n\n","category":"method"},{"location":"generated/robust_control/#robust-control-tutorial","page":"Robust Control","title":"Robust Control","text":"This tutorial shows how to design control pulses that are robust to parameter uncertainty using SamplingProblem.","category":"section"},{"location":"generated/robust_control/#The-Problem","page":"Robust Control","title":"The Problem","text":"Real quantum systems have parameter uncertainty:\n\nQubit frequencies drift over time\nFabrication variations between devices\nCalibration errors\n\nA pulse optimized for nominal parameters may perform poorly when parameters vary. SamplingProblem optimizes for multiple parameter values simultaneously.\n\nusing Piccolo\nusing CairoMakie\nusing Random\nRandom.seed!(456)","category":"section"},{"location":"generated/robust_control/#Setup:-Nominal-System","page":"Robust Control","title":"Setup: Nominal System","text":"# Nominal qubit frequency\nœâ_nominal = 0.5\n\nH_drift = œâ_nominal * PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\ndrive_bounds = [1.0, 1.0]\n\nsys_nominal = QuantumSystem(H_drift, H_drives, drive_bounds)\n\n# Time parameters\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\n\n# Target gate\nU_goal = GATES[:X]","category":"section"},{"location":"generated/robust_control/#Step-1:-Optimize-for-Nominal-Parameters-Only","page":"Robust Control","title":"Step 1: Optimize for Nominal Parameters Only","text":"pulse_nom = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj_nom = UnitaryTrajectory(sys_nominal, pulse_nom, U_goal)\n\nqcp_nom = SmoothPulseProblem(qtraj_nom, N; Q = 100.0, R = 1e-2)\ncached_solve!(qcp_nom, \"robust_nominal\"; max_iter = 20, verbose = false, print_level = 1)\n\nfidelity(qcp_nom)","category":"section"},{"location":"generated/robust_control/#Step-2:-Test-Robustness","page":"Robust Control","title":"Step 2: Test Robustness","text":"Let's see how this pulse performs with ¬±10% frequency variation:\n\nfunction evaluate_fidelity(qcp, œâ_test)\n    # Create test system with different frequency\n    H_test = œâ_test * PAULIS[:Z]\n    sys_test = QuantumSystem(H_test, H_drives, drive_bounds)\n\n    # Get optimized pulse\n    pulse_opt = get_pulse(qcp.qtraj)\n\n    # Create trajectory and evaluate\n    qtraj_test = UnitaryTrajectory(sys_test, pulse_opt, U_goal)\n    return fidelity(qtraj_test)\nend\n\n# Test across frequency range\nœâ_range = range(0.9 * œâ_nominal, 1.1 * œâ_nominal, length = 21)\nfidelities_nom = [evaluate_fidelity(qcp_nom, œâ) for œâ in œâ_range]\n\nextrema(fidelities_nom)","category":"section"},{"location":"generated/robust_control/#Step-3:-Robust-Optimization-with-SamplingProblem","page":"Robust Control","title":"Step 3: Robust Optimization with SamplingProblem","text":"Now let's optimize for multiple frequency values simultaneously.\n\n# Create perturbed systems (¬±5% and ¬±10%)\nœâ_samples = [0.9, 0.95, 1.0, 1.05, 1.1] .* œâ_nominal\nsystems = [QuantumSystem(œâ * PAULIS[:Z], H_drives, drive_bounds) for œâ in œâ_samples]\n\n# Optimize for all frequency samples\n\n# Start from the nominal solution\nqcp_robust = SamplingProblem(qcp_nom, systems; Q = 100.0)\ncached_solve!(\n    qcp_robust,\n    \"robust_sampling\";\n    max_iter = 20,\n    verbose = false,\n    print_level = 1,\n)\n\nfidelity(qcp_robust)","category":"section"},{"location":"generated/robust_control/#Step-4:-Compare-Performance","page":"Robust Control","title":"Step 4: Compare Performance","text":"# Evaluate robust pulse\nfidelities_robust = Float64[]\nfor œâ in œâ_range\n    H_test = œâ * PAULIS[:Z]\n    sys_test = QuantumSystem(H_test, H_drives, drive_bounds)\n    pulse_robust = get_pulse(qcp_robust.qtraj)\n    qtraj_test = UnitaryTrajectory(sys_test, pulse_robust, U_goal)\n    push!(fidelities_robust, fidelity(qtraj_test))\nend\n\nextrema(fidelities_robust)","category":"section"},{"location":"generated/robust_control/#Step-5:-Visualize-Comparison","page":"Robust Control","title":"Step 5: Visualize Comparison","text":"fig = Figure(size = (800, 400))\n\nax = Axis(\n    fig[1, 1],\n    xlabel = \"Frequency (œâ/œâ_nominal)\",\n    ylabel = \"Fidelity\",\n    title = \"Robustness Comparison\",\n)\n\nlines!(\n    ax,\n    œâ_range ./ œâ_nominal,\n    fidelities_nom,\n    label = \"Nominal-only\",\n    linewidth = 2,\n    color = :blue,\n)\nlines!(\n    ax,\n    œâ_range ./ œâ_nominal,\n    fidelities_robust,\n    label = \"Robust\",\n    linewidth = 2,\n    color = :red,\n)\n\nhlines!(ax, [0.99], linestyle = :dash, color = :gray, label = \"99% threshold\")\n\naxislegend(ax, position = :lb)\n\nfig","category":"section"},{"location":"generated/robust_control/#Step-6:-Combine-with-Time-Optimization","page":"Robust Control","title":"Step 6: Combine with Time Optimization","text":"We can chain SamplingProblem with MinimumTimeProblem for robust AND time-optimal pulses.\n\n# First, create base problem with free time\npulse_free = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj_free = UnitaryTrajectory(sys_nominal, pulse_free, U_goal)\n\nqcp_free = SmoothPulseProblem(\n    qtraj_free,\n    N;\n    Q = 100.0,\n    R = 1e-2,\n    Œît_bounds = (0.05, 0.3),  # Enable variable timesteps\n)\ncached_solve!(qcp_free, \"robust_free_time\"; max_iter = 15, verbose = false, print_level = 1)\n\n# Add robustness\nqcp_robust_free = SamplingProblem(qcp_free, systems; Q = 100.0)\ncached_solve!(\n    qcp_robust_free,\n    \"robust_free_sampling\";\n    max_iter = 15,\n    verbose = false,\n    print_level = 1,\n)\n\n# Minimize time while maintaining fidelity\nqcp_fast_robust = MinimumTimeProblem(qcp_robust_free; final_fidelity = 0.95, D = 100.0)\ncached_solve!(\n    qcp_fast_robust,\n    \"robust_fast_mintime\";\n    max_iter = 15,\n    verbose = false,\n    print_level = 1,\n)\n\n# Compare durations\nduration_initial = sum(get_timesteps(get_trajectory(qcp_free)))\nduration_robust = sum(get_timesteps(get_trajectory(qcp_robust_free)))\nduration_fast = sum(get_timesteps(get_trajectory(qcp_fast_robust)))\n\nduration_initial, duration_robust, duration_fast","category":"section"},{"location":"generated/robust_control/#Weighted-Sampling","page":"Robust Control","title":"Weighted Sampling","text":"You can weight some parameter values more heavily:\n\n# More weight on nominal, less on extremes\nweights = [0.5, 1.0, 2.0, 1.0, 0.5]  # Emphasize nominal\n\nqcp_weighted = SamplingProblem(qcp_nom, systems; weights = weights, Q = 100.0)\ncached_solve!(\n    qcp_weighted,\n    \"robust_weighted\";\n    max_iter = 15,\n    verbose = false,\n    print_level = 1,\n)\n\n# Evaluate\nfidelities_weighted = Float64[]\nfor œâ in œâ_range\n    H_test = œâ * PAULIS[:Z]\n    sys_test = QuantumSystem(H_test, H_drives, drive_bounds)\n    pulse_w = get_pulse(qcp_weighted.qtraj)\n    qtraj_test = UnitaryTrajectory(sys_test, pulse_w, U_goal)\n    push!(fidelities_weighted, fidelity(qtraj_test))\nend\n\nextrema(fidelities_weighted)","category":"section"},{"location":"generated/robust_control/#Best-Practices","page":"Robust Control","title":"Best Practices","text":"Start with nominal optimization - Get a working solution first\nSample key parameters - Focus on parameters with most uncertainty\nUse 3-5 samples initially - More samples = slower optimization\nVerify with dense evaluation - Test on more points than you optimized for\nBalance robustness and performance - More robust often means longer gates","category":"section"},{"location":"generated/robust_control/#Next-Steps","page":"Robust Control","title":"Next Steps","text":"Problem Templates: Full SamplingProblem documentation\nMinimumTimeProblem: Time optimization details\nComposing Templates: Advanced composition patterns\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/guides/leakage_suppression/#leakage-suppression","page":"Leakage Suppression","title":"Leakage Suppression","text":"When working with multilevel quantum systems (like transmons), population can \"leak\" from the computational subspace to higher energy levels. This guide shows how to suppress leakage in Piccolo.jl.","category":"section"},{"location":"generated/guides/leakage_suppression/#The-Problem","page":"Leakage Suppression","title":"The Problem","text":"Consider a 3-level transmon where we want to implement gates only on the |0‚ü© and |1‚ü© states. During optimization, population might temporarily occupy |2‚ü©, which can:\n\nReduce gate fidelity\nCause errors in subsequent operations\nLead to non-unitary dynamics if |2‚ü© decays","category":"section"},{"location":"generated/guides/leakage_suppression/#EmbeddedOperator","page":"Leakage Suppression","title":"EmbeddedOperator","text":"The key tool for handling subspace gates is EmbeddedOperator. It creates a full unitary that acts as the specified gate on the computational subspace and as identity on leakage levels.\n\nFor a 3-level system with 2-level computational subspace:\n\nU_textembedded = beginpmatrix U_textgate  0  0  I endpmatrix","category":"section"},{"location":"generated/guides/leakage_suppression/#Basic-Usage","page":"Leakage Suppression","title":"Basic Usage","text":"using Piccolo\nusing Random\nRandom.seed!(42)\n\n# Create a 3-level transmon\nsys = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.4, 0.4])\n\n# Define X gate in computational subspace\nU_goal = EmbeddedOperator(:X, sys)\n\nsize(U_goal.operator)\n\nU_goal.subspace","category":"section"},{"location":"generated/guides/leakage_suppression/#Construction-Options","page":"Leakage Suppression","title":"Construction Options","text":"# From symbol (gate name)\nU_X = EmbeddedOperator(:X, sys)\nU_H = EmbeddedOperator(:H, sys)\n\n# From matrix\ncustom_gate = ComplexF64[1 0; 0 exp(im * œÄ / 4)]  # T gate\nU_T = EmbeddedOperator(custom_gate, sys)","category":"section"},{"location":"generated/guides/leakage_suppression/#Accessing-Subspace-Information","page":"Leakage Suppression","title":"Accessing Subspace Information","text":"# Computational subspace indices\nU_goal.subspace\n\n# Leakage indices in isomorphic vector space\nleak_indices = get_iso_vec_leakage_indices(U_goal)\nleak_indices","category":"section"},{"location":"generated/guides/leakage_suppression/#Leakage-via-PiccoloOptions","page":"Leakage Suppression","title":"Leakage via PiccoloOptions","text":"The easiest way to add leakage handling is through PiccoloOptions.","category":"section"},{"location":"generated/guides/leakage_suppression/#Add-Leakage-Objective","page":"Leakage Suppression","title":"Add Leakage Objective","text":"Penalize population in leakage states with a soft cost:\n\nopts_cost = PiccoloOptions(\n    leakage_cost = 10.0,  # Weight on leakage penalty\n    verbose = false,\n)","category":"section"},{"location":"generated/guides/leakage_suppression/#Add-Leakage-Constraint","page":"Leakage Suppression","title":"Add Leakage Constraint","text":"Enforce a hard bound on leakage:\n\nopts_constraint = PiccoloOptions(\n    leakage_constraint = true,\n    leakage_constraint_value = 1e-3,  # Max 0.1% leakage\n    verbose = false,\n)","category":"section"},{"location":"generated/guides/leakage_suppression/#Both-Together","page":"Leakage Suppression","title":"Both Together","text":"opts = PiccoloOptions(\n    leakage_cost = 10.0,\n    leakage_constraint = true,\n    leakage_constraint_value = 1e-3,\n    verbose = false,\n)","category":"section"},{"location":"generated/guides/leakage_suppression/#Complete-Example:-X-Gate-on-3-Level-Transmon","page":"Leakage Suppression","title":"Complete Example: X Gate on 3-Level Transmon","text":"# 1. Create multilevel system\nsys = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.4, 0.4])\n\n# 2. Define embedded gate\nU_goal = EmbeddedOperator(:X, sys)\n\n# 3. Create trajectory\nT, N = 20.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.05 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# 4. Configure leakage suppression\nopts = PiccoloOptions(\n    leakage_cost = 5.0,\n    leakage_constraint = true,\n    leakage_constraint_value = 1e-3,\n    verbose = false,\n)\n\n# 5. Solve\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0, piccolo_options = opts)\ncached_solve!(\n    qcp,\n    \"leakage_suppression_2\";\n    max_iter = 150,\n    verbose = false,\n    print_level = 1,\n)\n\nfidelity(qcp)","category":"section"},{"location":"generated/guides/leakage_suppression/#Manual-Leakage-Objectives-and-Constraints","page":"Leakage Suppression","title":"Manual Leakage Objectives and Constraints","text":"For more control, add leakage handling manually using LeakageObjective and LeakageConstraint. Both take the leakage indices in the isomorphic vector space:\n\ntraj = get_trajectory(qcp)\nleak_indices = get_iso_vec_leakage_indices(U_goal)\n\n# Leakage objective (soft penalty)\nleak_obj = LeakageObjective(leak_indices, :≈®‚Éó, traj; Qs = fill(10.0, N))\n\n# Leakage constraint (hard bound)\nleak_constraint = LeakageConstraint(1e-3, leak_indices, :≈®‚Éó, traj)","category":"section"},{"location":"generated/guides/leakage_suppression/#Strategies-for-Difficult-Problems","page":"Leakage Suppression","title":"Strategies for Difficult Problems","text":"","category":"section"},{"location":"generated/guides/leakage_suppression/#1.-Start-Without-Leakage-Constraints","page":"Leakage Suppression","title":"1. Start Without Leakage Constraints","text":"Get a working solution first, then add constraints:\n\n# Step 1: Optimize without leakage constraints\nqtraj2 = UnitaryTrajectory(sys, pulse, U_goal)\nqcp_initial = SmoothPulseProblem(qtraj2, N; Q = 100.0)\ncached_solve!(\n    qcp_initial,\n    \"leakage_initial_2\";\n    max_iter = 100,\n    verbose = false,\n    print_level = 1,\n)\n\n# Step 2: Add leakage suppression\nopts = PiccoloOptions(\n    leakage_cost = 5.0,\n    leakage_constraint = true,\n    leakage_constraint_value = 1e-3,\n    verbose = false,\n)\nqcp_leakage = SmoothPulseProblem(qtraj2, N; Q = 100.0, piccolo_options = opts)\ncached_solve!(\n    qcp_leakage,\n    \"leakage_with_suppression_2\";\n    max_iter = 150,\n    verbose = false,\n    print_level = 1,\n)\n\nfidelity(qcp_initial)\n\nfidelity(qcp_leakage)","category":"section"},{"location":"generated/guides/leakage_suppression/#2.-Increase-Gate-Time","page":"Leakage Suppression","title":"2. Increase Gate Time","text":"Faster gates often have more leakage. Try a longer gate time if leakage is high.","category":"section"},{"location":"generated/guides/leakage_suppression/#3.-Use-More-Levels","page":"Leakage Suppression","title":"3. Use More Levels","text":"Include more levels to capture dynamics accurately:\n\nsys_4level = TransmonSystem(levels = 4, Œ¥ = 0.2, drive_bounds = [0.2, 0.2])","category":"section"},{"location":"generated/guides/leakage_suppression/#4.-Reduce-Drive-Amplitude","page":"Leakage Suppression","title":"4. Reduce Drive Amplitude","text":"Lower drives can reduce leakage:\n\nsys_low_drive = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.1, 0.1])","category":"section"},{"location":"generated/guides/leakage_suppression/#Analyzing-Leakage","page":"Leakage Suppression","title":"Analyzing Leakage","text":"After solving, visualize the state evolution including leakage levels:\n\nusing CairoMakie\n\ntraj = get_trajectory(qcp)\nfig = plot_unitary_populations(traj)","category":"section"},{"location":"generated/guides/leakage_suppression/#See-Also","page":"Leakage Suppression","title":"See Also","text":"Operators - EmbeddedOperator details\nSystem Templates - Creating multilevel systems\nObjectives - LeakageObjective documentation\nConstraints - LeakageConstraint documentation\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"guides/#guides-overview","page":"Overview","title":"How-To Guides","text":"This section contains task-oriented guides for specific problems in quantum optimal control.","category":"section"},{"location":"guides/#Available-Guides","page":"Overview","title":"Available Guides","text":"Guide Description\nSystem Templates Using pre-built systems for transmons, ions, and atoms\nLeakage Suppression Controlling population leakage in multilevel systems\nGlobal Variables Optimizing system parameters alongside controls\nVisualization Plotting trajectories and analyzing results\nCustom Objectives Creating custom optimization objectives","category":"section"},{"location":"guides/#Guide-Format","page":"Overview","title":"Guide Format","text":"Each guide follows a consistent format:\n\nProblem statement: What are we trying to accomplish?\nPrerequisites: What you need to know first\nStep-by-step solution: How to solve the problem\nComplete example: Full working code\nVariations: Common modifications","category":"section"},{"location":"guides/#Quick-Links-by-Task","page":"Overview","title":"Quick Links by Task","text":"","category":"section"},{"location":"guides/#Setting-Up-Systems","page":"Overview","title":"Setting Up Systems","text":"Using TransmonSystem for superconducting qubits\nUsing IonChainSystem for trapped ions\nUsing RydbergChainSystem for neutral atoms","category":"section"},{"location":"guides/#Handling-Multilevel-Systems","page":"Overview","title":"Handling Multilevel Systems","text":"Defining gates in subspaces with EmbeddedOperator\nAdding leakage penalties and constraints","category":"section"},{"location":"guides/#Advanced-Optimization","page":"Overview","title":"Advanced Optimization","text":"Optimizing system parameters\nCreating custom fidelity measures","category":"section"},{"location":"guides/#Analysis-and-Visualization","page":"Overview","title":"Analysis and Visualization","text":"Plotting control pulses\nVisualizing state populations\nCreating animations","category":"section"},{"location":"guides/#See-Also","page":"Overview","title":"See Also","text":"Problem Templates - Main optimization API\nConcepts - Detailed type documentation\nTutorials - Step-by-step learning examples","category":"section"},{"location":"generated/guides/visualization/#visualization","page":"Visualization","title":"Visualization","text":"Piccolo.jl provides visualization tools for analyzing optimization results. This guide covers plotting controls, states, and populations.","category":"section"},{"location":"generated/guides/visualization/#Setup","page":"Visualization","title":"Setup","text":"Visualization requires a Makie backend. We'll create a solved problem to work with:\n\nusing Piccolo\nusing CairoMakie\nusing Random\nRandom.seed!(42)\n\n# Create and solve a simple qubit gate problem\nH_drift = 0.5 * PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\nT = 10.0\nN = 100\ntimes = collect(range(0, T, length = N))\ninitial_controls = 0.1 * randn(2, N)\npulse = ZeroOrderPulse(initial_controls, times)\nqtraj = UnitaryTrajectory(sys, pulse, GATES[:X])\n\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0, R = 1e-2, ddu_bound = 1.0)\ncached_solve!(qcp, \"visualization_unitary\"; max_iter = 50, verbose = false, print_level = 1)\n\nfidelity(qcp)","category":"section"},{"location":"generated/guides/visualization/#Basic-Trajectory-Plotting","page":"Visualization","title":"Basic Trajectory Plotting","text":"The plot function from NamedTrajectories.jl plots trajectory components.","category":"section"},{"location":"generated/guides/visualization/#Plot-Controls","page":"Visualization","title":"Plot Controls","text":"traj = get_trajectory(qcp)\nfig = plot(traj, [:u])","category":"section"},{"location":"generated/guides/visualization/#Plot-Controls-and-Derivatives","page":"Visualization","title":"Plot Controls and Derivatives","text":"fig = plot(traj, [:u, :du, :ddu])","category":"section"},{"location":"generated/guides/visualization/#Quantum-Specific-Plots","page":"Visualization","title":"Quantum-Specific Plots","text":"","category":"section"},{"location":"generated/guides/visualization/#Unitary-Populations","page":"Visualization","title":"Unitary Populations","text":"For UnitaryTrajectory, visualize how state populations evolve during the gate:\n\nfig = plot_unitary_populations(traj)","category":"section"},{"location":"generated/guides/visualization/#Ket-State-Populations","page":"Visualization","title":"Ket State Populations","text":"For KetTrajectory, use plot_state_populations:\n\nœà_init = ComplexF64[1.0, 0.0]\nœà_goal = ComplexF64[0.0, 1.0]\n\npulse_ket = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj_ket = KetTrajectory(sys, pulse_ket, œà_init, œà_goal)\nqcp_ket = SmoothPulseProblem(qtraj_ket, N; Q = 100.0, R = 1e-2, ddu_bound = 1.0)\ncached_solve!(qcp_ket, \"visualization_ket\"; max_iter = 50, verbose = false, print_level = 1)\n\ntraj_ket = get_trajectory(qcp_ket)\nfig = plot_state_populations(traj_ket)","category":"section"},{"location":"generated/guides/visualization/#Custom-Plotting","page":"Visualization","title":"Custom Plotting","text":"For full control, extract trajectory data and use Makie directly.","category":"section"},{"location":"generated/guides/visualization/#Manual-Control-Plots","page":"Visualization","title":"Manual Control Plots","text":"plot_times = cumsum([0; get_timesteps(traj)])[1:(end-1)]\n\nfig = Figure(size = (800, 400))\nax = Axis(fig[1, 1], xlabel = \"Time\", ylabel = \"Control Amplitude\")\n\nfor i = 1:size(traj[:u], 1)\n    lines!(ax, plot_times, traj[:u][i, :], label = \"Drive $i\", linewidth = 2)\nend\n\naxislegend(ax, position = :rt)\nfig","category":"section"},{"location":"generated/guides/visualization/#Subplot-Layouts","page":"Visualization","title":"Subplot Layouts","text":"fig = Figure(size = (1000, 500))\n\n# Controls\nax1 = Axis(fig[1, 1], xlabel = \"Time\", ylabel = \"Amplitude\", title = \"Controls\")\nlines!(ax1, plot_times, traj[:u][1, :], label = \"u_x\", linewidth = 2)\nlines!(ax1, plot_times, traj[:u][2, :], label = \"u_y\", linewidth = 2)\naxislegend(ax1, position = :rt)\n\n# Derivatives\nax2 = Axis(fig[1, 2], xlabel = \"Time\", ylabel = \"Derivative\", title = \"Control Derivatives\")\nlines!(ax2, plot_times, traj[:du][1, :], label = \"du_x\", linewidth = 2)\nlines!(ax2, plot_times, traj[:du][2, :], label = \"du_y\", linewidth = 2)\naxislegend(ax2, position = :rt)\n\nfig","category":"section"},{"location":"generated/guides/visualization/#Phase-Space-Plot","page":"Visualization","title":"Phase Space Plot","text":"fig = Figure(size = (500, 500))\nax = Axis(fig[1, 1], xlabel = \"u_x\", ylabel = \"u_y\", title = \"Control Phase Space\")\nlines!(ax, traj[:u][1, :], traj[:u][2, :], linewidth = 2)\nscatter!(\n    ax,\n    [traj[:u][1, 1]],\n    [traj[:u][2, 1]],\n    color = :green,\n    markersize = 15,\n    label = \"Start\",\n)\nscatter!(\n    ax,\n    [traj[:u][1, end]],\n    [traj[:u][2, end]],\n    color = :red,\n    markersize = 15,\n    label = \"End\",\n)\naxislegend(ax, position = :rt)\nfig","category":"section"},{"location":"generated/guides/visualization/#Fidelity-Evolution","page":"Visualization","title":"Fidelity Evolution","text":"Track fidelity during the pulse:\n\nusing LinearAlgebra\n\nU_goal = GATES[:X]\nfidelities = Float64[]\nfor k = 1:size(traj[:≈®‚Éó], 2)\n    U_k = iso_vec_to_operator(traj[:≈®‚Éó][:, k])\n    F_k = abs(tr(U_goal' * U_k))^2 / sys.levels^2\n    push!(fidelities, F_k)\nend\n\nfig = Figure(size = (800, 300))\nax = Axis(fig[1, 1], xlabel = \"Timestep\", ylabel = \"Fidelity\")\nlines!(ax, 1:length(fidelities), fidelities, linewidth = 2)\nhlines!(ax, [0.99], color = :red, linestyle = :dash, label = \"99% target\")\naxislegend(ax, position = :rb)\nfig","category":"section"},{"location":"generated/guides/visualization/#Comparing-Solutions","page":"Visualization","title":"Comparing Solutions","text":"Compare solutions with different regularization weights:\n\nfig = Figure(size = (800, 400))\nax = Axis(fig[1, 1], xlabel = \"Time\", ylabel = \"u_x\", title = \"Effect of Regularization\")\n\nfor (R, label) in [(1e-3, \"R=1e-3\"), (1e-2, \"R=1e-2\"), (1e-1, \"R=1e-1\")]\n    pulse_r = ZeroOrderPulse(0.1 * randn(2, N), times)\n    qtraj_r = UnitaryTrajectory(sys, pulse_r, GATES[:X])\n    qcp_r = SmoothPulseProblem(qtraj_r, N; Q = 100.0, R = R, ddu_bound = 1.0)\n    cached_solve!(\n        qcp_r,\n        \"visualization_R_$(R)\";\n        max_iter = 50,\n        verbose = false,\n        print_level = 1,\n    )\n    traj_r = get_trajectory(qcp_r)\n    t_r = cumsum([0; get_timesteps(traj_r)])[1:(end-1)]\n    lines!(ax, t_r, traj_r[:u][1, :], label = label, linewidth = 2)\nend\n\naxislegend(ax, position = :rt)\nfig","category":"section"},{"location":"generated/guides/visualization/#Saving-Figures","page":"Visualization","title":"Saving Figures","text":"# PNG (raster)\n# save(\"controls.png\", fig)\n\n# PDF (vector graphics)\n# save(\"controls.pdf\", fig)\n\n# SVG (vector graphics)\n# save(\"controls.svg\", fig)","category":"section"},{"location":"generated/guides/visualization/#Plotting-Tips","page":"Visualization","title":"Plotting Tips","text":"","category":"section"},{"location":"generated/guides/visualization/#1.-Use-Appropriate-Resolution","page":"Visualization","title":"1. Use Appropriate Resolution","text":"For publications, use high-res settings:\n\nfig_hires = Figure(size = (1200, 800), fontsize = 14)","category":"section"},{"location":"generated/guides/visualization/#2.-Use-Consistent-Colors","page":"Visualization","title":"2. Use Consistent Colors","text":"colors = Makie.wong_colors()","category":"section"},{"location":"generated/guides/visualization/#3.-Show-Drive-Bounds","page":"Visualization","title":"3. Show Drive Bounds","text":"bound = 1.0\nfig = Figure(size = (800, 300))\nax = Axis(fig[1, 1], xlabel = \"Time\", ylabel = \"Amplitude\")\nband!(\n    ax,\n    plot_times,\n    -bound * ones(length(plot_times)),\n    bound * ones(length(plot_times)),\n    color = (:gray, 0.2),\n    label = \"Bounds\",\n)\nlines!(ax, plot_times, traj[:u][1, :], label = \"u_x\", linewidth = 2)\naxislegend(ax, position = :rt)\nfig","category":"section"},{"location":"generated/guides/visualization/#See-Also","page":"Visualization","title":"See Also","text":"Visualizations API - Complete API reference\nProblem Templates - Generating solutions to plot\nTrajectories - Understanding trajectory structure\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/problem-templates/spline_pulse/#spline-pulse","page":"SplinePulseProblem","title":"SplinePulseProblem","text":"SplinePulseProblem sets up trajectory optimization with spline-based pulses where derivative variables represent spline slopes or tangents. This is ideal for inherently smooth control pulses and warm-starting from previous solutions.","category":"section"},{"location":"generated/problem-templates/spline_pulse/#When-to-Use","page":"SplinePulseProblem","title":"When to Use","text":"Use SplinePulseProblem when:\n\nYou need inherently smooth control pulses\nYou're warm-starting from a previously optimized solution\nYou want cubic spline smoothness without derivative regularization\nYou're working with hardware that expects smooth pulse shapes","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Pulse-Requirements","page":"SplinePulseProblem","title":"Pulse Requirements","text":"SplinePulseProblem works with spline pulse types:\n\nPulse Type Derivative Meaning\nLinearSplinePulse :du represents constrained slope between knots\nCubicSplinePulse :du represents independent Hermite tangents\n\n# Linear spline\npulse = LinearSplinePulse(controls, times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SplinePulseProblem(qtraj)  # Works\n\n# Cubic spline\npulse = CubicSplinePulse(controls, tangents, times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SplinePulseProblem(qtraj)  # Works","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Constructor-Variants","page":"SplinePulseProblem","title":"Constructor Variants","text":"","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Use-Native-Knot-Times-(Recommended-for-Warm-Starting)","page":"SplinePulseProblem","title":"Use Native Knot Times (Recommended for Warm-Starting)","text":"SplinePulseProblem(qtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}; kwargs...)\n\nUses the pulse's native knot times without resampling. Best for warm-starting from a previous solution.","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Resample-to-N-Timesteps","page":"SplinePulseProblem","title":"Resample to N Timesteps","text":"SplinePulseProblem(qtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}, N::Int; kwargs...)\n\nResamples the pulse to N uniformly spaced timesteps.","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Use-Specific-Times","page":"SplinePulseProblem","title":"Use Specific Times","text":"SplinePulseProblem(qtraj::AbstractQuantumTrajectory{<:AbstractSplinePulse}, times::AbstractVector; kwargs...)\n\nResamples the pulse to the specified time points.","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Parameter-Reference","page":"SplinePulseProblem","title":"Parameter Reference","text":"","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Objective-Weights","page":"SplinePulseProblem","title":"Objective Weights","text":"Parameter Type Default Description\nQ Float64 100.0 Weight on infidelity objective\nR Float64 1e-2 Base regularization weight\nR_u Float64 or Vector{Float64} R Regularization on control values\nR_du Float64 or Vector{Float64} R Regularization on derivatives/tangents","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Bounds","page":"SplinePulseProblem","title":"Bounds","text":"Parameter Type Default Description\ndu_bound Float64 Inf Maximum derivative/slope bound\nŒît_bounds Tuple{Float64, Float64} nothing Time-step bounds for free-time optimization","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Advanced-Options","page":"SplinePulseProblem","title":"Advanced Options","text":"Parameter Type Default Description\nintegrator AbstractIntegrator nothing Custom integrator (uses BilinearIntegrator if nothing)\nglobal_names Vector{Symbol} nothing Global parameters to optimize\nglobal_bounds Dict{Symbol, ...} nothing Bounds on global variables\nconstraints Vector{AbstractConstraint} [] Additional constraints\npiccolo_options PiccoloOptions PiccoloOptions() Solver options","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Examples","page":"SplinePulseProblem","title":"Examples","text":"","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Basic-Spline-Optimization","page":"SplinePulseProblem","title":"Basic Spline Optimization","text":"using Piccolo\n\n# Define system\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n# Create cubic spline pulse\nT, N = 10.0, 50\ntimes = collect(range(0, T, length = N))\ncontrols = 0.1 * randn(2, N)\ntangents = zeros(2, N)  ## Initial tangents\npulse = CubicSplinePulse(controls, tangents, times)\n\nqtraj = UnitaryTrajectory(sys, pulse, GATES[:X])\n\n# Solve using native knot times\nqcp = SplinePulseProblem(qtraj; Q = 100.0, du_bound = 10.0)\ncached_solve!(qcp, \"spline_pulse_basic\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Warm-Starting-from-Previous-Solution","page":"SplinePulseProblem","title":"Warm-Starting from Previous Solution","text":"# Load previously optimized pulse\nusing JLD2\n@load \"optimized_pulse.jld2\" saved_pulse\n\n# Create new trajectory with saved pulse\nqtraj = UnitaryTrajectory(sys, saved_pulse, U_goal)\n\n# Use native knot times (no resampling)\nqcp = SplinePulseProblem(qtraj)\nsolve!(qcp; max_iter=50)  # Converges quickly from good initial guess","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Resampling-to-Different-Resolution","page":"SplinePulseProblem","title":"Resampling to Different Resolution","text":"The original pulse above has 50 knots. We can resample to 100 for finer control:\n\nqcp_resampled = SplinePulseProblem(qtraj, 100; Q = 100.0)\ncached_solve!(qcp_resampled, \"spline_pulse_resampled\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Linear-vs-Cubic-Splines","page":"SplinePulseProblem","title":"Linear vs Cubic Splines","text":"Linear Splines: The derivative :du represents the slope between knots. A DerivativeIntegrator constraint enforces du[k] = (u[k+1] - u[k]) / Œît.\n\npulse_linear = LinearSplinePulse(controls, times)\nqtraj_linear = UnitaryTrajectory(sys, pulse_linear, GATES[:X])\nqcp_linear = SplinePulseProblem(qtraj_linear)\n# du is constrained to be consistent with u\n\nCubic Splines (Hermite): The derivative :du represents independent Hermite tangents at each knot. These are free optimization variables with no inter-knot constraint.\n\npulse_cubic = CubicSplinePulse(controls, tangents, times)\nqtraj_cubic = UnitaryTrajectory(sys, pulse_cubic, GATES[:X])\nqcp_cubic = SplinePulseProblem(qtraj_cubic)\n# du (tangents) are independent variables","category":"section"},{"location":"generated/problem-templates/spline_pulse/#Trajectory-Structure","page":"SplinePulseProblem","title":"Trajectory Structure","text":"Unlike SmoothPulseProblem which has three derivative levels (:u, :du, :ddu), SplinePulseProblem only has one:\n\nVariable Description\n:u Control values at knot points\n:du Derivatives/tangents (meaning depends on spline type)\n\nThe reduced number of variables can lead to faster optimization while maintaining smooth pulses through the spline interpolation.","category":"section"},{"location":"generated/problem-templates/spline_pulse/#See-Also","page":"SplinePulseProblem","title":"See Also","text":"SmoothPulseProblem - For piecewise constant controls\nMinimumTimeProblem - Time-optimal control\nPulses - Detailed pulse type documentation\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"concepts/#concepts-overview","page":"Overview","title":"Concepts Overview","text":"Piccolo.jl is organized into three main modules that work together to enable quantum optimal control:","category":"section"},{"location":"concepts/#Architecture","page":"Overview","title":"Architecture","text":"Piccolo.jl\n‚îú‚îÄ‚îÄ Quantum          # Quantum mechanical building blocks\n‚îÇ   ‚îú‚îÄ‚îÄ Systems      # Hamiltonian representations\n‚îÇ   ‚îú‚îÄ‚îÄ Trajectories # Time evolution containers\n‚îÇ   ‚îú‚îÄ‚îÄ Pulses       # Control parameterizations\n‚îÇ   ‚îú‚îÄ‚îÄ Operators    # Embedded and lifted operators\n‚îÇ   ‚îî‚îÄ‚îÄ Isomorphisms # Real vector representations\n‚îÇ\n‚îú‚îÄ‚îÄ Control          # Optimal control framework\n‚îÇ   ‚îú‚îÄ‚îÄ Problems     # QuantumControlProblem wrapper\n‚îÇ   ‚îú‚îÄ‚îÄ Objectives   # Fidelity and regularization\n‚îÇ   ‚îú‚îÄ‚îÄ Constraints  # Bounds and equality constraints\n‚îÇ   ‚îî‚îÄ‚îÄ Templates    # High-level problem constructors\n‚îÇ\n‚îî‚îÄ‚îÄ Visualizations   # Plotting and analysis\n    ‚îú‚îÄ‚îÄ Trajectories # State and control plots\n    ‚îî‚îÄ‚îÄ Populations  # Population dynamics","category":"section"},{"location":"concepts/#Workflow-Overview","page":"Overview","title":"Workflow Overview","text":"A typical Piccolo.jl workflow follows these steps:\n\n# 1. Define the quantum system\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\n\n# 2. Create an initial control pulse\npulse = ZeroOrderPulse(initial_controls, times)\n\n# 3. Define the optimization goal via a trajectory\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# 4. Set up the optimization problem\nqcp = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2)\n\n# 5. Solve\nsolve!(qcp; max_iter=100)\n\n# 6. Analyze and use results\nfidelity(qcp)\noptimized_pulse = get_pulse(qcp.qtraj)","category":"section"},{"location":"concepts/#Core-Concepts","page":"Overview","title":"Core Concepts","text":"","category":"section"},{"location":"concepts/#[Quantum-Systems](@ref-quantum-systems)","page":"Overview","title":"Quantum Systems","text":"Quantum systems represent the physical hardware you're controlling. They encapsulate:\n\nDrift Hamiltonian H‚ÇÄ: Always-on system dynamics\nDrive Hamiltonians H·µ¢: Controllable interactions\nDrive bounds: Hardware limits on control amplitudes\n\n# The Hamiltonian: H(u,t) = H_drift + Œ£·µ¢ u·µ¢(t) H_drives[i]\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)","category":"section"},{"location":"concepts/#[Trajectories](@ref-trajectories-concept)","page":"Overview","title":"Trajectories","text":"Trajectories combine a system, pulse, and goal to represent a complete optimization task:\n\nType Use Case\nUnitaryTrajectory Gate synthesis\nKetTrajectory State preparation\nDensityTrajectory Open system evolution\nMultiKetTrajectory Multiple state transfers\nSamplingTrajectory Robust optimization","category":"section"},{"location":"concepts/#[Pulses](@ref-pulses-concept)","page":"Overview","title":"Pulses","text":"Pulses parameterize how controls vary in time:\n\nType Description\nZeroOrderPulse Piecewise constant (for SmoothPulseProblem)\nLinearSplinePulse Linear interpolation between knots\nCubicSplinePulse Smooth cubic Hermite splines\nGaussianPulse Parametric Gaussian envelope","category":"section"},{"location":"concepts/#[Objectives](@ref-objectives-concept)","page":"Overview","title":"Objectives","text":"Objectives define what the optimization minimizes:\n\nInfidelity objectives: 1 - F where F is fidelity\nRegularization: Penalize large or rapidly changing controls\nLeakage objectives: Penalize population outside computational subspace","category":"section"},{"location":"concepts/#[Constraints](@ref-constraints-concept)","page":"Overview","title":"Constraints","text":"Constraints define what solutions must satisfy:\n\nBound constraints: Limits on control values\nFidelity constraints: Minimum fidelity requirements\nLeakage constraints: Maximum allowed leakage","category":"section"},{"location":"concepts/#Reexported-Packages","page":"Overview","title":"Reexported Packages","text":"Piccolo.jl reexports several foundation packages:\n\nPackage Purpose\nDirectTrajOpt Trajectory optimization solver\nNamedTrajectories Named trajectory data structures\nTrajectoryIndexingUtils Trajectory slicing and indexing\n\nThese are available when you using Piccolo without additional imports.","category":"section"},{"location":"concepts/#Next-Steps","page":"Overview","title":"Next Steps","text":"New to Piccolo? Start with the Getting Started guide\nReady to optimize? See Problem Templates for the main API\nNeed details? Explore the individual concept pages below","category":"section"},{"location":"concepts/#Concept-Pages","page":"Overview","title":"Concept Pages","text":"Quantum Systems - Hamiltonian representations\nTrajectories - Time evolution containers\nPulses - Control parameterizations\nObjectives - Optimization objectives\nConstraints - Problem constraints\nOperators - Embedded and lifted operators\nIsomorphisms - Real vector representations","category":"section"},{"location":"generated/state_transfer/#state-transfer-tutorial","page":"State Transfer","title":"State Transfer","text":"This tutorial covers state-to-state transfer using KetTrajectory. We'll prepare quantum states and implement gates via state mappings.","category":"section"},{"location":"generated/state_transfer/#Overview","page":"State Transfer","title":"Overview","text":"While UnitaryTrajectory optimizes for a full unitary gate, KetTrajectory optimizes for transferring a specific initial state to a target state. This is useful for:\n\nState preparation\nGates where you only care about specific state mappings\nProblems where full unitary tracking is expensive\n\nusing Piccolo\nusing CairoMakie\nusing Random\nRandom.seed!(123)","category":"section"},{"location":"generated/state_transfer/#Single-State-Transfer","page":"State Transfer","title":"Single State Transfer","text":"Let's prepare the |1‚ü© state starting from |0‚ü©.","category":"section"},{"location":"generated/state_transfer/#Setup","page":"State Transfer","title":"Setup","text":"# Create quantum system\nH_drift = 0.5 * PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n# Time parameters\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\n\n# Initial pulse\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)","category":"section"},{"location":"generated/state_transfer/#Define-State-Transfer","page":"State Transfer","title":"Define State Transfer","text":"# Initial state: |0‚ü©\nœà_init = ComplexF64[1.0, 0.0]\n\n# Target state: |1‚ü©\nœà_goal = ComplexF64[0.0, 1.0]\n\n# Create KetTrajectory\nqtraj = KetTrajectory(sys, pulse, œà_init, œà_goal)","category":"section"},{"location":"generated/state_transfer/#Solve","page":"State Transfer","title":"Solve","text":"qcp = SmoothPulseProblem(qtraj, N; Q = 100.0, R = 1e-2)\ncached_solve!(qcp, \"state_transfer_single\"; max_iter = 20, verbose = false, print_level = 1)\n\nfidelity(qcp)","category":"section"},{"location":"generated/state_transfer/#Visualize-State-Evolution","page":"State Transfer","title":"Visualize State Evolution","text":"traj = get_trajectory(qcp)\n\n# Convert isomorphic states to physical states\nn_steps = size(traj[:œàÃÉ], 2)\npopulations = zeros(2, n_steps)\n\nfor k = 1:n_steps\n    œà = iso_to_ket(traj[:œàÃÉ][:, k])\n    populations[:, k] = abs2.(œà)\nend\n\n# Plot\nfig = Figure(size = (800, 400))\n\nax1 = Axis(fig[1, 1], xlabel = \"Timestep\", ylabel = \"Population\", title = \"State Evolution\")\nlines!(ax1, 1:n_steps, populations[1, :], label = \"|0‚ü©\", linewidth = 2)\nlines!(ax1, 1:n_steps, populations[2, :], label = \"|1‚ü©\", linewidth = 2)\naxislegend(ax1, position = :rt)\n\nfig","category":"section"},{"location":"generated/state_transfer/#Multi-State-Transfer-(Gate-via-States)","page":"State Transfer","title":"Multi-State Transfer (Gate via States)","text":"We can define a gate by specifying how it maps multiple states. MultiKetTrajectory optimizes all mappings simultaneously with coherent phases.","category":"section"},{"location":"generated/state_transfer/#Define-X-Gate-via-State-Mappings","page":"State Transfer","title":"Define X Gate via State Mappings","text":"The X gate maps:\n\n|0‚ü© ‚Üí |1‚ü©\n|1‚ü© ‚Üí |0‚ü©\n\n# Basis states\nœà0 = ComplexF64[1.0, 0.0]  # |0‚ü©\nœà1 = ComplexF64[0.0, 1.0]  # |1‚ü©\n\n# Initial states and their targets\ninitial_states = [œà0, œà1]\ngoal_states = [œà1, œà0]  # X gate swaps them\n\n# Create new pulse for this problem\npulse_multi = ZeroOrderPulse(0.1 * randn(2, N), times)\n\n# Create MultiKetTrajectory\nqtraj_multi = MultiKetTrajectory(sys, pulse_multi, initial_states, goal_states)","category":"section"},{"location":"generated/state_transfer/#Solve-with-Coherent-Fidelity","page":"State Transfer","title":"Solve with Coherent Fidelity","text":"MultiKetTrajectory uses CoherentKetInfidelityObjective, which ensures not just that each state reaches its target, but that the relative phases between states are preserved correctly.\n\nqcp_multi = SmoothPulseProblem(qtraj_multi, N; Q = 100.0, R = 1e-2)\ncached_solve!(\n    qcp_multi,\n    \"state_transfer_multi\";\n    max_iter = 20,\n    verbose = false,\n    print_level = 1,\n)\n\nfidelity(qcp_multi)","category":"section"},{"location":"generated/state_transfer/#Visualize-Both-State-Evolutions","page":"State Transfer","title":"Visualize Both State Evolutions","text":"traj_multi = get_trajectory(qcp_multi)\n\n# Extract populations for both initial states\n# MultiKetTrajectory stores states as :œàÃÉ1, :œàÃÉ2, etc.\nn_steps = size(traj_multi[:œàÃÉ1], 2)\n\npops1 = zeros(2, n_steps)  # Evolution from |0‚ü©\npops2 = zeros(2, n_steps)  # Evolution from |1‚ü©\n\nfor k = 1:n_steps\n    œà1_k = iso_to_ket(traj_multi[:œàÃÉ1][:, k])\n    œà2_k = iso_to_ket(traj_multi[:œàÃÉ2][:, k])\n    pops1[:, k] = abs2.(œà1_k)\n    pops2[:, k] = abs2.(œà2_k)\nend\n\nfig2 = Figure(size = (800, 400))\n\nax1 = Axis(fig2[1, 1], xlabel = \"Timestep\", ylabel = \"Population\", title = \"|0‚ü© ‚Üí |1‚ü©\")\nlines!(ax1, 1:n_steps, pops1[1, :], label = \"|0‚ü©\", linewidth = 2, color = :blue)\nlines!(ax1, 1:n_steps, pops1[2, :], label = \"|1‚ü©\", linewidth = 2, color = :red)\naxislegend(ax1, position = :rt)\n\nax2 = Axis(fig2[1, 2], xlabel = \"Timestep\", ylabel = \"Population\", title = \"|1‚ü© ‚Üí |0‚ü©\")\nlines!(ax2, 1:n_steps, pops2[1, :], label = \"|0‚ü©\", linewidth = 2, color = :blue)\nlines!(ax2, 1:n_steps, pops2[2, :], label = \"|1‚ü©\", linewidth = 2, color = :red)\naxislegend(ax2, position = :rt)\n\nfig2","category":"section"},{"location":"generated/state_transfer/#When-to-Use-Each-Trajectory-Type","page":"State Transfer","title":"When to Use Each Trajectory Type","text":"Trajectory Use Case Pros Cons\nUnitaryTrajectory Full gate synthesis Complete gate, any input Tracks d¬≤ elements\nKetTrajectory Single state prep Fast, simple Single state only\nMultiKetTrajectory Gate via state maps Phase coherent Need all relevant states","category":"section"},{"location":"generated/state_transfer/#Superposition-State-Preparation","page":"State Transfer","title":"Superposition State Preparation","text":"Let's prepare a superposition state: |+‚ü© = (|0‚ü© + |1‚ü©)/‚àö2\n\nœà_plus = ComplexF64[1, 1] / sqrt(2)\n\npulse_super = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj_super = KetTrajectory(sys, pulse_super, œà0, œà_plus)\n\nqcp_super = SmoothPulseProblem(qtraj_super, N; Q = 100.0, R = 1e-2)\ncached_solve!(\n    qcp_super,\n    \"state_transfer_superposition\";\n    max_iter = 20,\n    verbose = false,\n    print_level = 1,\n)\n\nfidelity(qcp_super)\n\nVerify the final state:\n\ntraj_super = get_trajectory(qcp_super)\nœà_final = iso_to_ket(traj_super[:œàÃÉ][:, end])\nround.(œà_final, digits = 3)","category":"section"},{"location":"generated/state_transfer/#Next-Steps","page":"State Transfer","title":"Next Steps","text":"Multilevel Transmon: Work with realistic superconducting qubits\nRobust Control: Make pulses robust to parameter uncertainty\nProblem Templates: Full API documentation\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/concepts/operators/#operators-concept","page":"Operators","title":"Operators","text":"Piccolo.jl provides specialized operator types for working with composite and multilevel quantum systems.","category":"section"},{"location":"generated/concepts/operators/#Overview","page":"Operators","title":"Overview","text":"Type / Function Purpose\nEmbeddedOperator Gates acting on subspace of larger system\nlift_operator Operators lifted to composite Hilbert spaces\ndirect_sum Block diagonal operator combinations","category":"section"},{"location":"generated/concepts/operators/#EmbeddedOperator","page":"Operators","title":"EmbeddedOperator","text":"EmbeddedOperator represents a gate that acts on a computational subspace within a larger Hilbert space. This is essential for multilevel systems like transmons.","category":"section"},{"location":"generated/concepts/operators/#Construction","page":"Operators","title":"Construction","text":"using Piccolo\nusing SparseArrays\n\n# From a gate symbol\nsys = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.2, 0.2])\nU_X = EmbeddedOperator(:X, sys)\n\n# From a matrix\nT_gate = [1 0; 0 exp(im * œÄ / 4)]\nU_T = EmbeddedOperator(T_gate, sys)","category":"section"},{"location":"generated/concepts/operators/#Supported-Gate-Symbols","page":"Operators","title":"Supported Gate Symbols","text":"Standard single-qubit gates:\n\n:I, :X, :Y, :Z - Pauli gates\n:H - Hadamard\n:T, :S - Phase gates\n:sqrtX, :sqrtY - Square root gates\n\nTwo-qubit gates (for composite systems):\n\n:CX, :CNOT - Controlled-NOT\n:CZ - Controlled-Z\n:SWAP - SWAP\n:sqrtiSWAP - ‚àöiSWAP","category":"section"},{"location":"generated/concepts/operators/#Properties","page":"Operators","title":"Properties","text":"U_goal = EmbeddedOperator(:X, sys)\n\n# Access the full operator matrix\nsize(U_goal.operator)\n\n# Computational subspace\nU_goal.subspace","category":"section"},{"location":"generated/concepts/operators/#How-Embedding-Works","page":"Operators","title":"How Embedding Works","text":"For a 3-level system with computational subspace {|0‚ü©, |1‚ü©}:\n\nX_textembedded = beginpmatrix\n0  1  0 \n1  0  0 \n0  0  1\nendpmatrix\n\nThe gate acts as X on the first two levels and as identity on the third.\n\nU_goal.operator","category":"section"},{"location":"generated/concepts/operators/#Use-with-Trajectories","page":"Operators","title":"Use with Trajectories","text":"T_dur, N = 10.0, 100\ntimes = collect(range(0, T_dur, length = N))\npulse = ZeroOrderPulse(0.01 * randn(2, N), times)\n\n# EmbeddedOperator is accepted as goal\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# Solve with leakage handling\nopts = PiccoloOptions(leakage_constraint = true, leakage_constraint_value = 1e-3)\nqcp = SmoothPulseProblem(qtraj, N; piccolo_options = opts)\ncached_solve!(qcp, \"operators_embedded\"; max_iter = 100)\nfidelity(qcp)","category":"section"},{"location":"generated/concepts/operators/#lift_operator","page":"Operators","title":"lift_operator","text":"lift_operator lifts an operator from a subsystem to a composite Hilbert space via tensor products.","category":"section"},{"location":"generated/concepts/operators/#Construction-2","page":"Operators","title":"Construction","text":"# Operator on qubit 1 of a 2-qubit system\nX_on_q1 = lift_operator(PAULIS[:X], 1, [2, 2])  # X ‚äó I\nX_on_q1 |> sparse\n\n# Operator on qubit 2\nZ_on_q2 = lift_operator(PAULIS[:Z], 2, [2, 2])  # I ‚äó Z\nZ_on_q2 |> sparse","category":"section"},{"location":"generated/concepts/operators/#Arguments","page":"Operators","title":"Arguments","text":"Argument Type Description\nop Matrix Operator to lift\nsubsystem Int Which subsystem (1-indexed)\ndims Vector{Int} Dimensions of all subsystems","category":"section"},{"location":"generated/concepts/operators/#Example:-Two-Qubit-Hamiltonian","page":"Operators","title":"Example: Two-Qubit Hamiltonian","text":"dims = [2, 2]  # Two qubits\n\n# Individual qubit terms\nZ1 = lift_operator(PAULIS[:Z], 1, dims)\nZ2 = lift_operator(PAULIS[:Z], 2, dims)\nX1 = lift_operator(PAULIS[:X], 1, dims)\nX2 = lift_operator(PAULIS[:X], 2, dims)\n\n# Build Hamiltonian: H = œâ1*Z1 + œâ2*Z2 + J*Z1*Z2\nœâ1, œâ2, J = 1.0, 1.1, 0.05\nH_drift_2q = œâ1 * Z1 + œâ2 * Z2 + J * Z1 * Z2\nH_drift_2q |> sparse","category":"section"},{"location":"generated/concepts/operators/#direct_sum","page":"Operators","title":"direct_sum","text":"direct_sum creates block diagonal operators, useful for parallel operations on independent subspaces.","category":"section"},{"location":"generated/concepts/operators/#Construction-3","page":"Operators","title":"Construction","text":"A = [1 0; 0 -1]\nB = [0 1; 1 0]\nC = direct_sum(A, B)\nC","category":"section"},{"location":"generated/concepts/operators/#Use-Case","page":"Operators","title":"Use Case","text":"Direct sums are useful for:\n\nOperations on multiple independent qubits\nBlock diagonal Hamiltonians\nComposite systems with no coupling","category":"section"},{"location":"generated/concepts/operators/#Common-Patterns","page":"Operators","title":"Common Patterns","text":"","category":"section"},{"location":"generated/concepts/operators/#Mixed-Subsystems","page":"Operators","title":"Mixed Subsystems","text":"Qubit coupled to a resonator (cavity):\n\n# Qubit: 2 levels, Cavity: 10 levels\ndims_qc = [2, 10]\n\n# Qubit operators\nœÉ_x = lift_operator(PAULIS[:X], 1, dims_qc)\nœÉ_z = lift_operator(PAULIS[:Z], 1, dims_qc)\n\n# Cavity operators\na_cav = lift_operator(annihilate(10), 2, dims_qc)\na_dag_cav = lift_operator(create(10), 2, dims_qc)\n\n# Jaynes-Cummings coupling\ng_jc = 0.1\nH_coupling = g_jc * (œÉ_x * (a_cav + a_dag_cav))\nH_coupling |> sparse","category":"section"},{"location":"generated/concepts/operators/#Utility-Functions","page":"Operators","title":"Utility Functions","text":"","category":"section"},{"location":"generated/concepts/operators/#Creating-Standard-Operators","page":"Operators","title":"Creating Standard Operators","text":"# Annihilation and creation operators\nlevels = 5\na = annihilate(levels)\na_dag = create(levels)\nn_op = a_dag * a  # Number operator\nn_op |> sparse\n\n# Pauli matrices\nI2, X, Y, Z = PAULIS[:I], PAULIS[:X], PAULIS[:Y], PAULIS[:Z]\nI2 |> sparse\n\nX |> sparse\n\nY |> sparse\n\nZ |> sparse","category":"section"},{"location":"generated/concepts/operators/#Tensor-Products","page":"Operators","title":"Tensor Products","text":"# Manual tensor product\nH_ZZ = kron(PAULIS[:Z], PAULIS[:Z])\n\n# Or use lift_operator for clarity\nZ1 = lift_operator(PAULIS[:Z], 1, [2, 2])\nZ2 = lift_operator(PAULIS[:Z], 2, [2, 2])\nH_ZZ_lifted = Z1 * Z2\n\nH_ZZ ‚âà H_ZZ_lifted","category":"section"},{"location":"generated/concepts/operators/#See-Also","page":"Operators","title":"See Also","text":"Leakage Suppression - Using EmbeddedOperator for leakage control\nQuantum Systems - Building Hamiltonians with operators\nIsomorphisms - Converting operators to optimization-friendly forms\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#smooth-pulse","page":"SmoothPulseProblem","title":"SmoothPulseProblem","text":"SmoothPulseProblem is the most commonly used problem template in Piccolo.jl. It sets up trajectory optimization with piecewise constant controls (ZeroOrderPulse) where control smoothness is enforced through discrete derivative variables.","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#When-to-Use","page":"SmoothPulseProblem","title":"When to Use","text":"Use SmoothPulseProblem when:\n\nYou want piecewise constant control pulses\nYou need smooth transitions between control values\nYou're starting a new optimization (not warm-starting from a previous solution)\nYou want fine control over derivative bounds","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Pulse-Requirement","page":"SmoothPulseProblem","title":"Pulse Requirement","text":"SmoothPulseProblem requires a trajectory with a ZeroOrderPulse:\n\npulse = ZeroOrderPulse(controls, times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SmoothPulseProblem(qtraj, N)  # Works\n\nUsing a spline pulse will result in an error directing you to SplinePulseProblem.","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Constructor","page":"SmoothPulseProblem","title":"Constructor","text":"SmoothPulseProblem(\n    qtraj::AbstractQuantumTrajectory{<:ZeroOrderPulse},\n    N::Int;\n    kwargs...\n)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Parameter-Reference","page":"SmoothPulseProblem","title":"Parameter Reference","text":"","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Required-Parameters","page":"SmoothPulseProblem","title":"Required Parameters","text":"Parameter Type Description\nqtraj AbstractQuantumTrajectory{ZeroOrderPulse} Quantum trajectory containing system, pulse, and goal\nN Int Number of discretization timesteps","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Objective-Weights","page":"SmoothPulseProblem","title":"Objective Weights","text":"Parameter Type Default Description\nQ Float64 100.0 Weight on infidelity objective. Higher values prioritize achieving target fidelity.\nR Float64 1e-2 Base regularization weight applied to all derivative terms.\nR_u Float64 or Vector{Float64} R Regularization on control values. Can be per-drive.\nR_du Float64 or Vector{Float64} R Regularization on first derivative (control jumps).\nR_ddu Float64 or Vector{Float64} R Regularization on second derivative (control acceleration).","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Bounds","page":"SmoothPulseProblem","title":"Bounds","text":"Parameter Type Default Description\ndu_bound Float64 Inf Maximum allowed control jump between timesteps.\nddu_bound Float64 1.0 Maximum allowed control acceleration.\nŒît_bounds Tuple{Float64, Float64} nothing Time-step bounds (min, max) for free-time optimization. Required for MinimumTimeProblem.","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Advanced-Options","page":"SmoothPulseProblem","title":"Advanced Options","text":"Parameter Type Default Description\nintegrator AbstractIntegrator nothing Custom integrator. If nothing, uses BilinearIntegrator.\nglobal_names Vector{Symbol} nothing Names of global parameters to optimize (requires custom integrator).\nglobal_bounds Dict{Symbol, ...} nothing Bounds on global variables. Values can be Float64 (symmetric ¬±) or Tuple{Float64, Float64}.\nconstraints Vector{AbstractConstraint} [] Additional constraints to add to the problem.\npiccolo_options PiccoloOptions PiccoloOptions() Solver and leakage options.","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Examples","page":"SmoothPulseProblem","title":"Examples","text":"","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Basic-Gate-Synthesis","page":"SmoothPulseProblem","title":"Basic Gate Synthesis","text":"using Piccolo\n\n# Define system\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n# Create trajectory\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys, pulse, GATES[:X])\n\n# Solve\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0, R = 1e-2)\ncached_solve!(qcp, \"smooth_pulse_basic\"; max_iter = 100)\n\nfidelity(qcp)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#With-Derivative-Bounds","page":"SmoothPulseProblem","title":"With Derivative Bounds","text":"Constrain how fast controls can change:\n\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    du_bound = 0.5,    ## Limit control jumps\n    ddu_bound = 0.1,    ## Limit control acceleration\n)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Enabling-Free-Time-for-MinimumTimeProblem","page":"SmoothPulseProblem","title":"Enabling Free Time for MinimumTimeProblem","text":"To later use MinimumTimeProblem, give bounds on variable timesteps:\n\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    Œît_bounds = (0.01, 0.5),  ## Timesteps can vary from 0.01 to 0.5\n)\ncached_solve!(qcp, \"smooth_pulse_free_time\"; max_iter = 100)\n\n# Now can minimize time\nqcp_mintime = MinimumTimeProblem(qcp; final_fidelity = 0.99)\ncached_solve!(qcp_mintime, \"smooth_pulse_mintime\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Per-Drive-Regularization","page":"SmoothPulseProblem","title":"Per-Drive Regularization","text":"Apply different regularization to different control channels:\n\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    R_u = [1e-3, 1e-2],     ## Less regularization on drive 1\n    R_du = [1e-2, 1e-1],    ## Different smoothness weights\n    R_ddu = [1e-2, 1e-1],\n)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#With-Leakage-Suppression","page":"SmoothPulseProblem","title":"With Leakage Suppression","text":"For multilevel systems, use PiccoloOptions to enable leakage handling, in this example a 3-level transmon system:\n\nsys = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.2, 0.2])\n\n# Embedded X gate (only affects computational subspace)\nU_goal = EmbeddedOperator(:X, sys)\n\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# Enable leakage suppression\nopts = PiccoloOptions(leakage_constraint = true, leakage_constraint_value = 1e-3)\n\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0, piccolo_options = opts)\ncached_solve!(qcp, \"smooth_pulse_leakage\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#State-Transfer","page":"SmoothPulseProblem","title":"State Transfer","text":"Works with KetTrajectory for state preparation. Here we go back to the 2-level system:\n\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\nœà_init = ComplexF64[1, 0]  ## |0‚ü©\nœà_goal = ComplexF64[0, 1]  ## |1‚ü©\n\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = KetTrajectory(sys, pulse, œà_init, œà_goal)\n\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0)\ncached_solve!(qcp, \"smooth_pulse_state_transfer\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#Multiple-State-Transfers","page":"SmoothPulseProblem","title":"Multiple State Transfers","text":"Use MultiKetTrajectory for gates defined by state mappings:\n\nœà0, œà1 = ComplexF64[1, 0], ComplexF64[0, 1]\n\n# X gate: |0‚ü© ‚Üí |1‚ü© and |1‚ü© ‚Üí |0‚ü©\nqtraj = MultiKetTrajectory(sys, pulse, [œà0, œà1], [œà1, œà0])\n\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0)\ncached_solve!(qcp, \"smooth_pulse_multi_ket\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#How-It-Works","page":"SmoothPulseProblem","title":"How It Works","text":"SmoothPulseProblem internally:\n\nAdds derivative variables: Creates :du (first derivative) and :ddu (second derivative) variables alongside controls :u\nSets up integrators: Uses DerivativeIntegrator to enforce consistency:\ndu[k] = (u[k+1] - u[k]) / Œît\nddu[k] = (du[k+1] - du[k]) / Œît\nConfigures objectives:\nInfidelity objective with weight Q\nQuadratic regularization on u, du, ddu with weights R_u, R_du, R_ddu\nApplies bounds: Enforces du_bound and ddu_bound as hard constraints\n\nThe derivative variables act as auxiliary optimization variables that encourage smooth control transitions without requiring explicit smoothness constraints on the original controls.","category":"section"},{"location":"generated/problem-templates/smooth_pulse/#See-Also","page":"SmoothPulseProblem","title":"See Also","text":"SplinePulseProblem - For inherently smooth spline-based controls\nMinimumTimeProblem - Time-optimal control\nSamplingProblem - Robust optimization\nPulses - Pulse type documentation\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/concepts/objectives/#objectives-concept","page":"Objectives","title":"Objectives","text":"Objectives define what the optimization minimizes. Piccolo.jl provides objectives for fidelity, regularization, and leakage suppression.","category":"section"},{"location":"generated/concepts/objectives/#Overview","page":"Objectives","title":"Overview","text":"The total objective is a weighted sum:\n\nJ = Q cdot J_textfidelity + R_u cdot J_u + R_du cdot J_du + R_ddu cdot J_ddu + cdots\n\nWhere:\n\nJ_fidelity: Infidelity (1 - F)\nJ_u, J_du, J_ddu: Control regularization terms","category":"section"},{"location":"generated/concepts/objectives/#Fidelity-Objectives","page":"Objectives","title":"Fidelity Objectives","text":"","category":"section"},{"location":"generated/concepts/objectives/#UnitaryInfidelityObjective","page":"Objectives","title":"UnitaryInfidelityObjective","text":"For unitary gate synthesis:\n\nobj = UnitaryInfidelityObjective(:≈®‚Éó, U_goal; Q=100.0)\n\nFidelity metric:\n\nF = frac1d^2 left textTr(U_textgoal^dagger U) right^2\n\nWhere d is the Hilbert space dimension.","category":"section"},{"location":"generated/concepts/objectives/#KetInfidelityObjective","page":"Objectives","title":"KetInfidelityObjective","text":"For single state transfer:\n\nobj = KetInfidelityObjective(:œàÃÉ, œà_goal; Q=100.0)\n\nFidelity metric:\n\nF = left langle psi_textgoal  psi rangle right^2","category":"section"},{"location":"generated/concepts/objectives/#CoherentKetInfidelityObjective","page":"Objectives","title":"CoherentKetInfidelityObjective","text":"For multiple state transfers with phase coherence (used by MultiKetTrajectory):\n\nobj = CoherentKetInfidelityObjective(\n    [:œàÃÉ1, :œàÃÉ2],\n    [œà_goal1, œà_goal2];\n    Q=100.0\n)\n\nThis ensures both:\n\nEach state reaches its target\nRelative phases between states are preserved","category":"section"},{"location":"generated/concepts/objectives/#UnitaryFreePhaseInfidelityObjective","page":"Objectives","title":"UnitaryFreePhaseInfidelityObjective","text":"When global phase doesn't matter:\n\nobj = UnitaryFreePhaseInfidelityObjective(:≈®‚Éó, U_goal; Q=100.0)\n\nOptimizes over the global phase to find the best match.","category":"section"},{"location":"generated/concepts/objectives/#Regularization-Objectives","page":"Objectives","title":"Regularization Objectives","text":"Regularization penalizes large or rapidly-varying controls.","category":"section"},{"location":"generated/concepts/objectives/#QuadraticRegularizer","page":"Objectives","title":"QuadraticRegularizer","text":"The standard regularization form:\n\n# Penalize control magnitude\nreg_u = QuadraticRegularizer(:u, traj, R)\n\n# Penalize control derivatives\nreg_du = QuadraticRegularizer(:du, traj, R)\nreg_ddu = QuadraticRegularizer(:ddu, traj, R)\n\nMathematical form:\n\nJ_x = sum_k  x_k ^2","category":"section"},{"location":"generated/concepts/objectives/#Why-Regularize?","page":"Objectives","title":"Why Regularize?","text":"Smoothness: Derivative regularization encourages smooth pulses\nRobustness: Prevents exploiting numerical precision\nHardware-friendliness: Bounded, smooth controls are easier to implement\nConvergence: Regularization improves optimization landscape","category":"section"},{"location":"generated/concepts/objectives/#Leakage-Objectives","page":"Objectives","title":"Leakage Objectives","text":"For multilevel systems, leakage to non-computational states can be penalized.","category":"section"},{"location":"generated/concepts/objectives/#LeakageObjective","page":"Objectives","title":"LeakageObjective","text":"# For EmbeddedOperator with defined subspace\nop = EmbeddedOperator(:X, sys)  # X gate in computational subspace\nobj = LeakageObjective(:≈®‚Éó, op; Q=10.0)\n\nMathematical form: Penalizes population outside the computational subspace at the final time.","category":"section"},{"location":"generated/concepts/objectives/#Via-PiccoloOptions","page":"Objectives","title":"Via PiccoloOptions","text":"The easier way is through PiccoloOptions:\n\nopts = PiccoloOptions(\n    leakage_constraint=true,\n    leakage_constraint_value=1e-3,\n    leakage_cost=10.0\n)\n\nqcp = SmoothPulseProblem(qtraj, N; piccolo_options=opts)","category":"section"},{"location":"generated/concepts/objectives/#Using-Objectives-in-Problem-Templates","page":"Objectives","title":"Using Objectives in Problem Templates","text":"Problem templates automatically set up objectives. You typically don't create them manually.","category":"section"},{"location":"generated/concepts/objectives/#Automatic-Setup","page":"Objectives","title":"Automatic Setup","text":"Let's see how the key parameters affect optimization:\n\nusing Piccolo\n\n# Set up a system\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nU_goal = GATES[:X]\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# SmoothPulseProblem automatically creates:\n# - UnitaryInfidelityObjective (for UnitaryTrajectory)\n# - QuadraticRegularizer for :u, :du, :ddu\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,      # Fidelity weight\n    R_u = 1e-3,     # Control regularization\n    R_du = 1e-2,    # First derivative regularization\n    R_ddu = 1e-2,   # Second derivative regularization\n)\ncached_solve!(qcp, \"objectives_example\"; max_iter = 50)\nfidelity(qcp)","category":"section"},{"location":"generated/concepts/objectives/#Trajectory-Dependent-Objectives","page":"Objectives","title":"Trajectory-Dependent Objectives","text":"The objective type is chosen based on the trajectory:\n\nTrajectory Type Default Objective\nUnitaryTrajectory UnitaryInfidelityObjective\nKetTrajectory KetInfidelityObjective\nMultiKetTrajectory CoherentKetInfidelityObjective","category":"section"},{"location":"generated/concepts/objectives/#Objective-Weights","page":"Objectives","title":"Objective Weights","text":"","category":"section"},{"location":"generated/concepts/objectives/#The-Q-Parameter","page":"Objectives","title":"The Q Parameter","text":"Q weights the fidelity objective:\n\nHigher Q (e.g., 1000): Prioritize fidelity over smoothness\nLower Q (e.g., 10): Allow more flexibility in controls","category":"section"},{"location":"generated/concepts/objectives/#The-R-Parameters","page":"Objectives","title":"The R Parameters","text":"R, R_u, R_du, R_ddu weight regularization:\n\nHigher R: Smoother, smaller controls\nLower R: More aggressive controls allowed","category":"section"},{"location":"generated/concepts/objectives/#Balancing-Trade-offs","page":"Objectives","title":"Balancing Trade-offs","text":"Let's compare different weight settings:\n\n# High fidelity weight\nqcp_high_Q =\n    SmoothPulseProblem(UnitaryTrajectory(sys, pulse, U_goal), N; Q = 1000.0, R = 1e-2)\ncached_solve!(qcp_high_Q, \"objectives_high_Q\"; max_iter = 100)\nfidelity(qcp_high_Q)\n\nHigh regularization\n\nqcp_high_R =\n    SmoothPulseProblem(UnitaryTrajectory(sys, pulse, U_goal), N; Q = 100.0, R = 0.1)\ncached_solve!(qcp_high_R, \"objectives_high_R\"; max_iter = 100)\nfidelity(qcp_high_R)","category":"section"},{"location":"generated/concepts/objectives/#Typical-Starting-Values","page":"Objectives","title":"Typical Starting Values","text":"Parameter Typical Range Starting Point\nQ 10 - 10000 100\nR 1e-6 - 1.0 1e-2\nR_u same as R R\nR_du same as R R\nR_ddu same as R R","category":"section"},{"location":"generated/concepts/objectives/#Best-Practices","page":"Objectives","title":"Best Practices","text":"","category":"section"},{"location":"generated/concepts/objectives/#1.-Start-with-Defaults","page":"Objectives","title":"1. Start with Defaults","text":"Problem templates have sensible defaults. Start there:\n\nqcp = SmoothPulseProblem(qtraj, N)  # Uses Q=100, R=1e-2","category":"section"},{"location":"generated/concepts/objectives/#2.-Tune-Q-First","page":"Objectives","title":"2. Tune Q First","text":"If fidelity is too low, increase Q.","category":"section"},{"location":"generated/concepts/objectives/#3.-Tune-R-if-Controls-are-Problematic","page":"Objectives","title":"3. Tune R if Controls are Problematic","text":"If controls are too noisy or large, increase R.","category":"section"},{"location":"generated/concepts/objectives/#4.-Use-Per-Derivative-Tuning-for-Fine-Control","page":"Objectives","title":"4. Use Per-Derivative Tuning for Fine Control","text":"qcp = SmoothPulseProblem(\n    qtraj, N;\n    R_u=1e-4,    # Allow larger control values\n    R_du=1e-2,   # Penalize jumps moderately\n    R_ddu=0.1    # Strongly penalize acceleration\n)","category":"section"},{"location":"generated/concepts/objectives/#See-Also","page":"Objectives","title":"See Also","text":"Constraints - Hard constraints on solutions\nProblem Templates - How objectives are used\nSmoothPulseProblem - Parameter reference\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/getting-started/concepts/#getting-started-concepts","page":"Core Concepts","title":"Core Concepts","text":"This page introduces the fundamental concepts in Piccolo.jl. For detailed documentation, see the Concepts section.","category":"section"},{"location":"generated/getting-started/concepts/#The-Quantum-Optimal-Control-Problem","page":"Core Concepts","title":"The Quantum Optimal Control Problem","text":"Quantum optimal control finds control pulses that steer a quantum system to achieve a desired outcome. In Piccolo.jl, this means:\n\nDefine a system: What physical hardware are you controlling?\nSpecify a goal: What gate or state do you want to achieve?\nOptimize controls: Find pulse shapes that achieve the goal","category":"section"},{"location":"generated/getting-started/concepts/#Key-Objects","page":"Core Concepts","title":"Key Objects","text":"","category":"section"},{"location":"generated/getting-started/concepts/#QuantumSystem","page":"Core Concepts","title":"QuantumSystem","text":"A QuantumSystem represents the physical hardware:\n\nusing Piccolo\n\n# Hamiltonian: H(t) = H_drift + u‚ÇÅ(t)¬∑H_drive‚ÇÅ + u‚ÇÇ(t)¬∑H_drive‚ÇÇ\nH_drift = PAULIS[:Z]            # Always-on term\nH_drives = [PAULIS[:X], PAULIS[:Y]]  # Controllable terms\ndrive_bounds = [1.0, 1.0]       # Maximum control amplitudes\n\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)","category":"section"},{"location":"generated/getting-started/concepts/#Pulse","page":"Core Concepts","title":"Pulse","text":"A Pulse specifies how controls vary in time:\n\nT = 10.0   # Total duration\nN = 100    # Number of time points\ntimes = collect(range(0, T, length = N))\ncontrols = 0.1 * randn(2, N)  # Initial control values\n\npulse = ZeroOrderPulse(controls, times)","category":"section"},{"location":"generated/getting-started/concepts/#Trajectory","page":"Core Concepts","title":"Trajectory","text":"A Trajectory combines system, pulse, and goal:\n\nU_goal = GATES[:X]  # Target: X gate\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)","category":"section"},{"location":"generated/getting-started/concepts/#QuantumControlProblem","page":"Core Concepts","title":"QuantumControlProblem","text":"A QuantumControlProblem sets up the optimization:\n\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0, R = 1e-2)","category":"section"},{"location":"generated/getting-started/concepts/#The-Workflow","page":"Core Concepts","title":"The Workflow","text":"The typical Piccolo.jl workflow follows these steps:\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Define System   ‚îÇ  sys = QuantumSystem(...)\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚îÇ\n         ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Create Pulse    ‚îÇ  pulse = ZeroOrderPulse(...)\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚îÇ\n         ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Set Goal        ‚îÇ  qtraj = UnitaryTrajectory(sys, pulse, U_goal)\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚îÇ\n         ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Create Problem  ‚îÇ  qcp = SmoothPulseProblem(qtraj, N)\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚îÇ\n         ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Solve!          ‚îÇ  solve!(qcp; max_iter=100)\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚îÇ\n         ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Analyze Results ‚îÇ  fidelity(qcp), plot(...)\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\nLet's run through the solve step now:\n\ncached_solve!(qcp, \"concepts_basic\"; max_iter = 100)\nfidelity(qcp)","category":"section"},{"location":"generated/getting-started/concepts/#Key-Parameters","page":"Core Concepts","title":"Key Parameters","text":"","category":"section"},{"location":"generated/getting-started/concepts/#Fidelity-Weight-(Q)","page":"Core Concepts","title":"Fidelity Weight (Q)","text":"Q controls how much the optimizer prioritizes achieving high fidelity:\n\nQ = 100 (default): Good balance\nQ = 1000: Strongly prioritize fidelity\nQ = 10: Allow more flexibility","category":"section"},{"location":"generated/getting-started/concepts/#Regularization-(R)","page":"Core Concepts","title":"Regularization (R)","text":"R controls pulse smoothness:\n\nR = 1e-2 (default): Moderate smoothness\nR = 0.1: Very smooth pulses\nR = 1e-4: Allow aggressive controls","category":"section"},{"location":"generated/getting-started/concepts/#Number-of-Timesteps-(N)","page":"Core Concepts","title":"Number of Timesteps (N)","text":"N is the discretization resolution:\n\nN = 50: Coarse, fast optimization\nN = 100: Typical\nN = 200+: Fine control, slower","category":"section"},{"location":"generated/getting-started/concepts/#Common-Patterns","page":"Core Concepts","title":"Common Patterns","text":"","category":"section"},{"location":"generated/getting-started/concepts/#Gate-Synthesis","page":"Core Concepts","title":"Gate Synthesis","text":"Most common use case ‚Äî synthesize a quantum gate:\n\nqcp_gate = SmoothPulseProblem(UnitaryTrajectory(sys, pulse, GATES[:X]), N)\ncached_solve!(qcp_gate, \"concepts_gate\"; max_iter = 100)\nfidelity(qcp_gate)","category":"section"},{"location":"generated/getting-started/concepts/#State-Preparation","page":"Core Concepts","title":"State Preparation","text":"Prepare a specific quantum state:\n\nœà_init = ComplexF64[1.0, 0.0]  # |0‚ü©\nœà_goal = ComplexF64[0.0, 1.0]  # |1‚ü©\nqcp_state = SmoothPulseProblem(KetTrajectory(sys, pulse, œà_init, œà_goal), N)\ncached_solve!(qcp_state, \"concepts_state\"; max_iter = 100)\nfidelity(qcp_state)","category":"section"},{"location":"generated/getting-started/concepts/#Time-Optimal-Control","page":"Core Concepts","title":"Time-Optimal Control","text":"Find the shortest gate duration:\n\nqcp_base = SmoothPulseProblem(qtraj, N; Œît_bounds = (0.01, 0.5))\ncached_solve!(qcp_base, \"concepts_base_freetime\"; max_iter = 100)\n\nqcp_fast = MinimumTimeProblem(qcp_base; final_fidelity = 0.99)\ncached_solve!(qcp_fast, \"concepts_fast\"; max_iter = 100)\nfidelity(qcp_fast)","category":"section"},{"location":"generated/getting-started/concepts/#Robust-Control","page":"Core Concepts","title":"Robust Control","text":"Optimize for parameter uncertainty:\n\n# Create perturbed systems\nsys_low = QuantumSystem(0.9 * H_drift, H_drives, drive_bounds)\nsys_nominal = sys\nsys_high = QuantumSystem(1.1 * H_drift, H_drives, drive_bounds)\n\n# Solve for nominal system first\nqcp_nom = SmoothPulseProblem(qtraj, N)\ncached_solve!(qcp_nom, \"concepts_nominal\"; max_iter = 100)\n\n# Add robustness\nperturbed_systems = [sys_low, sys_nominal, sys_high]\nqcp_robust = SamplingProblem(qcp_nom, perturbed_systems)\ncached_solve!(qcp_robust, \"concepts_robust\"; max_iter = 100)\nfidelity(qcp_robust)","category":"section"},{"location":"generated/getting-started/concepts/#Next-Steps","page":"Core Concepts","title":"Next Steps","text":"Quickstart: Run your first optimization\nProblem Templates: Learn the main API\nTutorials: Step-by-step examples\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/guides/global_variables/#global-variables","page":"Global Variables","title":"Global Variables","text":"Global variables allow you to optimize system parameters alongside control pulses. This is useful for calibrating system properties or finding optimal operating points.","category":"section"},{"location":"generated/guides/global_variables/#When-to-Use-Global-Variables","page":"Global Variables","title":"When to Use Global Variables","text":"System calibration: Finding optimal qubit frequencies or coupling strengths\nGate design: Optimizing hardware parameters for better gates\nSensitivity analysis: Understanding parameter effects","category":"section"},{"location":"generated/guides/global_variables/#Basic-Concept","page":"Global Variables","title":"Basic Concept","text":"Standard optimization only varies control pulses u(t). With global variables, you can also optimize system parameters that appear in the Hamiltonian.\n\nH(u t theta) = H_textdrift(theta) + sum_i u_i(t) H_textdrivei(theta)\n\nWhere theta are global parameters to optimize.","category":"section"},{"location":"generated/guides/global_variables/#Setup-Requirements","page":"Global Variables","title":"Setup Requirements","text":"Global variable optimization requires:\n\nA QuantumSystem with global_params\nA custom integrator that supports globals (e.g., from Piccolissimo)\nGlobal bounds specification\n\nPiccolo's built-in BilinearIntegrator does not support global variables ‚Äî it has no global-aware Jacobian columns or Hessian blocks. A custom integrator from Piccolissimo handles the extended control vector [controls..., globals...] and provides the correct derivative information to the optimizer.\n\nThis guide demonstrates the global variable API using Piccolo's built-in integrator. The globals are stored in the trajectory and bounded, but are not coupled to the dynamics. For full global optimization, use a Piccolissimo integrator.","category":"section"},{"location":"generated/guides/global_variables/#Defining-a-System-with-Global-Parameters","page":"Global Variables","title":"Defining a System with Global Parameters","text":"Global parameters are stored on the QuantumSystem via the global_params keyword argument. With a custom integrator from Piccolissimo, the Hamiltonian function receives u = [controls..., globals...]:\n\n## Function-based system (requires Piccolissimo integrator for dynamics)\nH = (u, t) -> u[3] * PAULIS[:Z] + u[1] * PAULIS[:X] + u[2] * PAULIS[:Y]\nsys = QuantumSystem(H, [1.0, 1.0]; time_dependent=true, global_params=(Œ¥=0.5,))\n\nFor this guide we use a matrix-based system, which works with the built-in BilinearIntegrator:\n\nusing Piccolo\n\nsys = QuantumSystem(\n    PAULIS[:Z],\n    [PAULIS[:X], PAULIS[:Y]],\n    [1.0, 1.0];\n    global_params = (Œ¥ = 0.5,),\n)\n\nsys.global_params","category":"section"},{"location":"generated/guides/global_variables/#Setting-Up-a-Problem-with-Globals","page":"Global Variables","title":"Setting Up a Problem with Globals","text":"When global_params is set on the system, SmoothPulseProblem automatically includes the global variables in the trajectory as optimization variables. The global_bounds keyword constrains their range:\n\nT = 10.0\nN = 50\nU_goal = GATES[:X]\n\nqtraj = UnitaryTrajectory(sys, U_goal, T)\n\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    R = 1e-2,\n    global_bounds = Dict(:Œ¥ => 1.0),  ## symmetric bounds: Œ¥ ‚àà [Œ¥‚ÇÄ - 1.0, Œ¥‚ÇÄ + 1.0]\n)\n\ncached_solve!(\n    qcp,\n    \"global_variables_single\";\n    max_iter = 100,\n    verbose = false,\n    print_level = 1,\n)","category":"section"},{"location":"generated/guides/global_variables/#Accessing-Global-Variables","page":"Global Variables","title":"Accessing Global Variables","text":"After solving, global values are stored in the trajectory's global_data vector, indexed by global_components:\n\ntraj = get_trajectory(qcp)\noptimized_Œ¥ = traj.global_data[traj.global_components[:Œ¥]][1]\noptimized_Œ¥\n\nnote: Note\nWith the built-in BilinearIntegrator, the global variable is not coupled to the dynamics, so its value will remain near the initial value. To actually optimize globals through the Hamiltonian, use a Piccolissimo integrator that provides global-aware Jacobians and Hessians.","category":"section"},{"location":"generated/guides/global_variables/#Global-Bounds-Format","page":"Global Variables","title":"Global Bounds Format","text":"Global bounds can be specified in two ways:\n\nSymmetric bounds (scalar): applied as ¬±value around the initial value.\n\nglobal_bounds = Dict(:Œ¥ => 0.05)  # Œ¥ ‚àà [Œ¥‚ÇÄ - 0.05, Œ¥‚ÇÄ + 0.05]\n\nAsymmetric bounds (tuple): explicit (lower, upper) bounds.\n\nglobal_bounds = Dict(:Œ¥ => (0.05, 0.2))  # Œ¥ ‚àà [0.05, 0.2]\n\nMultiple globals with mixed bound types:\n\nglobal_bounds = Dict(\n    :Œ¥ => (0.05, 0.2),\n    :J => 0.01,  # J ‚àà [J‚ÇÄ - 0.01, J‚ÇÄ + 0.01]\n)","category":"section"},{"location":"generated/guides/global_variables/#Multiple-Global-Variables","page":"Global Variables","title":"Multiple Global Variables","text":"You can define several system parameters simultaneously:\n\nsys_multi =\n    QuantumSystem(PAULIS[:Z], [PAULIS[:X]], [1.0]; global_params = (œâ = 1.0, J = 0.05))\n\nqtraj_multi = UnitaryTrajectory(sys_multi, U_goal, T)\n\nqcp_multi = SmoothPulseProblem(\n    qtraj_multi,\n    N;\n    Q = 100.0,\n    R = 1e-2,\n    global_bounds = Dict(:œâ => (0.9, 1.1), :J => (0.02, 0.1)),\n)\n\ncached_solve!(\n    qcp_multi,\n    \"global_variables_multi\";\n    max_iter = 100,\n    verbose = false,\n    print_level = 1,\n)\n\n# Access optimized global values\ntraj_multi = get_trajectory(qcp_multi)\noptimized_global_data = traj_multi.global_data\n(optimized_global_data)","category":"section"},{"location":"generated/guides/global_variables/#Best-Practices","page":"Global Variables","title":"Best Practices","text":"","category":"section"},{"location":"generated/guides/global_variables/#1.-Start-with-Good-Initial-Values","page":"Global Variables","title":"1. Start with Good Initial Values","text":"Use physically reasonable initial parameters. The initial values come from global_params in the QuantumSystem constructor:\n\nsys = QuantumSystem(H_drift, H_drives, bounds; global_params = (Œ¥ = 0.15,))","category":"section"},{"location":"generated/guides/global_variables/#2.-Use-Reasonable-Bounds","page":"Global Variables","title":"2. Use Reasonable Bounds","text":"Don't make bounds too wide ‚Äî ~50% variation is usually sufficient:\n\nglobal_bounds = Dict(:Œ¥ => (0.1, 0.2))  # Not 10x variation","category":"section"},{"location":"generated/guides/global_variables/#3.-Consider-Sensitivity","page":"Global Variables","title":"3. Consider Sensitivity","text":"Global parameters affect all timesteps, so they have strong influence on the solution. Start with tighter bounds and relax if needed.","category":"section"},{"location":"generated/guides/global_variables/#4.-Verify-Physical-Meaning","page":"Global Variables","title":"4. Verify Physical Meaning","text":"After optimization, check that global values are physically reasonable:","category":"section"},{"location":"generated/guides/global_variables/#Comparison-with-SamplingProblem","page":"Global Variables","title":"Comparison with SamplingProblem","text":"Feature Global Variables SamplingProblem\nParameter role Optimized Fixed (sampled)\nGoal Find optimal parameter Robust to parameter variation\nUse case Calibration, design Uncertainty handling\n\nFor robustness to uncertainty, use SamplingProblem. For finding optimal parameters, use global variables.","category":"section"},{"location":"generated/guides/global_variables/#Limitations","page":"Global Variables","title":"Limitations","text":"Full global optimization requires a custom integrator from Piccolissimo that provides global-aware Jacobians and Hessians\nPiccolo's built-in BilinearIntegrator stores globals in the trajectory but does not couple them to the dynamics\nMore complex optimization landscape\nConvergence can be slower","category":"section"},{"location":"generated/guides/global_variables/#See-Also","page":"Global Variables","title":"See Also","text":"SamplingProblem - For parameter robustness\nQuantum Systems - System construction\nProblem Templates - Main optimization API\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/concepts/isomorphisms/#isomorphisms-concept","page":"Isomorphisms","title":"Isomorphisms","text":"Piccolo.jl uses real isomorphisms to convert complex quantum states and operators into real vectors suitable for numerical optimization.","category":"section"},{"location":"generated/concepts/isomorphisms/#Why-Isomorphisms?","page":"Isomorphisms","title":"Why Isomorphisms?","text":"Optimization algorithms work with real numbers. Quantum states and unitaries are complex, so we need to:\n\nConvert complex objects to real vectors for optimization\nConvert back to complex form for physics calculations","category":"section"},{"location":"generated/concepts/isomorphisms/#State-Isomorphisms","page":"Isomorphisms","title":"State Isomorphisms","text":"","category":"section"},{"location":"generated/concepts/isomorphisms/#Ket-States","page":"Isomorphisms","title":"Ket States","text":"A complex ket state |œà‚ü© is converted to a real vector:\n\nusing Piccolo\nusing LinearAlgebra\n\n# Complex ket\nœà = ComplexF64[1, im] / ‚àö2\n\n# Convert to isomorphic form\nœàÃÉ = ket_to_iso(œà)\n\n# Convert back\nœà_recovered = iso_to_ket(œàÃÉ)\nœà ‚âà œà_recovered","category":"section"},{"location":"generated/concepts/isomorphisms/#Mathematical-Form","page":"Isomorphisms","title":"Mathematical Form","text":"psirangle = beginpmatrix a + ib  c + id endpmatrix\nquadrightarrowquad\ntildepsi = beginpmatrix a  c  b  d endpmatrix\n\nThe isomorphism stacks real parts followed by imaginary parts.","category":"section"},{"location":"generated/concepts/isomorphisms/#Operator-Isomorphisms","page":"Isomorphisms","title":"Operator Isomorphisms","text":"","category":"section"},{"location":"generated/concepts/isomorphisms/#Unitary-Operators","page":"Isomorphisms","title":"Unitary Operators","text":"Unitary matrices are vectorized and converted to real form:\n\n# Complex unitary\nU = GATES[:H]  # Hadamard\nU\n\n# Convert to isomorphic vector\n≈® = operator_to_iso_vec(U)\nlength(≈®)\n\n# Convert back\nU_recovered = iso_vec_to_operator(≈®)\nU ‚âà U_recovered","category":"section"},{"location":"generated/concepts/isomorphisms/#Mathematical-Form-2","page":"Isomorphisms","title":"Mathematical Form","text":"The unitary U is first vectorized (column-major) then split into real and imaginary parts:\n\nU = beginpmatrix U_11  U_12  U_21  U_22 endpmatrix\nrightarrow\ntextvec(U) = beginpmatrix U_11  U_21  U_12  U_22 endpmatrix\nrightarrow\ntildeU = beginpmatrix textRe(textvec(U))  textIm(textvec(U)) endpmatrix","category":"section"},{"location":"generated/concepts/isomorphisms/#Using-Isomorphisms-in-Practice","page":"Isomorphisms","title":"Using Isomorphisms in Practice","text":"","category":"section"},{"location":"generated/concepts/isomorphisms/#Accessing-Trajectory-Data","page":"Isomorphisms","title":"Accessing Trajectory Data","text":"Trajectories store isomorphic states. Let's solve a problem and inspect:\n\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nU_goal = GATES[:X]\n\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0)\ncached_solve!(qcp, \"isomorphisms_example\"; max_iter = 50)\nfidelity(qcp)","category":"section"},{"location":"generated/concepts/isomorphisms/#Inspecting-Isomorphic-State","page":"Isomorphisms","title":"Inspecting Isomorphic State","text":"traj = get_trajectory(qcp)\n\n# Isomorphic unitary at final timestep\n≈®_final = traj[:≈®‚Éó][:, end]\nlength(≈®_final)\n\n# Convert to complex unitary\nU_final = iso_vec_to_operator(≈®_final)\nsize(U_final)","category":"section"},{"location":"generated/concepts/isomorphisms/#Computing-Fidelity-Manually","page":"Isomorphisms","title":"Computing Fidelity Manually","text":"d = size(U_goal, 1)\nF = abs(tr(U_goal' * U_final))^2 / d^2\nF","category":"section"},{"location":"generated/concepts/isomorphisms/#Function-Reference","page":"Isomorphisms","title":"Function Reference","text":"","category":"section"},{"location":"generated/concepts/isomorphisms/#Ket-Conversions","page":"Isomorphisms","title":"Ket Conversions","text":"Function Description\nket_to_iso(œà) Complex ket ‚Üí real vector\niso_to_ket(œàÃÉ) Real vector ‚Üí complex ket","category":"section"},{"location":"generated/concepts/isomorphisms/#Operator-Conversions","page":"Isomorphisms","title":"Operator Conversions","text":"Function Description\noperator_to_iso_vec(U) Complex operator ‚Üí real vector\niso_vec_to_operator(≈®) Real vector ‚Üí complex operator","category":"section"},{"location":"generated/concepts/isomorphisms/#Variable-Naming-Convention","page":"Isomorphisms","title":"Variable Naming Convention","text":"Piccolo.jl uses a tilde notation to distinguish isomorphic variables:\n\nPhysical Isomorphic Meaning\nœà œàÃÉ Ket state\nU ≈® Unitary operator\nœÅ œÅÃÉ Density matrix\n\nIn trajectories:\n\n:œàÃÉ - Isomorphic ket state\n:≈®‚Éó - Isomorphic vectorized unitary\n:œÅÃÉ - Isomorphic vectorized density matrix","category":"section"},{"location":"generated/concepts/isomorphisms/#Dimension-Reference","page":"Isomorphisms","title":"Dimension Reference","text":"For a system with d levels:\n\nObject Complex Dimension Isomorphic Dimension\nKet |œà‚ü© d complex 2d real\nUnitary U d√ód complex 2d¬≤ real\nDensity œÅ d√ód complex 2d¬≤ real\n\n# Verify dimensions for a 2-level system\nd = 2\nlength(ket_to_iso(zeros(ComplexF64, d)))           ## 2d real elements\n\nlength(operator_to_iso_vec(zeros(ComplexF64, d, d))) ## 2d¬≤ real elements","category":"section"},{"location":"generated/concepts/isomorphisms/#See-Also","page":"Isomorphisms","title":"See Also","text":"Trajectories - How isomorphisms are used in trajectories\nOperators - Working with quantum operators\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/problem-templates/composition/#composition","page":"Composing Templates","title":"Composing Templates","text":"Problem templates in Piccolo.jl are designed to be composable. You can chain them together to build sophisticated optimization pipelines that combine multiple capabilities.","category":"section"},{"location":"generated/problem-templates/composition/#Composition-Overview","page":"Composing Templates","title":"Composition Overview","text":"The templates form a hierarchy:\n\nBase Problems (create from trajectory):\n‚îú‚îÄ‚îÄ SmoothPulseProblem\n‚îî‚îÄ‚îÄ SplinePulseProblem\n        ‚îÇ\n        ‚ñº\nWrapper Problems (wrap existing problem):\n‚îú‚îÄ‚îÄ SamplingProblem (adds robustness)\n‚îî‚îÄ‚îÄ MinimumTimeProblem (adds time optimization)\n\nAny wrapper can wrap another wrapper, enabling combinations like:\n\nMinimumTimeProblem(SamplingProblem(SmoothPulseProblem(...)))\nMinimumTimeProblem(SplinePulseProblem(...))","category":"section"},{"location":"generated/problem-templates/composition/#Full-Pipeline-Example","page":"Composing Templates","title":"Full Pipeline Example","text":"Here's a complete pipeline: base optimization ‚Üí robust optimization ‚Üí time-optimal control.\n\nusing Piccolo","category":"section"},{"location":"generated/problem-templates/composition/#Step-1:-Setup","page":"Composing Templates","title":"Step 1: Setup","text":"# Define nominal system\nH_drift = 0.5 * PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys_nominal = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n# Create initial trajectory\nT, N = 20.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys_nominal, pulse, GATES[:X])","category":"section"},{"location":"generated/problem-templates/composition/#Step-2:-Base-Problem-(with-free-time-enabled)","page":"Composing Templates","title":"Step 2: Base Problem (with free time enabled)","text":"qcp_base = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    R = 1e-2,\n    Œît_bounds = (0.05, 0.5),  ## Required for MinimumTimeProblem\n)\ncached_solve!(qcp_base, \"composition_base\"; max_iter = 100)\n\nfidelity(qcp_base)\n\nsum(get_timesteps(get_trajectory(qcp_base)))","category":"section"},{"location":"generated/problem-templates/composition/#Step-3:-Add-Robustness","page":"Composing Templates","title":"Step 3: Add Robustness","text":"# Create perturbed systems (¬±5% drift variation)\nsys_high = QuantumSystem(1.05 * H_drift, H_drives, [1.0, 1.0])\nsys_low = QuantumSystem(0.95 * H_drift, H_drives, [1.0, 1.0])\n\nqcp_robust = SamplingProblem(qcp_base, [sys_nominal, sys_high, sys_low]; Q = 100.0)\ncached_solve!(qcp_robust, \"composition_robust\"; max_iter = 100)\n\nfidelity(qcp_robust)","category":"section"},{"location":"generated/problem-templates/composition/#Step-4:-Minimize-Time","page":"Composing Templates","title":"Step 4: Minimize Time","text":"qcp_mintime = MinimumTimeProblem(qcp_robust; final_fidelity = 0.95, D = 100.0)\ncached_solve!(qcp_mintime, \"composition_mintime\"; max_iter = 100)\n\nfidelity(qcp_mintime)\n\nsum(get_timesteps(get_trajectory(qcp_mintime)))","category":"section"},{"location":"generated/problem-templates/composition/#Common-Composition-Patterns","page":"Composing Templates","title":"Common Composition Patterns","text":"","category":"section"},{"location":"generated/problem-templates/composition/#Pattern-1:-Robust-Gate","page":"Composing Templates","title":"Pattern 1: Robust Gate","text":"Optimize for parameter uncertainty without time constraints.\n\nqcp_base = SmoothPulseProblem(qtraj, N; Q=100.0)\nsolve!(qcp_base)\n\nqcp_robust = SamplingProblem(qcp_base, systems)\nsolve!(qcp_robust)","category":"section"},{"location":"generated/problem-templates/composition/#Pattern-2:-Fast-Gate","page":"Composing Templates","title":"Pattern 2: Fast Gate","text":"Minimize time without robustness requirements.\n\nqcp_base = SmoothPulseProblem(qtraj, N; Q=100.0, Œît_bounds=(0.01, 0.5))\nsolve!(qcp_base)\n\nqcp_fast = MinimumTimeProblem(qcp_base; final_fidelity=0.99)\nsolve!(qcp_fast)","category":"section"},{"location":"generated/problem-templates/composition/#Pattern-3:-Fast-Robust-Gate","page":"Composing Templates","title":"Pattern 3: Fast + Robust Gate","text":"The full pipeline for production-quality gates.\n\nqcp_base = SmoothPulseProblem(qtraj, N; Q=100.0, Œît_bounds=(0.01, 0.5))\nsolve!(qcp_base)\n\nqcp_robust = SamplingProblem(qcp_base, systems)\nsolve!(qcp_robust)\n\nqcp_final = MinimumTimeProblem(qcp_robust; final_fidelity=0.95)\nsolve!(qcp_final)","category":"section"},{"location":"generated/problem-templates/composition/#Pattern-4:-Spline-Warm-Start-Pipeline","page":"Composing Templates","title":"Pattern 4: Spline Warm-Start Pipeline","text":"Start with smooth problem, refine with splines.\n\n# Initial optimization with piecewise constant\nqcp_smooth = SmoothPulseProblem(qtraj_smooth, N; Q=100.0)\nsolve!(qcp_smooth)\n\n# Extract optimized pulse and convert to spline\noptimized_pulse = get_pulse(qcp_smooth.qtraj)\nspline_pulse = CubicSplinePulse(optimized_pulse)\nqtraj_spline = UnitaryTrajectory(sys, spline_pulse, U_goal)\n\n# Refine with spline problem\nqcp_spline = SplinePulseProblem(qtraj_spline; Q=100.0)\nsolve!(qcp_spline; max_iter=50)  # Quick refinement","category":"section"},{"location":"generated/problem-templates/composition/#Iteration-and-Refinement","page":"Composing Templates","title":"Iteration and Refinement","text":"You can iteratively refine solutions:\n\n# First pass: coarse optimization\nqcp = SmoothPulseProblem(qtraj, 50; Q=10.0)\nsolve!(qcp; max_iter=50)\n\n# Second pass: increase resolution\n# ... resample to higher N ...\n\n# Third pass: tighten tolerances\nsolve!(qcp; max_iter=100, tol=1e-8)","category":"section"},{"location":"generated/problem-templates/composition/#Accessing-Results-Through-the-Chain","page":"Composing Templates","title":"Accessing Results Through the Chain","text":"Each wrapper preserves access to the underlying trajectory:\n\n# Access trajectory at any level\ntraj = get_trajectory(qcp_mintime)\nsys = get_system(qcp_mintime)\n\n# Fidelity evaluation uses the innermost trajectory type\nfid = fidelity(qcp_mintime)\n\n# Get optimized pulse\npulse = get_pulse(qcp_mintime.qtraj)","category":"section"},{"location":"generated/problem-templates/composition/#Order-Matters","page":"Composing Templates","title":"Order Matters","text":"The order of composition affects the optimization:\n\nMinimumTimeProblem(SamplingProblem(base)):\n\nFirst achieves robustness, then minimizes time\nTime minimization respects the robust solution\nGenerally preferred for production gates\n\nSamplingProblem(MinimumTimeProblem(base)):\n\nFirst minimizes time, then adds robustness\nMay require re-solving if time-optimal solution isn't robust\nLess common, but useful for exploring trade-offs","category":"section"},{"location":"generated/problem-templates/composition/#Tips-for-Complex-Pipelines","page":"Composing Templates","title":"Tips for Complex Pipelines","text":"","category":"section"},{"location":"generated/problem-templates/composition/#1.-Solve-Each-Stage","page":"Composing Templates","title":"1. Solve Each Stage","text":"Always solve! after each composition step:\n\nqcp_base = SmoothPulseProblem(qtraj, N)\nsolve!(qcp_base)  # Important!\n\nqcp_robust = SamplingProblem(qcp_base, systems)\nsolve!(qcp_robust)  # Important!\n\nqcp_mintime = MinimumTimeProblem(qcp_robust)\nsolve!(qcp_mintime)  # Important!","category":"section"},{"location":"generated/problem-templates/composition/#2.-Monitor-Progress","page":"Composing Templates","title":"2. Monitor Progress","text":"Check fidelity at each stage to catch issues early:\n\nfor (name, prob) in [(\"Base\", qcp_base), (\"Robust\", qcp_robust), (\"MinTime\", qcp_mintime)]\n    println(\"$name: Fidelity = $(fidelity(prob))\")\nend","category":"section"},{"location":"generated/problem-templates/composition/#3.-Adjust-Parameters-at-Each-Stage","page":"Composing Templates","title":"3. Adjust Parameters at Each Stage","text":"Different stages may need different settings:\n\n# Base: prioritize finding a solution\nqcp_base = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2)\nsolve!(qcp_base; max_iter=200)\n\n# Robust: may need more iterations\nqcp_robust = SamplingProblem(qcp_base, systems; Q=100.0)\nsolve!(qcp_robust; max_iter=300)\n\n# MinTime: typically faster since starting from good solution\nqcp_mintime = MinimumTimeProblem(qcp_robust; final_fidelity=0.95, D=100.0)\nsolve!(qcp_mintime; max_iter=100)","category":"section"},{"location":"generated/problem-templates/composition/#See-Also","page":"Composing Templates","title":"See Also","text":"SmoothPulseProblem - Base problem template\nSplinePulseProblem - Spline-based base problem\nMinimumTimeProblem - Time optimization wrapper\nSamplingProblem - Robustness wrapper\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/quickstart/#quickstart","page":"Quickstart","title":"Quickstart Guide","text":"This guide shows you how to set up and solve a quantum optimal control problem in Piccolo.jl. We'll synthesize a single-qubit X gate.","category":"section"},{"location":"generated/quickstart/#The-Problem","page":"Quickstart","title":"The Problem","text":"We want to find control pulses that implement an X gate on a single qubit with system Hamiltonian:\n\nH(t) = fracomega2 sigma_z + u_1(t) sigma_x + u_2(t) sigma_y\n\nusing Piccolo","category":"section"},{"location":"generated/quickstart/#Step-1:-Define-the-Quantum-System","page":"Quickstart","title":"Step 1: Define the Quantum System","text":"First, we define our quantum system by specifying the drift Hamiltonian (always-on), the drive Hamiltonians (controllable), and the bounds on control amplitudes.\n\n# Drift Hamiltonian: qubit frequency term\nH_drift = 0.5 * PAULIS[:Z]\n\n# Drive Hamiltonians: X and Y controls\nH_drives = [PAULIS[:X], PAULIS[:Y]]\n\n# Maximum control amplitudes\ndrive_bounds = [1.0, 1.0]\n\n# Create the quantum system\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)","category":"section"},{"location":"generated/quickstart/#Step-2:-Create-an-Initial-Pulse","page":"Quickstart","title":"Step 2: Create an Initial Pulse","text":"We need an initial guess for the control pulse. ZeroOrderPulse represents piecewise constant controls.\n\n# Time parameters\nT = 10.0   # Total gate duration\nN = 100    # Number of timesteps\n\n# Create time vector\ntimes = collect(range(0, T, length = N))\n\n# Random initial controls (scaled by drive bounds)\ninitial_controls = 0.1 * randn(2, N)\n\n# Create the pulse\npulse = ZeroOrderPulse(initial_controls, times)","category":"section"},{"location":"generated/quickstart/#Step-3:-Define-the-Goal-via-a-Trajectory","page":"Quickstart","title":"Step 3: Define the Goal via a Trajectory","text":"A UnitaryTrajectory combines the system, pulse, and target gate.\n\n# Target: X gate\nU_goal = GATES[:X]\n\n# Create the trajectory\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)","category":"section"},{"location":"generated/quickstart/#Step-4:-Set-Up-the-Optimization-Problem","page":"Quickstart","title":"Step 4: Set Up the Optimization Problem","text":"SmoothPulseProblem creates the optimization problem with:\n\nFidelity objective (weight Q)\nRegularization for smooth controls (weight R)\nDerivative bounds for control smoothness\n\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,       # Fidelity weight\n    R = 1e-2,        # Regularization weight\n    ddu_bound = 1.0,  # Control acceleration bound\n)","category":"section"},{"location":"generated/quickstart/#Step-5:-Solve!","page":"Quickstart","title":"Step 5: Solve!","text":"cached_solve!(qcp, \"quickstart\"; max_iter = 20, verbose = false, print_level = 1)","category":"section"},{"location":"generated/quickstart/#Step-6:-Analyze-Results","page":"Quickstart","title":"Step 6: Analyze Results","text":"After solving, we can check the fidelity and examine the optimized controls.\n\n# Check final fidelity\nfidelity(qcp)\n\nAccess the trajectory and check the final unitary:\n\ntraj = get_trajectory(qcp)\nU_final = iso_vec_to_operator(traj[:≈®‚Éó][:, end])\nround.(U_final, digits = 3)","category":"section"},{"location":"generated/quickstart/#Visualization","page":"Quickstart","title":"Visualization","text":"Piccolo provides specialized plotting functions for quantum trajectories:\n\nusing CairoMakie\n\n# Plot the unitary evolution (state populations over time)\nfig = plot_unitary_populations(traj)","category":"section"},{"location":"generated/quickstart/#Minimum-Time-Optimization","page":"Quickstart","title":"Minimum Time Optimization","text":"Now let's find the shortest gate duration that achieves 99% fidelity.\n\nFirst, we need to create a new problem with variable timesteps enabled:\n\n# Create problem with free-time optimization\nqcp_free = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,\n    R = 1e-2,\n    ddu_bound = 1.0,\n    Œît_bounds = (0.01, 0.5),  # Enable variable timesteps\n)\ncached_solve!(\n    qcp_free,\n    \"quickstart_free_time\";\n    max_iter = 20,\n    verbose = false,\n    print_level = 1,\n)\n\n# Convert to minimum time problem\nqcp_mintime = MinimumTimeProblem(qcp_free; final_fidelity = 0.99)\ncached_solve!(\n    qcp_mintime,\n    \"quickstart_mintime\";\n    max_iter = 20,\n    verbose = false,\n    print_level = 1,\n)\n\nCompare durations:\n\ninitial_duration = sum(get_timesteps(get_trajectory(qcp_free)))\nminimum_duration = sum(get_timesteps(get_trajectory(qcp_mintime)))\n\ninitial_duration\n\nminimum_duration\n\nfidelity(qcp_mintime)\n\nPlot the time-optimal solution:\n\nfig_mintime = plot_unitary_populations(get_trajectory(qcp_mintime))","category":"section"},{"location":"generated/quickstart/#Next-Steps","page":"Quickstart","title":"Next Steps","text":"Learn about different Problem Templates for various optimization scenarios\nExplore Tutorials for more complex examples\nSee Concepts for detailed documentation of types and functions\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"","page":"Home","title":"Home","text":"<div align=\"center\">\n  <a href=\"https://github.com/harmoniqs/Piccolo.jl\">\n    <img src=\"assets/piccolo_logo.svg\" alt=\"Piccolo.jl\" width=\"25%\"/>\n  </a> \n</div>\n\n<div align=\"center\">\n  <table>\n    <tr>\n      <td align=\"center\">\n        <b>Documentation</b>\n        <br>\n        <a href=\"https://docs.harmoniqs.co/Piccolo/dev/\">\n          <img src=\"https://img.shields.io/badge/docs-stable-blue.svg\" alt=\"Stable\"/>\n        </a>\n        <a href=\"https://docs.harmoniqs.co/Piccolo/dev/\">\n          <img src=\"https://img.shields.io/badge/docs-dev-blue.svg\" alt=\"Dev\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Build Status</b>\n        <br>\n        <a href=\"https://github.com/harmoniqs/Piccolo.jl/actions/workflows/CI.yml?query=branch%3Amain\">\n          <img src=\"https://github.com/harmoniqs/Piccolo.jl/actions/workflows/CI.yml/badge.svg?branch=main\" alt=\"Build Status\"/>\n        </a>\n        <a href=\"https://codecov.io/gh/harmoniqs/Piccolo.jl\">\n          <img src=\"https://codecov.io/gh/harmoniqs/Piccolo.jl/branch/main/graph/badge.svg\" alt=\"Coverage\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>License</b>\n        <br>\n        <a href=\"https://opensource.org/licenses/MIT\">\n          <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"MIT License\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Support</b>\n        <br>\n        <a href=\"https://unitary.fund\">\n          <img src=\"https://img.shields.io/badge/Supported%20By-Unitary%20Fund-FFFF00.svg\" alt=\"Unitary Fund\"/>\n        </a>\n      </td>\n    </tr>\n  </table>\n</div>","category":"section"},{"location":"#Description","page":"Home","title":"Description","text":"Piccolo.jl is a meta-package for quantum optimal control using the Pade Integrator Collocation (Piccolo) method. This package reexports the following packages\n\nNamedTrajectories.jl\nTrajectoryIndexingUtils.jl\n\nFor documentation please see the individual packages.","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"Just run\n\nusing Piccolo","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"This package is registered! To install enter the Julia REPL, type ] to enter pkg mode, activate your environment activate, and then run \n\npkg> add Piccolo","category":"section"},{"location":"#Building-Documentation","page":"Home","title":"Building Documentation","text":"This package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility. \n\n# first time only\n./docs/get_docs_utils.sh   # or ./get_docs_utils.sh if cwd is in ./docs/\n\nTo build the docs pages:\n\njulia --project=docs docs/make.jl\n\nor editing the docs live:\n\njulia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"], skip_files=[\"docs/src/index.md\"])\n\nNote: servedocs needs to watch a subset of the files in the docs/ folder. If it watches files that are generated on a docs build/re-build, servedocs will continuously try to re-serve the pages.To prevent this, ensure all generated files are included in the skip dirs or skip files args for servedocs.\n\nFor example, if we forget index.md like so:\n\njulia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"])\n\nit will not build and serve.\n\n\n\n\"Technologies are ways of commandeering nature: the sky belongs to those who know how to fly; the sea belongs to those who know how to swim and navigate.\" ‚Äì Simone de Beauvoir","category":"section"},{"location":"generated/problem-templates/sampling/#sampling","page":"SamplingProblem","title":"SamplingProblem","text":"SamplingProblem enables robust optimization over multiple system variants with shared controls. This is essential for designing pulses that perform well despite parameter uncertainty or variation.","category":"section"},{"location":"generated/problem-templates/sampling/#When-to-Use","page":"SamplingProblem","title":"When to Use","text":"Use SamplingProblem when:\n\nYour system parameters have uncertainty (e.g., qubit frequency drift)\nYou need pulses robust to fabrication variations\nYou want to optimize across an ensemble of similar systems\nYou're designing calibration-free gates","category":"section"},{"location":"generated/problem-templates/sampling/#Key-Design:-Composition-Pattern","page":"SamplingProblem","title":"Key Design: Composition Pattern","text":"SamplingProblem wraps an existing QuantumControlProblem and extends it with multiple system variants:\n\n# Create base problem\nqcp_base = SmoothPulseProblem(qtraj, N; Q=100.0)\nsolve!(qcp_base; max_iter=100)\n\n# Create perturbed systems\nsys_nominal = get_system(qcp_base)\nsys_high = QuantumSystem(1.05 * H_drift, H_drives, drive_bounds)\nsys_low = QuantumSystem(0.95 * H_drift, H_drives, drive_bounds)\n\n# Robust optimization\nqcp_robust = SamplingProblem(qcp_base, [sys_nominal, sys_high, sys_low])\nsolve!(qcp_robust; max_iter=100)","category":"section"},{"location":"generated/problem-templates/sampling/#Constructor","page":"SamplingProblem","title":"Constructor","text":"SamplingProblem(\n    qcp::QuantumControlProblem,\n    systems::Vector{<:AbstractQuantumSystem};\n    weights = fill(1.0, length(systems)),\n    Q = 100.0,\n    piccolo_options = PiccoloOptions()\n)","category":"section"},{"location":"generated/problem-templates/sampling/#Parameter-Reference","page":"SamplingProblem","title":"Parameter Reference","text":"Parameter Type Default Description\nqcp QuantumControlProblem required Base problem providing trajectory structure\nsystems Vector{AbstractQuantumSystem} required System variants to optimize over\nweights Vector{Float64} fill(1.0, length(systems)) Relative importance of each system\nQ Float64 100.0 Infidelity weight (applied to all systems)\npiccolo_options PiccoloOptions PiccoloOptions() Solver options","category":"section"},{"location":"generated/problem-templates/sampling/#Optimization-Objective","page":"SamplingProblem","title":"Optimization Objective","text":"SamplingProblem creates a weighted sum of objectives:\n\nminimize: Œ£·µ¢ w·µ¢ √ó Q·µ¢ √ó (1 - F·µ¢) + regularization\n\nWhere:\n\nw·µ¢ is the weight for system i\nQ·µ¢ is the infidelity weight\nF·µ¢ is the fidelity for system i\n\nAll systems share the same control pulse, but each has its own state trajectory.","category":"section"},{"location":"generated/problem-templates/sampling/#Examples","page":"SamplingProblem","title":"Examples","text":"","category":"section"},{"location":"generated/problem-templates/sampling/#Robust-to-Frequency-Drift","page":"SamplingProblem","title":"Robust to Frequency Drift","text":"using Piccolo\n\n# Nominal system\nH_drift = 0.5 * PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys_nominal = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n# Create trajectory and base problem\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys_nominal, pulse, GATES[:X])\n\nqcp_base = SmoothPulseProblem(qtraj, N; Q = 100.0)\ncached_solve!(qcp_base, \"sampling_base\"; max_iter = 100)\n\n# ¬±5% frequency variation\nsys_high = QuantumSystem(1.05 * H_drift, H_drives, [1.0, 1.0])\nsys_low = QuantumSystem(0.95 * H_drift, H_drives, [1.0, 1.0])\n\n# Robust optimization\nqcp_robust =\n    SamplingProblem(qcp_base, [sys_nominal, sys_high, sys_low]; weights = [1.0, 1.0, 1.0])\ncached_solve!(qcp_robust, \"sampling_robust\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/sampling/#Weighted-Sampling","page":"SamplingProblem","title":"Weighted Sampling","text":"Prioritize certain parameter values:\n\nqcp_weighted = SamplingProblem(\n    qcp_base,\n    [sys_nominal, sys_high, sys_low];\n    weights = [2.0, 1.0, 1.0],  ## Nominal weighted 2x\n)\ncached_solve!(qcp_weighted, \"sampling_weighted\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/sampling/#Dense-Parameter-Sampling","page":"SamplingProblem","title":"Dense Parameter Sampling","text":"For smooth performance across a parameter range:\n\nscales = range(0.9, 1.1, length = 3)\nsystems = [QuantumSystem(s * H_drift, H_drives, [1.0, 1.0]) for s in scales]\n\nqcp_dense = SamplingProblem(qcp_base, systems)\ncached_solve!(qcp_dense, \"sampling_dense\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/sampling/#With-Time-Optimization","page":"SamplingProblem","title":"With Time Optimization","text":"Chain with MinimumTimeProblem:\n\n# Base problem with free time\nqcp_base = SmoothPulseProblem(qtraj, N; Q=100.0, Œît_bounds=(0.05, 0.5))\nsolve!(qcp_base; max_iter=100)\n\n# Add robustness\nqcp_robust = SamplingProblem(qcp_base, [sys_nominal, sys_high, sys_low])\nsolve!(qcp_robust; max_iter=100)\n\n# Minimize time\nqcp_mintime = MinimumTimeProblem(qcp_robust; final_fidelity=0.95)\nsolve!(qcp_mintime; max_iter=100)","category":"section"},{"location":"generated/problem-templates/sampling/#Trajectory-Structure","page":"SamplingProblem","title":"Trajectory Structure","text":"SamplingProblem creates a SamplingTrajectory internally with:\n\nVariable Description\n:u Shared control values\n:≈®‚Éó1, :≈®‚Éó2, ... State for each system (unitary case)\nor :œàÃÉ1, :œàÃÉ2, ... State for each system (ket case)\n\nNote: Derivative variables (:du, :ddu) from the base problem are not carried over. The robustness is achieved through multiple dynamics integrators, one per system.","category":"section"},{"location":"generated/problem-templates/sampling/#Difference-from-MultiKetTrajectory","page":"SamplingProblem","title":"Difference from MultiKetTrajectory","text":"These serve different purposes:\n\nFeature SamplingProblem MultiKetTrajectory\nSystems Multiple different systems Single system\nStates Same goal across systems Different initial/goal pairs\nUse case Parameter uncertainty Multi-state gates\n\nSamplingProblem: \"Same gate, different systems\" MultiKetTrajectory: \"Same system, different state transfers\"","category":"section"},{"location":"generated/problem-templates/sampling/#Evaluating-Robustness","page":"SamplingProblem","title":"Evaluating Robustness","text":"After solving, check fidelity across the parameter range:\n\n# Sample more densely for evaluation\neval_scales = range(0.8, 1.2, length=21)\neval_systems = [QuantumSystem(s * H_drift, H_drives, drive_bounds) for s in eval_scales]\n\n# Get optimized pulse\noptimized_pulse = get_pulse(qcp_robust.qtraj)\n\n# Evaluate\nfor (s, sys) in zip(eval_scales, eval_systems)\n    qtraj_eval = UnitaryTrajectory(sys, optimized_pulse, GATES[:X])\n    fid = fidelity(qtraj_eval)\n    println(\"Scale $s: Fidelity = $fid\")\nend","category":"section"},{"location":"generated/problem-templates/sampling/#See-Also","page":"SamplingProblem","title":"See Also","text":"SmoothPulseProblem - Base problem for piecewise constant controls\nMinimumTimeProblem - Minimize duration of robust pulses\nComposing Templates - Advanced composition patterns\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/guides/custom_objectives/#custom-objectives","page":"Custom Objectives","title":"Custom Objectives","text":"While Piccolo.jl provides standard objectives for fidelity and regularization, you may need custom objectives for specialized optimization goals. This guide shows how to create and use them.","category":"section"},{"location":"generated/guides/custom_objectives/#Setup","page":"Custom Objectives","title":"Setup","text":"We'll work with a simple single-qubit X gate problem:\n\nusing Piccolo\nusing DirectTrajOpt\nusing LinearAlgebra\nusing Random\nRandom.seed!(42)\n\n# Define system\nH_drift = 0.5 * PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\ndrive_bounds = [1.0, 1.0]\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\n\n# Create initial pulse and trajectory\nT = 10.0\nN = 50\ntimes = collect(range(0, T, length = N))\ninitial_controls = 0.1 * randn(2, N)\npulse = ZeroOrderPulse(initial_controls, times)\n\nU_goal = GATES[:X]\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)","category":"section"},{"location":"generated/guides/custom_objectives/#Objective-Types","page":"Custom Objectives","title":"Objective Types","text":"Piccolo uses two objective types from DirectTrajOpt.jl:\n\nType When Evaluated Constructor\nTerminalObjective At final timestep only TerminalObjective(loss, name, traj; Q=weight)\nKnotPointObjective At specified timesteps KnotPointObjective(loss, name, traj; Qs=weights)\n\nBoth take a loss function as their first argument ‚Äî a regular Julia function that maps a component vector to a scalar cost.","category":"section"},{"location":"generated/guides/custom_objectives/#Creating-a-Custom-Terminal-Objective","page":"Custom Objectives","title":"Creating a Custom Terminal Objective","text":"A terminal objective evaluates a loss function on a trajectory component at the final timestep. Let's create one that penalizes trace distance from the target:\n\n# Build the problem to get the internal NamedTrajectory\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0, R = 1e-2, ddu_bound = 1.0)\ntraj = get_trajectory(qcp)\n\n# Define a custom loss: trace distance penalty on the isomorphic unitary vector\ntrace_distance_loss(≈®‚Éó) =\n    let\n        U = iso_vec_to_operator(≈®‚Éó)\n        n = size(U, 1)\n        diff = U - U_goal\n        real(tr(diff' * diff)) / n\n    end\n\n# Wrap it in a TerminalObjective (evaluated on :≈®‚Éó at the final timestep)\ncustom_terminal_obj = TerminalObjective(trace_distance_loss, :≈®‚Éó, traj; Q = 50.0)","category":"section"},{"location":"generated/guides/custom_objectives/#Creating-a-Custom-Knotpoint-Objective","page":"Custom Objectives","title":"Creating a Custom Knotpoint Objective","text":"A knotpoint objective evaluates at every (or selected) timesteps. Let's penalize control energy:\n\n# Loss function: squared norm of control values\ncontrol_energy_loss(u) = dot(u, u)\n\n# Applied at all timesteps on the :u component\ncustom_knotpoint_obj =\n    KnotPointObjective(control_energy_loss, :u, traj; Qs = fill(0.1, N), times = 1:N)","category":"section"},{"location":"generated/guides/custom_objectives/#Adding-Custom-Objectives-to-a-Problem","page":"Custom Objectives","title":"Adding Custom Objectives to a Problem","text":"","category":"section"},{"location":"generated/guides/custom_objectives/#Building-the-objective-manually","page":"Custom Objectives","title":"Building the objective manually","text":"Combine objective terms with +:\n\n# Start with the standard infidelity objective\nJ = UnitaryInfidelityObjective(U_goal, :≈®‚Éó, traj; Q = 100.0)\n\n# Add standard regularization\nJ += QuadraticRegularizer(:u, traj, 1e-2)\nJ += QuadraticRegularizer(:du, traj, 1e-2)\nJ += QuadraticRegularizer(:ddu, traj, 1e-2)\n\n# Add our custom objective\nJ += custom_knotpoint_obj\n\ntypeof(J)","category":"section"},{"location":"generated/guides/custom_objectives/#Adding-to-an-existing-problem","page":"Custom Objectives","title":"Adding to an existing problem","text":"qcp = SmoothPulseProblem(qtraj, N; Q = 100.0, R = 1e-2, ddu_bound = 1.0)\nqcp.prob.objective += custom_knotpoint_obj","category":"section"},{"location":"generated/guides/custom_objectives/#Solving-and-Comparing","page":"Custom Objectives","title":"Solving and Comparing","text":"Solve with the extra control energy penalty:\n\ncached_solve!(\n    qcp,\n    \"custom_objectives_with_penalty\";\n    max_iter = 50,\n    verbose = false,\n    print_level = 1,\n)\nfidelity(qcp)\n\nCompare against the standard problem:\n\nqcp_standard = SmoothPulseProblem(qtraj, N; Q = 100.0, R = 1e-2, ddu_bound = 1.0)\ncached_solve!(\n    qcp_standard,\n    \"custom_objectives_standard\";\n    max_iter = 50,\n    verbose = false,\n    print_level = 1,\n)\nfidelity(qcp_standard)","category":"section"},{"location":"generated/guides/custom_objectives/#Example:-Leakage-Style-Penalty","page":"Custom Objectives","title":"Example: Leakage-Style Penalty","text":"Here's how the built-in LeakageObjective works under the hood ‚Äî it's just a KnotPointObjective with a custom loss function:\n\nleakage_indices = [3, 4]  # Indices of leakage states in the isomorphic vector\n\nleakage_loss(x) = sum(abs2, x[leakage_indices]) / length(leakage_indices)\n\nleakage_obj = KnotPointObjective(leakage_loss, :≈®‚Éó, traj; Qs = fill(1.0, N), times = 1:N)","category":"section"},{"location":"generated/guides/custom_objectives/#Tips-for-Custom-Objectives","page":"Custom Objectives","title":"Tips for Custom Objectives","text":"","category":"section"},{"location":"generated/guides/custom_objectives/#1.-Scale-Appropriately","page":"Custom Objectives","title":"1. Scale Appropriately","text":"Match the scale of built-in objectives:\n\nBuilt-in fidelity uses Q ~ 100\nCustom objectives should use similar magnitude\n\ncustom_obj = TerminalObjective(my_loss, :≈®‚Éó, traj; Q = 50.0)","category":"section"},{"location":"generated/guides/custom_objectives/#2.-Ensure-Smoothness","page":"Custom Objectives","title":"2. Ensure Smoothness","text":"Avoid discontinuities that can cause optimization issues:\n\n## Bad: discontinuous\npenalty = x > 0 ? x^2 : 0\n\n## Good: smooth approximation\npenalty = max(0, x)^2\n\n## Also good: softplus\npenalty = log(1 + exp(k * x)) / k","category":"section"},{"location":"generated/guides/custom_objectives/#3.-Test-Independently","page":"Custom Objectives","title":"3. Test Independently","text":"Verify your objective computes expected values:\n\n## Evaluate the full objective on a trajectory\nvalue = objective_value(custom_obj, traj)\nprintln(\"Objective value: \", value)\n\n## Check gradient\n‚àá = zeros(traj.dim * traj.N + traj.global_dim)\ngradient!(‚àá, custom_obj, traj)","category":"section"},{"location":"generated/guides/custom_objectives/#4.-Start-Simple","page":"Custom Objectives","title":"4. Start Simple","text":"Add custom objectives incrementally:\n\n## Step 1: Solve with standard objectives\nqcp = SmoothPulseProblem(qtraj, N)\nsolve!(qcp)\n\n## Step 2: Check if solution needs improvement\nprintln(\"Fidelity: \", fidelity(qcp))\n\n## Step 3: Add custom objective with small weight\ncustom_obj = KnotPointObjective(my_loss, :u, traj; Qs = fill(0.1, N))\nqcp.prob.objective += custom_obj\nsolve!(qcp)\n\n## Step 4: Increase weight if needed","category":"section"},{"location":"generated/guides/custom_objectives/#5.-Gradients-are-Automatic","page":"Custom Objectives","title":"5. Gradients are Automatic","text":"DirectTrajOpt uses ForwardDiff for automatic differentiation, so gradients are computed automatically for any loss function you provide. No need to implement gradient methods manually.","category":"section"},{"location":"generated/guides/custom_objectives/#See-Also","page":"Custom Objectives","title":"See Also","text":"Objectives - Built-in objectives\nConstraints - Hard constraints (vs soft objective penalties)\nProblem Templates - Using objectives in problems\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/guides/system_templates/#system-templates","page":"System Templates","title":"System Templates","text":"Piccolo.jl provides pre-built system templates for common physical platforms. These templates handle the Hamiltonian construction with physically meaningful parameters.","category":"section"},{"location":"generated/guides/system_templates/#Available-Templates","page":"System Templates","title":"Available Templates","text":"Template Physical System\nTransmonSystem Superconducting transmon qubits\nMultiTransmonSystem Multiple coupled transmons\nIonChainSystem Linear chain of trapped ions\nRadialMSGateSystem Molmer-Sorensen gates for ions\nRydbergChainSystem Rydberg atom arrays\nCatSystem Bosonic cat qubits in cavities","category":"section"},{"location":"generated/guides/system_templates/#TransmonSystem","page":"System Templates","title":"TransmonSystem","text":"For superconducting transmon qubits with anharmonicity.","category":"section"},{"location":"generated/guides/system_templates/#Basic-Usage","page":"System Templates","title":"Basic Usage","text":"using Piccolo\nusing LinearAlgebra\nusing Random\nRandom.seed!(42)\n\n# 3-level transmon with X and Y drives\nsys = TransmonSystem(\n    levels = 3,\n    Œ¥ = 0.2,                   # Anharmonicity (GHz)\n    drive_bounds = [0.2, 0.2],  # Max amplitude for X, Y drives\n)\n\nsys.levels, sys.n_drives","category":"section"},{"location":"generated/guides/system_templates/#Parameters","page":"System Templates","title":"Parameters","text":"Parameter Type Default Description\nlevels Int 3 Number of transmon levels (‚â•2)\nŒ¥ Float64 0.2 Anharmonicity (typically ~0.2 GHz)\ndrive_bounds Vector{Float64} [1.0, 1.0] Bounds for X and Y drives\nœâ Float64 4.0 Qubit frequency (often 0 in rotating frame)\nlab_frame Bool false Whether to use lab frame","category":"section"},{"location":"generated/guides/system_templates/#Hamiltonian-Structure","page":"System Templates","title":"Hamiltonian Structure","text":"H = omega a^dagger a + fracdelta2 a^dagger a (a^dagger a - 1) + u_x(t) (a + a^dagger) + u_y(t) i(a^dagger - a)","category":"section"},{"location":"generated/guides/system_templates/#Example:-X-Gate-on-3-Level-Transmon","page":"System Templates","title":"Example: X Gate on 3-Level Transmon","text":"sys = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.2, 0.2])\n\n# Goal: X gate embedded in computational subspace\nU_goal = EmbeddedOperator(:X, sys)\n\n# Setup and solve\nT, N = 20.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.05 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\nqcp = SmoothPulseProblem(qtraj, N; Q = 100.0)\ncached_solve!(\n    qcp,\n    \"system_templates_transmon\";\n    max_iter = 100,\n    verbose = false,\n    print_level = 1,\n)\n\nfidelity(qcp)","category":"section"},{"location":"generated/guides/system_templates/#MultiTransmonSystem","page":"System Templates","title":"MultiTransmonSystem","text":"For multiple coupled transmon qubits.","category":"section"},{"location":"generated/guides/system_templates/#Usage","page":"System Templates","title":"Usage","text":"sys_multi = MultiTransmonSystem(\n    [4.0, 4.1],               # Qubit frequencies (GHz)\n    [0.2, 0.22],              # Anharmonicities (can differ)\n    [0.0 0.01; 0.01 0.0];    # Coupling matrix\n    drive_bounds = 0.2,\n    levels_per_transmon = 3,\n)","category":"section"},{"location":"generated/guides/system_templates/#Parameters-2","page":"System Templates","title":"Parameters","text":"Parameter Type Description\nœâs Vector{Float64} Qubit frequencies\nŒ¥s Vector{Float64} Anharmonicities\ngs Matrix{Float64} Coupling strength matrix\nlevels_per_transmon Int Levels per qubit\ndrive_bounds Float64 or Vector Control bounds","category":"section"},{"location":"generated/guides/system_templates/#IonChainSystem","page":"System Templates","title":"IonChainSystem","text":"For trapped ion quantum computing.","category":"section"},{"location":"generated/guides/system_templates/#Usage-2","page":"System Templates","title":"Usage","text":"sys_ion = IonChainSystem(\n    N_ions = 2,\n    mode_levels = 5,\n    œâq = 1.0,            # Qubit frequency\n    œâm = 0.1,            # Motional mode frequency\n    Œ∑ = 0.1,             # Lamb-Dicke parameter\n    drive_bounds = fill(0.5, 4),\n)","category":"section"},{"location":"generated/guides/system_templates/#Parameters-3","page":"System Templates","title":"Parameters","text":"Parameter Type Description\nN_ions Int Number of ions\nmode_levels Int Motional mode Fock space truncation\nœâq Float64 Qubit frequency\nœâm Float64 Motional mode frequency\nŒ∑ Float64 Lamb-Dicke parameter\ndrive_bounds Vector Laser drive bounds","category":"section"},{"location":"generated/guides/system_templates/#RadialMSGateSystem","page":"System Templates","title":"RadialMSGateSystem","text":"Specialized for Molmer-Sorensen entangling gates.","category":"section"},{"location":"generated/guides/system_templates/#Usage-3","page":"System Templates","title":"Usage","text":"sys_ms = RadialMSGateSystem(\n    N_ions = 2,\n    mode_levels = 5,\n    œâm_radial = [5.0, 5.0, 5.1, 5.1],  # Radial mode frequencies\n    Œ¥ = 0.2,\n    Œ∑ = 0.1,\n    drive_bounds = fill(1.0, 2),\n)","category":"section"},{"location":"generated/guides/system_templates/#RydbergChainSystem","page":"System Templates","title":"RydbergChainSystem","text":"For Rydberg atom arrays.","category":"section"},{"location":"generated/guides/system_templates/#Usage-4","page":"System Templates","title":"Usage","text":"sys_rydberg = RydbergChainSystem(\n    N = 3,                # Number of atoms\n    C = 862690 * 2œÄ,      # Rydberg interaction coefficient\n    distance = 8.7,       # Atom spacing (Œºm)\n    cutoff_order = 1,     # Nearest-neighbor interactions\n    drive_bounds = [1.0, 1.0, 1.0],\n)","category":"section"},{"location":"generated/guides/system_templates/#Parameters-4","page":"System Templates","title":"Parameters","text":"Parameter Type Description\nN Int Number of atoms\nC Float64 Rydberg interaction coefficient\ndistance Float64 Atom spacing (Œºm)\ncutoff_order Int Interaction range (1 = nearest neighbor)","category":"section"},{"location":"generated/guides/system_templates/#Hamiltonian-Structure-2","page":"System Templates","title":"Hamiltonian Structure","text":"H = sum_i fracOmega(t)2 sigma_x^i - Delta(t) n_i + sum_ij fracC_6r_i - r_j^6 n_i n_j","category":"section"},{"location":"generated/guides/system_templates/#CatSystem","page":"System Templates","title":"CatSystem","text":"For bosonic cat qubits in superconducting cavities:\n\nsys_cat = CatSystem(\n    cat_levels = 13,       # Photon number cutoff\n    buffer_levels = 3,     # Buffer mode levels\n    g2 = 0.36,            # Two-photon drive strength\n    drive_bounds = [1.0, 1.0],\n)\n\nnote: Note\nCatSystem returns an OpenQuantumSystem for Lindbladian dynamics.","category":"section"},{"location":"generated/guides/system_templates/#Creating-Custom-Templates","page":"System Templates","title":"Creating Custom Templates","text":"You can create your own system templates by wrapping QuantumSystem:\n\nfunction MyCustomSystem(; œâ, Œ¥, drive_bounds)\n    levels = 3\n    # Build Hamiltonian using Piccolo's annihilation operator\n    a = annihilate(levels)\n    n = a' * a\n\n    H_drift = œâ * n + (Œ¥ / 2) * n * (n - I)\n    H_drives = [a + a', 1.0im * (a' - a)]\n\n    return QuantumSystem(H_drift, H_drives, drive_bounds)\nend\n\nmy_sys = MyCustomSystem(œâ = 4.0, Œ¥ = 0.2, drive_bounds = [0.2, 0.2])\nmy_sys.levels","category":"section"},{"location":"generated/guides/system_templates/#Best-Practices","page":"System Templates","title":"Best Practices","text":"","category":"section"},{"location":"generated/guides/system_templates/#1.-Include-Enough-Levels","page":"System Templates","title":"1. Include Enough Levels","text":"For transmons, always include at least one level above the computational space:\n\n# For single-qubit gates: 3 levels minimum\nsys = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.2, 0.2])","category":"section"},{"location":"generated/guides/system_templates/#2.-Use-Realistic-Parameters","page":"System Templates","title":"2. Use Realistic Parameters","text":"Match your physical system:\n\n# Typical transmon parameters\nsys = TransmonSystem(\n    levels = 4,\n    Œ¥ = 0.2,                       # ~200 MHz anharmonicity\n    drive_bounds = [0.05, 0.05],   # ~50 MHz max drive\n)","category":"section"},{"location":"generated/guides/system_templates/#3.-Combine-with-EmbeddedOperator","page":"System Templates","title":"3. Combine with EmbeddedOperator","text":"For multilevel systems, define gates in the computational subspace:\n\nsys = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.2, 0.2])\nU_goal = EmbeddedOperator(:X, sys)  # X gate on |0‚ü©, |1‚ü© subspace","category":"section"},{"location":"generated/guides/system_templates/#See-Also","page":"System Templates","title":"See Also","text":"Quantum Systems - General system documentation\nLeakage Suppression - Handling higher levels\nOperators - EmbeddedOperator details\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/concepts/pulses/#pulses-concept","page":"Pulses","title":"Pulses","text":"Pulses in Piccolo.jl parameterize how control signals vary over time. The choice of pulse type affects both the optimization problem structure and the resulting control smoothness.","category":"section"},{"location":"generated/concepts/pulses/#Overview","page":"Pulses","title":"Overview","text":"Pulse Type Description Use With\nZeroOrderPulse Piecewise constant SmoothPulseProblem\nLinearSplinePulse Linear interpolation SplinePulseProblem\nCubicSplinePulse Cubic Hermite splines SplinePulseProblem\nGaussianPulse Parametric Gaussian Analytical evaluation\nCompositePulse Combination of pulses Various","category":"section"},{"location":"generated/concepts/pulses/#ZeroOrderPulse","page":"Pulses","title":"ZeroOrderPulse","text":"Piecewise constant (zero-order hold) controls. The most common choice for initial optimization.","category":"section"},{"location":"generated/concepts/pulses/#Construction","page":"Pulses","title":"Construction","text":"using Piccolo\n\nn_dr = 2\nN = 100\nT = 10.0\n\n# Time points\ntimes = collect(range(0, T, length = N))\n\n# Control values: n_drives √ó N matrix\ncontrols = 0.1 * randn(n_dr, N)\n\npulse_zop = ZeroOrderPulse(controls, times)","category":"section"},{"location":"generated/concepts/pulses/#Properties","page":"Pulses","title":"Properties","text":"# Evaluate at time t\nu = pulse_zop(T / 2)\nu\n\n# Duration\nduration(pulse_zop)\n\n# Number of drives\nn_drives(pulse_zop)","category":"section"},{"location":"generated/concepts/pulses/#Visualization","page":"Pulses","title":"Visualization","text":"Control Value\n    ‚îÇ    ‚îå‚îÄ‚îÄ‚îê\n    ‚îÇ    ‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îê\n    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ\n    ‚îÇ       ‚îî‚îÄ‚îÄ‚îò\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Time","category":"section"},{"location":"generated/concepts/pulses/#Use-Case","page":"Pulses","title":"Use Case","text":"Primary use: SmoothPulseProblem\nCharacteristics: Simple structure, smoothness via derivative regularization\nBest for: Initial optimization, most quantum control problems","category":"section"},{"location":"generated/concepts/pulses/#LinearSplinePulse","page":"Pulses","title":"LinearSplinePulse","text":"Linear interpolation between control knots.","category":"section"},{"location":"generated/concepts/pulses/#Construction-2","page":"Pulses","title":"Construction","text":"pulse_linear = LinearSplinePulse(controls, times)","category":"section"},{"location":"generated/concepts/pulses/#Properties-2","page":"Pulses","title":"Properties","text":"Continuous control values\nDiscontinuous first derivative (at knots)\nDerivative = slope between knots\n\nu_linear = pulse_linear(T / 2)\nu_linear","category":"section"},{"location":"generated/concepts/pulses/#Visualization-2","page":"Pulses","title":"Visualization","text":"Control Value\n    ‚îÇ      /\\\n    ‚îÇ     /  \\    /\n    ‚îÇ    /    \\  /\n    ‚îÇ‚îÄ‚îÄ‚îÄ/      \\/\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Time","category":"section"},{"location":"generated/concepts/pulses/#CubicSplinePulse","page":"Pulses","title":"CubicSplinePulse","text":"Cubic Hermite spline interpolation with independent tangents at each knot.","category":"section"},{"location":"generated/concepts/pulses/#Construction-3","page":"Pulses","title":"Construction","text":"tangents = zeros(n_dr, N)  # Initial tangents (slopes)\npulse_cubic = CubicSplinePulse(controls, tangents, times)","category":"section"},{"location":"generated/concepts/pulses/#Properties-3","page":"Pulses","title":"Properties","text":"Continuous control values AND first derivatives\nTangents are independent optimization variables\nSmooth C¬π continuous curves\n\nu_cubic = pulse_cubic(T / 2)\nu_cubic","category":"section"},{"location":"generated/concepts/pulses/#GaussianPulse","page":"Pulses","title":"GaussianPulse","text":"Parametric Gaussian envelope with analytical form.","category":"section"},{"location":"generated/concepts/pulses/#Construction-4","page":"Pulses","title":"Construction","text":"amplitudes = [0.5, 0.3]\nsigmas = [1.0, 1.5]\ncenters = [5.0, 5.0]\n\npulse_gauss = GaussianPulse(amplitudes, sigmas, centers, T)","category":"section"},{"location":"generated/concepts/pulses/#Mathematical-Form","page":"Pulses","title":"Mathematical Form","text":"u_i(t) = A_i expleft(-frac(t - mu_i)^22sigma_i^2right)\n\nu_gauss = pulse_gauss(5.0)\nu_gauss","category":"section"},{"location":"generated/concepts/pulses/#CompositePulse","page":"Pulses","title":"CompositePulse","text":"Combine multiple pulses.","category":"section"},{"location":"generated/concepts/pulses/#Construction-5","page":"Pulses","title":"Construction","text":"pulse1 = GaussianPulse([0.5], [0.5], [2.0], T)\npulse2 = GaussianPulse([0.3], [0.5], [8.0], T)\n\n# Interleave the pulses (each pulse contributes different drives)\ncomposite = CompositePulse([pulse1, pulse2])\nn_drives(composite)","category":"section"},{"location":"generated/concepts/pulses/#Choosing-a-Pulse-Type","page":"Pulses","title":"Choosing a Pulse Type","text":"","category":"section"},{"location":"generated/concepts/pulses/#Decision-Guide","page":"Pulses","title":"Decision Guide","text":"Start\n  ‚îÇ\n  ‚ñº\nIs this your first optimization attempt?\n  ‚îÇ\n  ‚îú‚îÄ‚îÄ Yes ‚Üí ZeroOrderPulse + SmoothPulseProblem\n  ‚îÇ\n  ‚îî‚îÄ‚îÄ No ‚Üí Do you have a previous solution?\n              ‚îÇ\n              ‚îú‚îÄ‚îÄ Yes ‚Üí CubicSplinePulse + SplinePulseProblem (warm-start)\n              ‚îÇ\n              ‚îî‚îÄ‚îÄ No ‚Üí Do you need smooth pulses?\n                          ‚îÇ\n                          ‚îú‚îÄ‚îÄ Yes ‚Üí CubicSplinePulse\n                          ‚îÇ\n                          ‚îî‚îÄ‚îÄ No ‚Üí ZeroOrderPulse","category":"section"},{"location":"generated/concepts/pulses/#Practical-Recommendations","page":"Pulses","title":"Practical Recommendations","text":"Scenario Recommended Pulse\nStarting fresh ZeroOrderPulse\nRefining a solution CubicSplinePulse\nHardware requires smooth pulses CubicSplinePulse\nSimple continuous pulses LinearSplinePulse\nAnalytical pulse design GaussianPulse","category":"section"},{"location":"generated/concepts/pulses/#Converting-Between-Pulse-Types","page":"Pulses","title":"Converting Between Pulse Types","text":"","category":"section"},{"location":"generated/concepts/pulses/#ZeroOrderPulse-CubicSplinePulse","page":"Pulses","title":"ZeroOrderPulse ‚Üí CubicSplinePulse","text":"# Sample control values from the zero-order pulse\nctrl = hcat([pulse_zop(t) for t in times]...)\n\n# Estimate tangents (finite differences)\ntgts = similar(ctrl)\nfor k = 1:(N-1)\n    tgts[:, k] = (ctrl[:, k+1] - ctrl[:, k]) / (times[k+1] - times[k])\nend\ntgts[:, N] = tgts[:, N-1]\n\n# Create cubic spline\ncubic_from_zop = CubicSplinePulse(ctrl, tgts, times)\nduration(cubic_from_zop)","category":"section"},{"location":"generated/concepts/pulses/#Arbitrary-ZeroOrderPulse","page":"Pulses","title":"Arbitrary ‚Üí ZeroOrderPulse","text":"# Sample any pulse type to create a ZeroOrderPulse\nnew_times = collect(range(0, T, length = 200))\nnew_ctrl = hcat([pulse_cubic(t) for t in new_times]...)\nresampled = ZeroOrderPulse(new_ctrl, new_times)\nlength(new_times)","category":"section"},{"location":"generated/concepts/pulses/#Best-Practices","page":"Pulses","title":"Best Practices","text":"","category":"section"},{"location":"generated/concepts/pulses/#1.-Initialize-Appropriately","page":"Pulses","title":"1. Initialize Appropriately","text":"# Scale by drive bounds\nmax_amp = 0.1 * maximum(drive_bounds)\ncontrols = max_amp * randn(n_drives, N)","category":"section"},{"location":"generated/concepts/pulses/#2.-Use-Enough-Time-Points","page":"Pulses","title":"2. Use Enough Time Points","text":"# Rule of thumb: ~10 points per characteristic time scale\nT = 10.0  # Total time\nœÑ = 1.0   # Shortest feature you want to capture\nN = ceil(Int, 10 * T / œÑ)","category":"section"},{"location":"generated/concepts/pulses/#3.-Start-with-ZeroOrderPulse","page":"Pulses","title":"3. Start with ZeroOrderPulse","text":"Even if you need smooth pulses, optimize with ZeroOrderPulse first, then convert to CubicSplinePulse for refinement.","category":"section"},{"location":"generated/concepts/pulses/#See-Also","page":"Pulses","title":"See Also","text":"SmoothPulseProblem - Using ZeroOrderPulse\nSplinePulseProblem - Using spline pulses\nTrajectories - Combining pulses with systems\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/concepts/trajectories/#trajectories-concept","page":"Trajectories","title":"Trajectories","text":"Trajectories in Piccolo.jl represent a complete quantum control scenario: a system, a control pulse, and a goal. They are the central object passed to problem templates.","category":"section"},{"location":"generated/concepts/trajectories/#Overview","page":"Trajectories","title":"Overview","text":"A trajectory encapsulates:\n\nQuantum system: The hardware being controlled\nPulse: How controls vary over time\nGoal: The desired outcome (gate, state, etc.)\nState evolution: The quantum state over time","category":"section"},{"location":"generated/concepts/trajectories/#Trajectory-Types","page":"Trajectories","title":"Trajectory Types","text":"Type Use Case State Variable\nUnitaryTrajectory Gate synthesis Unitary matrix U(t)\nKetTrajectory State preparation State vector |œà(t)‚ü©\nDensityTrajectory Open systems Density matrix œÅ(t)\nMultiKetTrajectory Multiple state transfers Multiple |œà·µ¢(t)‚ü©\nSamplingTrajectory Robust optimization States for multiple systems","category":"section"},{"location":"generated/concepts/trajectories/#UnitaryTrajectory","page":"Trajectories","title":"UnitaryTrajectory","text":"For synthesizing quantum gates.","category":"section"},{"location":"generated/concepts/trajectories/#Construction","page":"Trajectories","title":"Construction","text":"using Piccolo\n\n# Define system\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n# Create pulse\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\n\n# Create trajectory with goal\nU_goal = GATES[:X]\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)","category":"section"},{"location":"generated/concepts/trajectories/#Solve-and-Analyze","page":"Trajectories","title":"Solve and Analyze","text":"qcp = SmoothPulseProblem(qtraj, N; Q = 100.0)\ncached_solve!(qcp, \"trajectories_unitary\"; max_iter = 50)\nfidelity(qcp)","category":"section"},{"location":"generated/concepts/trajectories/#Extracting-the-Pulse","page":"Trajectories","title":"Extracting the Pulse","text":"optimized_pulse = get_pulse(qcp.qtraj)\nduration(optimized_pulse)","category":"section"},{"location":"generated/concepts/trajectories/#KetTrajectory","page":"Trajectories","title":"KetTrajectory","text":"For state preparation (state-to-state transfer).","category":"section"},{"location":"generated/concepts/trajectories/#Construction-2","page":"Trajectories","title":"Construction","text":"# Initial and goal states\nœà_init = ComplexF64[1, 0]  # |0‚ü©\nœà_goal = ComplexF64[0, 1]  # |1‚ü©\n\nqtraj_ket = KetTrajectory(sys, pulse, œà_init, œà_goal)","category":"section"},{"location":"generated/concepts/trajectories/#When-to-Use","page":"Trajectories","title":"When to Use","text":"Use KetTrajectory when:\n\nPreparing a specific quantum state\nGlobal phase doesn't matter\nSingle state transfer\n\nqcp_ket = SmoothPulseProblem(qtraj_ket, N; Q = 100.0)\ncached_solve!(qcp_ket, \"trajectories_ket\"; max_iter = 50)\nfidelity(qcp_ket)","category":"section"},{"location":"generated/concepts/trajectories/#MultiKetTrajectory","page":"Trajectories","title":"MultiKetTrajectory","text":"For gates defined by multiple state mappings with coherent phases.","category":"section"},{"location":"generated/concepts/trajectories/#Construction-3","page":"Trajectories","title":"Construction","text":"# Define state pairs: X gate maps |0‚ü© ‚Üí |1‚ü© and |1‚ü© ‚Üí |0‚ü©\nœà0 = ComplexF64[1, 0]\nœà1 = ComplexF64[0, 1]\n\ninitial_states = [œà0, œà1]\ngoal_states = [œà1, œà0]\n\nqtraj_multi = MultiKetTrajectory(sys, pulse, initial_states, goal_states)","category":"section"},{"location":"generated/concepts/trajectories/#Coherent-Fidelity","page":"Trajectories","title":"Coherent Fidelity","text":"MultiKetTrajectory uses CoherentKetInfidelityObjective, which ensures:\n\nEach state reaches its target\nRelative phases between states are preserved\n\nThis is important for gates where phase relationships matter (unlike UnitaryTrajectory which tracks the full unitary).\n\nqcp_multi = SmoothPulseProblem(qtraj_multi, N; Q = 100.0)\ncached_solve!(qcp_multi, \"trajectories_multi\"; max_iter = 50)\nfidelity(qcp_multi)","category":"section"},{"location":"generated/concepts/trajectories/#DensityTrajectory","page":"Trajectories","title":"DensityTrajectory","text":"For open quantum systems with dissipation.\n\n# Open system with collapse operators\nopen_sys = OpenQuantumSystem(H_drift, H_drives, bounds, c_ops)\n\n# Initial density matrix\nœÅ_init = [1.0 0.0; 0.0 0.0]  # Pure |0‚ü©\nœÅ_goal = [0.0 0.0; 0.0 1.0]  # Pure |1‚ü©\n\nqtraj = DensityTrajectory(open_sys, pulse, œÅ_init, œÅ_goal)\n\nnote: Note\nDensityTrajectory support for fidelity objectives is still in development. For most open-system problems, consider using KetTrajectory with an effective Hamiltonian.","category":"section"},{"location":"generated/concepts/trajectories/#SamplingTrajectory","page":"Trajectories","title":"SamplingTrajectory","text":"For robust optimization over parameter variations. This is created internally by SamplingProblem.","category":"section"},{"location":"generated/concepts/trajectories/#How-It-Works","page":"Trajectories","title":"How It Works","text":"SamplingTrajectory wraps multiple system variants:\n\n# Created internally by SamplingProblem\nsystems = [sys_nominal, sys_high, sys_low]\nqcp_robust = SamplingProblem(qcp_base, systems)\n# This creates a SamplingTrajectory internally\n\nThe resulting trajectory has:\n\nSingle shared control pulse\nMultiple state trajectories (one per system)","category":"section"},{"location":"generated/concepts/trajectories/#Common-Operations","page":"Trajectories","title":"Common Operations","text":"","category":"section"},{"location":"generated/concepts/trajectories/#Named-Trajectory-Integration","page":"Trajectories","title":"Named Trajectory Integration","text":"After solving, the NamedTrajectory stores discrete time points:\n\ntraj = get_trajectory(qcp)\n\n# Controls at timestep k\nu_1 = traj[1][:u]\nu_1\n\n# All timesteps\nŒîts = get_timesteps(traj)\nlength(Œîts)","category":"section"},{"location":"generated/concepts/trajectories/#Internal-Representation","page":"Trajectories","title":"Internal Representation","text":"Piccolo.jl uses real isomorphisms internally for optimization. Complex states are converted to real vectors:\n\n# Complex ket |œà‚ü© ‚Üí real vector œàÃÉ\nœà = ComplexF64[1, im] / ‚àö2\nœàÃÉ = ket_to_iso(œà)  # [Re(œà); Im(œà)]\n\n# Unitary U ‚Üí real vector ≈®‚Éó\nU = GATES[:H]\n≈® = operator_to_iso_vec(U)\n\nSee Isomorphisms for details.","category":"section"},{"location":"generated/concepts/trajectories/#Best-Practices","page":"Trajectories","title":"Best Practices","text":"","category":"section"},{"location":"generated/concepts/trajectories/#1.-Match-Pulse-Type-to-Problem","page":"Trajectories","title":"1. Match Pulse Type to Problem","text":"# For SmoothPulseProblem\npulse = ZeroOrderPulse(controls, times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SmoothPulseProblem(qtraj, N)  # ‚úì\n\n# For SplinePulseProblem\npulse = CubicSplinePulse(controls, tangents, times)\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\nqcp = SplinePulseProblem(qtraj)  # ‚úì","category":"section"},{"location":"generated/concepts/trajectories/#2.-Initialize-with-Reasonable-Controls","page":"Trajectories","title":"2. Initialize with Reasonable Controls","text":"# Scale by drive bounds\nmax_amp = 0.1 * 1.0\ninitial_controls = max_amp * randn(2, N)\nextrema(initial_controls)","category":"section"},{"location":"generated/concepts/trajectories/#See-Also","page":"Trajectories","title":"See Also","text":"Quantum Systems - System definitions\nPulses - Control parameterizations\nProblem Templates - Using trajectories in optimization\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorials/#tutorials-overview","page":"Overview","title":"Tutorials","text":"Step-by-step tutorials for learning Piccolo.jl. Each tutorial builds on previous ones, introducing new concepts progressively.","category":"section"},{"location":"tutorials/#Learning-Path","page":"Overview","title":"Learning Path","text":"","category":"section"},{"location":"tutorials/#For-Beginners","page":"Overview","title":"For Beginners","text":"If you're new to quantum optimal control or Piccolo.jl:\n\nYour First Gate - Complete walkthrough of X gate synthesis\nState Transfer - Learn about KetTrajectory for state preparation\nMultilevel Transmon - Work with realistic multilevel systems","category":"section"},{"location":"tutorials/#For-Experienced-Users","page":"Overview","title":"For Experienced Users","text":"If you're familiar with quantum control concepts:\n\nMultilevel Transmon - EmbeddedOperator and leakage suppression\nRobust Control - SamplingProblem for parameter robustness","category":"section"},{"location":"tutorials/#Tutorial-Overview","page":"Overview","title":"Tutorial Overview","text":"Tutorial Duration Topics\nYour First Gate 15 min Systems, pulses, trajectories, solving, analysis\nState Transfer 15 min KetTrajectory, state preparation, coherent gates\nMultilevel Transmon 20 min TransmonSystem, EmbeddedOperator, leakage\nRobust Control 20 min SamplingProblem, parameter uncertainty","category":"section"},{"location":"tutorials/#Prerequisites","page":"Overview","title":"Prerequisites","text":"Before starting the tutorials, ensure you have:\n\nJulia 1.10+ installed\nPiccolo.jl installed: using Pkg; Pkg.add(\"Piccolo\")\nCairoMakie for plotting: using Pkg; Pkg.add(\"CairoMakie\")\n\nTest your setup:\n\nusing Piccolo\nusing CairoMakie\n\nprintln(\"Setup complete!\")","category":"section"},{"location":"tutorials/#What-You'll-Learn","page":"Overview","title":"What You'll Learn","text":"","category":"section"},{"location":"tutorials/#Your-First-Gate","page":"Overview","title":"Your First Gate","text":"Defining quantum systems with QuantumSystem\nCreating control pulses with ZeroOrderPulse\nSetting optimization goals with UnitaryTrajectory\nSolving with SmoothPulseProblem\nAnalyzing results with fidelity() and plotting","category":"section"},{"location":"tutorials/#State-Transfer","page":"Overview","title":"State Transfer","text":"Using KetTrajectory for state-to-state transfer\nWorking with MultiKetTrajectory for multiple state mappings\nUnderstanding coherent fidelity for phase-sensitive gates","category":"section"},{"location":"tutorials/#Multilevel-Transmon","page":"Overview","title":"Multilevel Transmon","text":"Using TransmonSystem for realistic superconducting qubits\nDefining subspace gates with EmbeddedOperator\nSuppressing leakage to higher energy levels\nUsing PiccoloOptions for leakage handling","category":"section"},{"location":"tutorials/#Robust-Control","page":"Overview","title":"Robust Control","text":"Creating system variants for parameter uncertainty\nUsing SamplingProblem for robust optimization\nEvaluating robustness across parameter ranges\nCombining robustness with time optimization","category":"section"},{"location":"tutorials/#Running-the-Tutorials","page":"Overview","title":"Running the Tutorials","text":"Each tutorial is a complete, runnable Julia script. You can:\n\nRead online: Follow along in the documentation\nRun locally: Download the .jl file from the docs/literate/ folder\nCopy-paste: Copy code blocks into your Julia REPL","category":"section"},{"location":"tutorials/#Next-Steps","page":"Overview","title":"Next Steps","text":"After completing the tutorials:\n\nExplore Problem Templates for the full API\nRead Concepts for detailed documentation\nCheck How-To Guides for specific tasks","category":"section"},{"location":"generated/concepts/constraints/#constraints-concept","page":"Constraints","title":"Constraints","text":"Constraints define hard requirements that optimized solutions must satisfy. Unlike objectives (which are minimized), constraints are enforced exactly.","category":"section"},{"location":"generated/concepts/constraints/#Overview","page":"Constraints","title":"Overview","text":"Piccolo.jl supports several constraint types:\n\nConstraint Type Description\nBound constraints Limits on variable values\nFidelity constraints Minimum fidelity requirements\nLeakage constraints Maximum allowed leakage\nEquality constraints Custom equality requirements","category":"section"},{"location":"generated/concepts/constraints/#Bound-Constraints","page":"Constraints","title":"Bound Constraints","text":"","category":"section"},{"location":"generated/concepts/constraints/#Control-Bounds","page":"Constraints","title":"Control Bounds","text":"Control bounds are specified in the QuantumSystem and automatically enforced:\n\nusing Piccolo\n\n# Bounds specified at system creation\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\ndrive_bounds = [1.0, 0.5]  # Drive 1: ¬±1.0, Drive 2: ¬±0.5\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)","category":"section"},{"location":"generated/concepts/constraints/#Derivative-Bounds","page":"Constraints","title":"Derivative Bounds","text":"Derivative bounds limit how fast controls can change:\n\nT, N = 10.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nU_goal = GATES[:X]\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    du_bound = 0.5,    # Max control jump per timestep\n    ddu_bound = 0.1,   # Max control acceleration\n)\ncached_solve!(qcp, \"constraints_bounds\"; max_iter = 50)\nfidelity(qcp)","category":"section"},{"location":"generated/concepts/constraints/#Timestep-Bounds","page":"Constraints","title":"Timestep Bounds","text":"For free-time optimization:\n\nqcp = SmoothPulseProblem(\n    qtraj, N;\n    Œît_bounds=(0.01, 0.5)  # Min and max timestep\n)","category":"section"},{"location":"generated/concepts/constraints/#Fidelity-Constraints","page":"Constraints","title":"Fidelity Constraints","text":"Used with MinimumTimeProblem to enforce minimum gate quality.","category":"section"},{"location":"generated/concepts/constraints/#FinalUnitaryFidelityConstraint","page":"Constraints","title":"FinalUnitaryFidelityConstraint","text":"constraint = FinalUnitaryFidelityConstraint(\n    :≈®‚Éó,        # State variable name\n    U_goal,    # Target unitary\n    0.99       # Minimum fidelity\n)","category":"section"},{"location":"generated/concepts/constraints/#Automatic-Setup-in-MinimumTimeProblem","page":"Constraints","title":"Automatic Setup in MinimumTimeProblem","text":"You typically don't create fidelity constraints manually. MinimumTimeProblem adds them automatically:\n\n# First solve a base problem with variable timesteps\nqcp_base = SmoothPulseProblem(qtraj, N; Œît_bounds = (0.01, 0.5))\ncached_solve!(qcp_base, \"constraints_base_freetime\"; max_iter = 100)\nfidelity(qcp_base)\n\n# Automatically adds FinalUnitaryFidelityConstraint\nqcp_mintime = MinimumTimeProblem(qcp_base; final_fidelity = 0.99)\ncached_solve!(qcp_mintime, \"constraints_mintime\"; max_iter = 100)\nfidelity(qcp_mintime)","category":"section"},{"location":"generated/concepts/constraints/#Leakage-Constraints","page":"Constraints","title":"Leakage Constraints","text":"","category":"section"},{"location":"generated/concepts/constraints/#Via-PiccoloOptions","page":"Constraints","title":"Via PiccoloOptions","text":"The easiest approach to handle leakage:\n\nopts = PiccoloOptions(leakage_constraint = true, leakage_constraint_value = 1e-3)\n\n# Example with a transmon system\nsys_transmon = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.2, 0.2])\npulse_t = ZeroOrderPulse(0.01 * randn(2, N), times)\nU_X = EmbeddedOperator(:X, sys_transmon)\nqtraj_t = UnitaryTrajectory(sys_transmon, pulse_t, U_X)\n\nqcp_leak = SmoothPulseProblem(qtraj_t, N; piccolo_options = opts)\ncached_solve!(qcp_leak, \"constraints_leakage\"; max_iter = 100)\nfidelity(qcp_leak)","category":"section"},{"location":"generated/concepts/constraints/#PiccoloOptions","page":"Constraints","title":"PiccoloOptions","text":"PiccoloOptions provides a convenient way to configure common constraint settings:\n\nopts = PiccoloOptions(\n    # Leakage handling\n    leakage_constraint=true,\n    leakage_constraint_value=1e-3,\n    leakage_cost=10.0,  # Also adds objective\n\n    # Timestep handling\n    timesteps_all_equal=false,\n\n    # Verbosity\n    verbose=true\n)","category":"section"},{"location":"generated/concepts/constraints/#Key-Options","page":"Constraints","title":"Key Options","text":"Option Type Default Description\nleakage_constraint Bool false Enable leakage constraint\nleakage_constraint_value Float64 1e-3 Maximum leakage\nleakage_cost Float64 0.0 Leakage objective weight\ntimesteps_all_equal Bool false Force uniform timesteps\nverbose Bool false Print solver progress","category":"section"},{"location":"generated/concepts/constraints/#Constraints-vs-Objectives","page":"Constraints","title":"Constraints vs Objectives","text":"Understanding when to use each:\n\nUse Case Constraint Objective\nMust achieve F ‚â• 0.99 ‚úì Fidelity constraint \nPrefer higher fidelity  ‚úì Infidelity objective\nControl must be ‚â§ 1.0 ‚úì Bound constraint \nPrefer smaller controls  ‚úì Regularization\nLeakage must be < 1e-3 ‚úì Leakage constraint \nPrefer less leakage  ‚úì Leakage objective","category":"section"},{"location":"generated/concepts/constraints/#Trade-offs","page":"Constraints","title":"Trade-offs","text":"Constraints:\n\nGuarantee satisfaction (if feasible)\nCan make problem harder to solve\nMay be infeasible\n\nObjectives:\n\nMore flexible\nEasier optimization\nNo guarantees","category":"section"},{"location":"generated/concepts/constraints/#Recommendation","page":"Constraints","title":"Recommendation","text":"Start with objectives, add constraints for hard requirements.","category":"section"},{"location":"generated/concepts/constraints/#Constraint-Feasibility","page":"Constraints","title":"Constraint Feasibility","text":"","category":"section"},{"location":"generated/concepts/constraints/#Common-Causes-of-Infeasibility","page":"Constraints","title":"Common Causes of Infeasibility","text":"Fidelity too high: Target fidelity may not be achievable\nTime too short: Insufficient time for the gate\nBounds too tight: Controls can't reach required values\nConflicting constraints: e.g., low leakage with high fidelity in short time","category":"section"},{"location":"generated/concepts/constraints/#Solutions","page":"Constraints","title":"Solutions","text":"Relax constraints: Lower fidelity target, increase time\nBetter initialization: Start from a working solution\nAdjust bounds: Allow larger controls or longer time\nUse objectives first: Find a good solution, then add constraints","category":"section"},{"location":"generated/concepts/constraints/#Best-Practices","page":"Constraints","title":"Best Practices","text":"","category":"section"},{"location":"generated/concepts/constraints/#1.-Start-Without-Constraints","page":"Constraints","title":"1. Start Without Constraints","text":"# First, find a good solution with just objectives\nqcp_simple = SmoothPulseProblem(UnitaryTrajectory(sys, pulse, U_goal), N; Q = 100.0)\ncached_solve!(qcp_simple, \"constraints_simple\"; max_iter = 100)\nfidelity(qcp_simple)","category":"section"},{"location":"generated/concepts/constraints/#2.-Add-Constraints-Gradually","page":"Constraints","title":"2. Add Constraints Gradually","text":"# Then add constraints if needed\nif fidelity(qcp_simple) > 0.99\n    qcp_constrained = MinimumTimeProblem(qcp_simple; final_fidelity=0.99)\n    solve!(qcp_constrained)\nend","category":"section"},{"location":"generated/concepts/constraints/#3.-Use-Margin-for-Robustness","page":"Constraints","title":"3. Use Margin for Robustness","text":"# Target slightly higher than needed\nqcp = MinimumTimeProblem(qcp_base; final_fidelity=0.995)  # Want 0.99","category":"section"},{"location":"generated/concepts/constraints/#See-Also","page":"Constraints","title":"See Also","text":"Objectives - Soft optimization targets\nProblem Templates - Using constraints in practice\nMinimumTimeProblem - Fidelity-constrained time optimization\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/getting-started/installation/#installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"generated/getting-started/installation/#Requirements","page":"Installation","title":"Requirements","text":"Julia 1.10 or later\nA working internet connection (for package installation)","category":"section"},{"location":"generated/getting-started/installation/#Installing-Piccolo.jl","page":"Installation","title":"Installing Piccolo.jl","text":"Piccolo.jl is registered in the Julia General registry. Install it using the Julia package manager:\n\nusing Pkg\nPkg.add(\"Piccolo\")\n\nOr from the Julia REPL, press ] to enter package mode and run:\n\npkg> add Piccolo","category":"section"},{"location":"generated/getting-started/installation/#Verifying-Installation","page":"Installation","title":"Verifying Installation","text":"Test your installation by running:\n\nusing Piccolo\n\n# Check that core types are available\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\nsys","category":"section"},{"location":"generated/getting-started/installation/#Optional:-Visualization-Support","page":"Installation","title":"Optional: Visualization Support","text":"For plotting, you'll need a Makie backend. CairoMakie is recommended:\n\nusing Pkg\nPkg.add(\"CairoMakie\")\n\nThen in your code:\n\nusing Piccolo\nusing CairoMakie","category":"section"},{"location":"generated/getting-started/installation/#Development-Installation","page":"Installation","title":"Development Installation","text":"For contributing to Piccolo.jl or using the latest development version:\n\nusing Pkg\nPkg.develop(url=\"https://github.com/harmoniqs/Piccolo.jl\")\n\nOr clone the repository and use dev mode:\n\ngit clone https://github.com/harmoniqs/Piccolo.jl.git\ncd Piccolo.jl\njulia --project=.\n\nusing Pkg\nPkg.instantiate()","category":"section"},{"location":"generated/getting-started/installation/#Troubleshooting","page":"Installation","title":"Troubleshooting","text":"","category":"section"},{"location":"generated/getting-started/installation/#Precompilation-Takes-Long","page":"Installation","title":"Precompilation Takes Long","text":"First-time precompilation can take several minutes due to dependencies. This is normal and only happens once.","category":"section"},{"location":"generated/getting-started/installation/#Missing-Dependencies","page":"Installation","title":"Missing Dependencies","text":"If you encounter missing dependency errors, try:\n\nusing Pkg\nPkg.instantiate()\nPkg.precompile()","category":"section"},{"location":"generated/getting-started/installation/#Version-Conflicts","page":"Installation","title":"Version Conflicts","text":"If you have version conflicts with other packages:\n\nusing Pkg\nPkg.update()\n\nOr create a fresh environment:\n\nusing Pkg\nPkg.activate(\"my_project\")\nPkg.add(\"Piccolo\")","category":"section"},{"location":"generated/getting-started/installation/#Next-Steps","page":"Installation","title":"Next Steps","text":"Once installed, continue to the Quickstart guide to run your first optimization.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"problem-templates/#problem-templates-overview","page":"Overview","title":"Problem Templates","text":"Problem templates are the primary user-facing API in Piccolo.jl. They provide high-level constructors that set up quantum optimal control problems with sensible defaults while allowing fine-grained customization.","category":"section"},{"location":"problem-templates/#Overview","page":"Overview","title":"Overview","text":"Piccolo.jl provides four main problem templates:\n\nTemplate Purpose Pulse Type\nSmoothPulseProblem Piecewise constant controls with smoothness regularization ZeroOrderPulse\nSplinePulseProblem Spline-based controls for smooth pulses LinearSplinePulse, CubicSplinePulse\nMinimumTimeProblem Time-optimal control (wraps another problem) Any\nSamplingProblem Robust optimization over parameter variations Any","category":"section"},{"location":"problem-templates/#Choosing-a-Template","page":"Overview","title":"Choosing a Template","text":"Use this decision flowchart to select the right template for your task:\n\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n        ‚îÇ  What pulse type?    ‚îÇ\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n           ‚ñº               ‚ñº\n    ZeroOrderPulse    SplinePulse\n           ‚îÇ               ‚îÇ\n           ‚ñº               ‚ñº\n  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n  ‚îÇ SmoothPulse     ‚îÇ ‚îÇ SplinePulse     ‚îÇ\n  ‚îÇ Problem         ‚îÇ ‚îÇ Problem         ‚îÇ\n  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                     ‚ñº\n           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n           ‚îÇ Need robustness? ‚îÇ\n           ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò\n            Yes‚îÇ          ‚îÇNo\n               ‚ñº          ‚îÇ\n       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n       ‚îÇ Sampling     ‚îÇ   ‚îÇ\n       ‚îÇ Problem      ‚îÇ   ‚îÇ\n       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                    ‚ñº\n           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n           ‚îÇ Minimize time? ‚îÇ\n           ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò\n            Yes‚îÇ        ‚îÇNo\n               ‚ñº        ‚îÇ\n       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\n       ‚îÇ MinimumTime  ‚îÇ ‚îÇ\n       ‚îÇ Problem      ‚îÇ ‚îÇ\n       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\n              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                   ‚ñº\n              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n              ‚îÇ Done!  ‚îÇ\n              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò","category":"section"},{"location":"problem-templates/#Quick-Decision-Guide","page":"Overview","title":"Quick Decision Guide","text":"Choose your base problem:\n\nSmoothPulseProblem: Start here for most problems. Uses piecewise constant pulses with derivative regularization for smoothness.\nSplinePulseProblem: Use when you need inherently smooth pulses or want to warm-start from a previous solution.\n\nAdd robustness (optional):\n\nSamplingProblem: Wrap your base problem to optimize over multiple system variants (e.g., different detuning values).\n\nMinimize time (optional):\n\nMinimumTimeProblem: Wrap any problem to find the shortest gate duration that achieves a target fidelity.","category":"section"},{"location":"problem-templates/#Composability","page":"Overview","title":"Composability","text":"Problem templates can be chained together:\n\n# Step 1: Create base problem with free time enabled\nqcp_base = SmoothPulseProblem(qtraj, N; Œît_bounds=(0.01, 0.5))\nsolve!(qcp_base; max_iter=100)\n\n# Step 2: Add robustness\nqcp_robust = SamplingProblem(qcp_base, [sys_nominal, sys_perturbed])\nsolve!(qcp_robust; max_iter=100)\n\n# Step 3: Minimize time while maintaining fidelity\nqcp_mintime = MinimumTimeProblem(qcp_robust; final_fidelity=0.99)\nsolve!(qcp_mintime; max_iter=100)","category":"section"},{"location":"problem-templates/#Common-Workflow","page":"Overview","title":"Common Workflow","text":"All problem templates follow the same workflow:\n\n# 1. Define quantum system\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\n\n# 2. Create initial pulse\npulse = ZeroOrderPulse(initial_controls, times)\n\n# 3. Create trajectory with goal\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# 4. Set up optimization problem\nqcp = SmoothPulseProblem(qtraj, N; Q=100.0, R=1e-2)\n\n# 5. Solve\nsolve!(qcp; max_iter=100)\n\n# 6. Analyze results\nprintln(\"Fidelity: \", fidelity(qcp))\noptimized_pulse = get_pulse(qcp.qtraj)","category":"section"},{"location":"problem-templates/#Key-Concepts","page":"Overview","title":"Key Concepts","text":"","category":"section"},{"location":"problem-templates/#Pulse-Type-Matching","page":"Overview","title":"Pulse Type Matching","text":"Each base problem template requires a specific pulse type:\n\nProblem Template Required Pulse Type\nSmoothPulseProblem ZeroOrderPulse\nSplinePulseProblem LinearSplinePulse or CubicSplinePulse\n\nUsing the wrong pulse type will result in a helpful error message.","category":"section"},{"location":"problem-templates/#Trajectory-Types","page":"Overview","title":"Trajectory Types","text":"Problem templates work with different trajectory types depending on your goal:\n\nTrajectory Type Use Case\nUnitaryTrajectory Gate synthesis (most common)\nKetTrajectory State transfer\nDensityTrajectory Open system evolution\nMultiKetTrajectory Multiple state transfers with coherent phases","category":"section"},{"location":"problem-templates/#Regularization-Parameters","page":"Overview","title":"Regularization Parameters","text":"Most problems use these regularization parameters:\n\nQ: Weight on infidelity objective (higher = prioritize fidelity)\nR: Base regularization weight for control smoothness\nR_u, R_du, R_ddu: Per-derivative regularization weights","category":"section"},{"location":"problem-templates/#Free-Time-Optimization","page":"Overview","title":"Free-Time Optimization","text":"To enable time optimization with MinimumTimeProblem, set Œît_bounds in your base problem:\n\nqcp = SmoothPulseProblem(qtraj, N; Œît_bounds=(0.01, 0.5))","category":"section"},{"location":"problem-templates/#Detailed-Documentation","page":"Overview","title":"Detailed Documentation","text":"SmoothPulseProblem - Full parameter reference and examples\nSplinePulseProblem - Spline-based optimization\nMinimumTimeProblem - Time-optimal control\nSamplingProblem - Robust optimization\nComposing Templates - Advanced composition patterns","category":"section"},{"location":"generated/concepts/systems/#quantum-systems","page":"Quantum Systems","title":"Quantum Systems","text":"Quantum systems in Piccolo.jl represent the physical hardware you're controlling. They encapsulate the Hamiltonian structure and control bounds.","category":"section"},{"location":"generated/concepts/systems/#The-Hamiltonian-Model","page":"Quantum Systems","title":"The Hamiltonian Model","text":"Piccolo.jl uses the standard quantum control Hamiltonian:\n\nH(u t) = H_textdrift + sum_i=1^n u_i(t) H_textdrivei\n\nWhere:\n\nH_drift: The always-on system Hamiltonian (e.g., qubit frequencies, couplings)\nH_drive,i: The i-th controllable interaction (e.g., microwave drives)\nu_i(t): The control amplitude for drive i at time t","category":"section"},{"location":"generated/concepts/systems/#QuantumSystem","page":"Quantum Systems","title":"QuantumSystem","text":"QuantumSystem is the primary type for closed quantum systems.","category":"section"},{"location":"generated/concepts/systems/#Matrix-Based-Construction","page":"Quantum Systems","title":"Matrix-Based Construction","text":"The most common way to create a system:\n\nusing Piccolo\n\n# Single qubit with X and Y drives\nH_drift = PAULIS[:Z]                    # œâq/2 œÉz\nH_drives = [PAULIS[:X], PAULIS[:Y]]     # Controllable terms\ndrive_bounds = [1.0, 1.0]               # Maximum amplitude for each drive\n\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)","category":"section"},{"location":"generated/concepts/systems/#Constructor-Variants","page":"Quantum Systems","title":"Constructor Variants","text":"# Full specification\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\n\n# No drift (pure control)\nsys = QuantumSystem(H_drives, drive_bounds)\n\n# No drives (free evolution)\nsys = QuantumSystem(H_drift)","category":"section"},{"location":"generated/concepts/systems/#Drive-Bounds","page":"Quantum Systems","title":"Drive Bounds","text":"Drive bounds specify the maximum control amplitude for each drive channel:\n\n# Vector: per-drive bounds\nsys_vector = QuantumSystem(H_drift, H_drives, [0.5, 1.0])","category":"section"},{"location":"generated/concepts/systems/#Accessing-System-Properties","page":"Quantum Systems","title":"Accessing System Properties","text":"# Number of energy levels\nsys.levels\n\n# Number of control drives\nsys.n_drives\n\n# Get Hamiltonian components\nH_d = get_drift(sys)\nH_dr = get_drives(sys)\nH_d","category":"section"},{"location":"generated/concepts/systems/#OpenQuantumSystem","page":"Quantum Systems","title":"OpenQuantumSystem","text":"For systems with dissipation, use OpenQuantumSystem:\n\n# Collapse operators (Lindblad form)\nc_ops = [\n    sqrt(Œ≥1) * annihilate(levels),  # Energy relaxation (T1)\n    sqrt(Œ≥2) * PAULIS[:Z]           # Pure dephasing (T2)\n]\n\nopen_sys = OpenQuantumSystem(H_drift, H_drives, drive_bounds, c_ops)\n\nThe dynamics follow the Lindblad master equation:\n\ndotrho = -iH rho + sum_k left( L_k rho L_k^dagger - frac12L_k^dagger L_k rho right)","category":"section"},{"location":"generated/concepts/systems/#CompositeQuantumSystem","page":"Quantum Systems","title":"CompositeQuantumSystem","text":"For multi-qubit or multi-subsystem setups:\n\nsys1 = QuantumSystem(H1_drift, H1_drives, bounds1)\nsys2 = QuantumSystem(H2_drift, H2_drives, bounds2)\nH_coupling = J * kron(PAULIS[:Z], PAULIS[:Z])\n\ncomposite_sys = CompositeQuantumSystem([sys1, sys2], H_coupling)","category":"section"},{"location":"generated/concepts/systems/#Common-Gates-and-Operators","page":"Quantum Systems","title":"Common Gates and Operators","text":"Piccolo.jl provides standard quantum operators:","category":"section"},{"location":"generated/concepts/systems/#Pauli-Matrices","page":"Quantum Systems","title":"Pauli Matrices","text":"PAULIS[:I]  ## Identity\n\nPAULIS[:X]  ## Pauli-X (NOT)\n\nPAULIS[:Y]  ## Pauli-Y\n\nPAULIS[:Z]  ## Pauli-Z","category":"section"},{"location":"generated/concepts/systems/#Common-Gates","page":"Quantum Systems","title":"Common Gates","text":"(:I, :X, :Y, :Z, :H, :T, :S, :CX, :CZ)","category":"section"},{"location":"generated/concepts/systems/#Creation/Annihilation-Operators","page":"Quantum Systems","title":"Creation/Annihilation Operators","text":"levels = 5\na = annihilate(levels)\na_dag = create(levels)\nn_op = a_dag * a  # Number operator\n\nNumber operator (5 levels):\n\nn_op","category":"section"},{"location":"generated/concepts/systems/#System-Templates","page":"Quantum Systems","title":"System Templates","text":"Piccolo.jl provides pre-built templates for common physical systems:","category":"section"},{"location":"generated/concepts/systems/#Transmon-Qubits","page":"Quantum Systems","title":"Transmon Qubits","text":"sys_transmon = TransmonSystem(levels = 3, Œ¥ = 0.2, drive_bounds = [0.2, 0.2])\nsys_transmon.levels, sys_transmon.n_drives","category":"section"},{"location":"generated/concepts/systems/#Other-Templates","page":"Quantum Systems","title":"Other Templates","text":"# Trapped ions\n\n````@example systems\nsys = IonChainSystem(N_ions = 2, œâq = 1.0, Œ∑ = 0.1)\n````\n\n# Rydberg atoms\n\n````@example systems\nsys = RydbergChainSystem(N = 3, drive_bounds = [1.0])\n````\n\n\nSee System Templates in the How-To Guides for detailed usage.","category":"section"},{"location":"generated/concepts/systems/#Best-Practices","page":"Quantum Systems","title":"Best Practices","text":"","category":"section"},{"location":"generated/concepts/systems/#1.-Check-Hermiticity","page":"Quantum Systems","title":"1. Check Hermiticity","text":"Hamiltonians should be Hermitian. Piccolo.jl validates this:\n\n# This will warn if H is not Hermitian\nsys = QuantumSystem(H_drift, H_drives, bounds)","category":"section"},{"location":"generated/concepts/systems/#2.-Normalize-Units","page":"Quantum Systems","title":"2. Normalize Units","text":"Use consistent units throughout. A common choice:\n\nEnergy/frequency: GHz (or 2œÄ √ó GHz)\nTime: nanoseconds\nControl amplitudes: GHz","category":"section"},{"location":"generated/concepts/systems/#3.-Include-All-Relevant-Levels","page":"Quantum Systems","title":"3. Include All Relevant Levels","text":"For transmon qubits, include at least one level above the computational subspace to capture leakage:\n\n# Good: 3 levels for qubit (captures leakage to |2‚ü©)\nsys_3level = TransmonSystem(levels = 3, Œ¥ = 0.2)\nsys_3level.levels\n\n# Better for high-fidelity: 4+ levels\nsys_4level = TransmonSystem(levels = 4, Œ¥ = 0.2)\nsys_4level.levels","category":"section"},{"location":"generated/concepts/systems/#See-Also","page":"Quantum Systems","title":"See Also","text":"Trajectories - Combining systems with pulses and goals\nProblem Templates - Setting up optimization problems\nSystem Templates - Pre-built physical system models\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"development/contributing/#Contributing","page":"Contributing","title":"Contributing","text":"We welcome contributions to Piccolo.jl! This document outlines the guidelines for contributing to the project. If you know what you want to see but are unsure of the best way to achieve it, open an issue and start a discussion with the community.","category":"section"},{"location":"development/contributing/#Development-Setup","page":"Contributing","title":"Development Setup","text":"","category":"section"},{"location":"development/contributing/#Install-Julia","page":"Contributing","title":"Install Julia","text":"Juliaup is an installer and version manager for Julia. After installing, run julia to obtain the Julia REPL.","category":"section"},{"location":"development/contributing/#Julia-Environments","page":"Contributing","title":"Julia Environments","text":"Your project's environment is stored in Project.toml. You can interactively manage packages using the Julia REPL and package manager:\n\nStart Julia in the project folder\nType ] to enter the package manager\nType activate . to activate the environment\nRun instantiate to install dependencies","category":"section"},{"location":"development/contributing/#Development-Installation","page":"Contributing","title":"Development Installation","text":"For development, clone the repository and use dev mode:\n\nusing Pkg\nPkg.dev(\"path/to/Piccolo.jl\")","category":"section"},{"location":"development/contributing/#Using-Revise","page":"Contributing","title":"Using Revise","text":"Revise.jl automatically reloads code changes during development:\n\nusing Revise\nusing Piccolo\n\nLoad Revise before any packages you intend to edit.","category":"section"},{"location":"development/contributing/#Tips-for-Visual-Studio-Code","page":"Contributing","title":"Tips for Visual Studio Code","text":"","category":"section"},{"location":"development/contributing/#Julia-Extension","page":"Contributing","title":"Julia Extension","text":"The Julia extension provides excellent Julia support including notebooks, REPL integration, and debugging.","category":"section"},{"location":"development/contributing/#Fonts","page":"Contributing","title":"Fonts","text":"VS Code may not display all Julia characters correctly. Change the editor font family to 'JuliaMono' for full Unicode support. You can create a VS Code settings profile for Julia at File > Preferences > Profile.","category":"section"},{"location":"development/contributing/#Tests","page":"Contributing","title":"Tests","text":"Tests automatically populate in VS Code when working with Piccolo packages. Click the Testing sidebar icon to see and run tests. Sometimes you may need to restart the Julia kernel to see changes reflected in tests.","category":"section"},{"location":"development/contributing/#Writing-Tests","page":"Contributing","title":"Writing Tests","text":"Tests are implemented using TestItems.jl:\n\n@testitem \"X gate synthesis\" begin\n    H_drift = PAULIS[:Z]\n    H_drives = [PAULIS[:X], PAULIS[:Y]]\n    sys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\n    T, N = 10.0, 100\n    times = collect(range(0, T, length=N))\n    pulse = ZeroOrderPulse(0.1 * randn(2, N), times)\n    qtraj = UnitaryTrajectory(sys, pulse, GATES[:X])\n\n    qcp = SmoothPulseProblem(qtraj, N)\n    solve!(qcp; max_iter=100)\n\n    @test fidelity(qcp) > 0.99\nend\n\nTests should be included in the same file as the code they test. Individual tests populate in the Testing panel in VS Code and are run in CI on each PR.","category":"section"},{"location":"development/contributing/#Building-Documentation","page":"Contributing","title":"Building Documentation","text":"Documentation is built using Documenter.jl with Literate.jl for executable examples.","category":"section"},{"location":"development/contributing/#Build-Locally","page":"Contributing","title":"Build Locally","text":"julia --project=docs docs/make.jl","category":"section"},{"location":"development/contributing/#Live-Development-Server","page":"Contributing","title":"Live Development Server","text":"For interactive documentation development:\n\njulia --project=docs\n\nusing Revise, LiveServer, Piccolo\nservedocs(\n    literate_dir=\"docs/literate\",\n    skip_dirs=[\"docs/src/generated\"],\n    skip_files=[\"docs/src/index.md\"]\n)\n\nChanges to documentation files are automatically reflected. To see source code changes (e.g., docstrings), restart the live server.","category":"section"},{"location":"development/contributing/#Reporting-Issues","page":"Contributing","title":"Reporting Issues","text":"Use the GitHub issue templates for bug reports and feature requests.","category":"section"},{"location":"reference/#API-Reference","page":"Overview","title":"API Reference","text":"This section provides complete documentation of all public types and functions in Piccolo.jl.","category":"section"},{"location":"reference/#Module-Organization","page":"Overview","title":"Module Organization","text":"Piccolo.jl is organized into three main modules:\n\nModule Contents\nQuantum Systems, trajectories, pulses, operators, isomorphisms\nControl Problems, objectives, constraints, integrators, templates\nVisualizations Plotting and animation utilities\n\nSee the Library Reference page for full docstrings of all exported types and functions.","category":"section"},{"location":"reference/#Reexported-Packages","page":"Overview","title":"Reexported Packages","text":"Piccolo.jl reexports several foundation packages. Their functionality is available when you using Piccolo:\n\nPackage Purpose Key Types/Functions\nDirectTrajOpt Trajectory optimization solve!, add_objective!, add_constraint!\nNamedTrajectories Trajectory containers NamedTrajectory, get_timesteps, plot\nTrajectoryIndexingUtils Indexing utilities Trajectory slicing and indexing","category":"section"},{"location":"reference/#Quick-Reference","page":"Overview","title":"Quick Reference","text":"","category":"section"},{"location":"reference/#Creating-Systems","page":"Overview","title":"Creating Systems","text":"# Basic system\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\n\n# From templates\nsys = TransmonSystem(levels=3, Œ¥=0.2, drive_bounds=[0.2, 0.2])","category":"section"},{"location":"reference/#Creating-Trajectories","page":"Overview","title":"Creating Trajectories","text":"# Unitary gate synthesis\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)\n\n# State preparation\nqtraj = KetTrajectory(sys, pulse, œà_init, œà_goal)","category":"section"},{"location":"reference/#Creating-Problems","page":"Overview","title":"Creating Problems","text":"# Smooth pulse optimization\nqcp = SmoothPulseProblem(qtraj, N; Q=100.0)\n\n# Time-optimal control\nqcp_mintime = MinimumTimeProblem(qcp; final_fidelity=0.99)\n\n# Robust optimization\nqcp_robust = SamplingProblem(qcp, systems)","category":"section"},{"location":"reference/#Solving-and-Analysis","page":"Overview","title":"Solving and Analysis","text":"# Solve\nsolve!(qcp; max_iter=100)\n\n# Analyze\nfid = fidelity(qcp)\ntraj = get_trajectory(qcp)","category":"section"},{"location":"development/release-notes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"section"},{"location":"development/release-notes/#[v1.0.0]-Upcoming","page":"Release Notes","title":"[v1.0.0] - Upcoming","text":"","category":"section"},{"location":"development/release-notes/#Changed","page":"Release Notes","title":"Changed","text":"Complete documentation overhaul with concept-driven organization\nMigrated from PiccoloDocsTemplate to standard Documenter.jl","category":"section"},{"location":"development/release-notes/#[v0.3.1]-2024-10-17","page":"Release Notes","title":"[v0.3.1] - 2024-10-17","text":"","category":"section"},{"location":"development/release-notes/#Fixed","page":"Release Notes","title":"Fixed","text":"Fixed and added tests to RydbergChainSystem","category":"section"},{"location":"development/release-notes/#[v0.3.0]-2024-10-10","page":"Release Notes","title":"[v0.3.0] - 2024-10-10","text":"","category":"section"},{"location":"development/release-notes/#Added","page":"Release Notes","title":"Added","text":"PiccoloOptions to handle custom problem settings","category":"section"},{"location":"development/release-notes/#Changed-2","page":"Release Notes","title":"Changed","text":"Refactored trajectory initialization functions\nImproved documentation\nTypo fixes","category":"section"},{"location":"development/release-notes/#[v0.2.0]-2024-02-22","page":"Release Notes","title":"[v0.2.0] - 2024-02-22","text":"","category":"section"},{"location":"development/release-notes/#Added-2","page":"Release Notes","title":"Added","text":"EmbeddedOperator to handle subspace gate optimization and leakage suppression\nPlotting methods for unitary populations","category":"section"},{"location":"development/release-notes/#Changed-3","page":"Release Notes","title":"Changed","text":"New quantum systems interface\nTransmon system template\nRestructured the code base for easier quantum system and problem template development","category":"section"},{"location":"development/release-notes/#Removed","page":"Release Notes","title":"Removed","text":"Stale examples","category":"section"},{"location":"development/release-notes/#Fixed-2","page":"Release Notes","title":"Fixed","text":"Robustness improvements objective test fixes","category":"section"},{"location":"generated/problem-templates/minimum_time/#minimum-time","page":"MinimumTimeProblem","title":"MinimumTimeProblem","text":"MinimumTimeProblem converts an existing optimization problem into a time-optimal control problem. It minimizes the total gate duration while maintaining a minimum fidelity constraint.","category":"section"},{"location":"generated/problem-templates/minimum_time/#When-to-Use","page":"MinimumTimeProblem","title":"When to Use","text":"Use MinimumTimeProblem when:\n\nYou have a working solution and want to minimize its duration\nYou need the fastest possible gate that achieves a target fidelity\nYou're exploring the fidelity-time trade-off","category":"section"},{"location":"generated/problem-templates/minimum_time/#Key-Design:-Composition-Pattern","page":"MinimumTimeProblem","title":"Key Design: Composition Pattern","text":"MinimumTimeProblem wraps an existing QuantumControlProblem. It does not create a problem directly from a trajectory:\n\n# This does NOT work\nqcp_mintime = MinimumTimeProblem(qtraj, N)  # Error!\n\n# This works\nqcp_base = SmoothPulseProblem(qtraj, N; Œît_bounds=(0.01, 0.5))\nsolve!(qcp_base)\nqcp_mintime = MinimumTimeProblem(qcp_base; final_fidelity=0.99)","category":"section"},{"location":"generated/problem-templates/minimum_time/#Prerequisites","page":"MinimumTimeProblem","title":"Prerequisites","text":"The base problem must have Œît_bounds set to enable variable timesteps:\n\n# Enable free-time optimization in the base problem\nqcp_base = SmoothPulseProblem(qtraj, N; Œît_bounds=(0.01, 0.5))","category":"section"},{"location":"generated/problem-templates/minimum_time/#Constructor","page":"MinimumTimeProblem","title":"Constructor","text":"MinimumTimeProblem(\n    qcp::QuantumControlProblem;\n    goal = nothing,\n    final_fidelity = 0.99,\n    D = 100.0,\n    piccolo_options = PiccoloOptions()\n)","category":"section"},{"location":"generated/problem-templates/minimum_time/#Parameter-Reference","page":"MinimumTimeProblem","title":"Parameter Reference","text":"Parameter Type Default Description\nqcp QuantumControlProblem required Base problem to convert (must have Œît_bounds)\ngoal AbstractPiccoloOperator or AbstractVector nothing Optional new goal (uses base problem's goal if nothing)\nfinal_fidelity Float64 0.99 Minimum fidelity constraint\nD Float64 100.0 Weight on total time objective\npiccolo_options PiccoloOptions PiccoloOptions() Solver options","category":"section"},{"location":"generated/problem-templates/minimum_time/#Optimization-Problem","page":"MinimumTimeProblem","title":"Optimization Problem","text":"MinimumTimeProblem sets up:\n\nminimize:    J_original + D √ó Œ£ Œît‚Çñ\nsubject to:  Original dynamics and constraints\n             F_final ‚â• final_fidelity\n             Œît_min ‚â§ Œît‚Çñ ‚â§ Œît_max\n\nThe parameter D controls the trade-off between the original objective and time minimization. Higher D values prioritize shorter duration.","category":"section"},{"location":"generated/problem-templates/minimum_time/#Examples","page":"MinimumTimeProblem","title":"Examples","text":"","category":"section"},{"location":"generated/problem-templates/minimum_time/#Basic-Time-Optimal-Gate","page":"MinimumTimeProblem","title":"Basic Time-Optimal Gate","text":"using Piccolo\nusing Printf # hide\n\n# Setup\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsys = QuantumSystem(H_drift, H_drives, [1.0, 1.0])\n\nT, N = 20.0, 100\ntimes = collect(range(0, T, length = N))\npulse = ZeroOrderPulse(0.1 * randn(2, N), times)\nqtraj = UnitaryTrajectory(sys, pulse, GATES[:X])\n\n# Step 1: Solve base problem with free time enabled\nqcp_base = SmoothPulseProblem(qtraj, N; Q = 100.0, Œît_bounds = (0.05, 0.5))\ncached_solve!(qcp_base, \"mintime_base\"; max_iter = 100)\n\nsum(get_timesteps(get_trajectory(qcp_base)))\n\nfidelity(qcp_base)","category":"section"},{"location":"generated/problem-templates/minimum_time/#Step-2:-Minimize-Time","page":"MinimumTimeProblem","title":"Step 2: Minimize Time","text":"qcp_mintime = MinimumTimeProblem(qcp_base; final_fidelity = 0.99, D = 100.0)\ncached_solve!(qcp_mintime, \"mintime_optimal\"; max_iter = 100)\n\nsum(get_timesteps(get_trajectory(qcp_mintime)))\n\nfidelity(qcp_mintime)","category":"section"},{"location":"generated/problem-templates/minimum_time/#Exploring-Fidelity-Time-Trade-off","page":"MinimumTimeProblem","title":"Exploring Fidelity-Time Trade-off","text":"results = []\nfor target_fidelity in [0.999, 0.99, 0.95, 0.90]\n    qcp_mt = MinimumTimeProblem(qcp_base; final_fidelity = target_fidelity)\n    cached_solve!(\n        qcp_mt,\n        \"mintime_tradeoff_$(target_fidelity)\";\n        max_iter = 100,\n        verbose = false,\n        print_level = 1,\n    )\n    dur = sum(get_timesteps(get_trajectory(qcp_mt)))\n    push!(results, (target = target_fidelity, duration = dur, achieved = fidelity(qcp_mt)))\nend\n\nprintln(\"Fidelity-Time Trade-off\")\nprintln(\"‚îÄ\" ^ 50)\nfor r in results\n    @printf(\n        \"  Target: %.3f  ‚îÇ  Duration: %.3f  ‚îÇ  Achieved: %.4f\\n\",\n        r.target,\n        r.duration,\n        r.achieved\n    )\nend","category":"section"},{"location":"generated/problem-templates/minimum_time/#With-Robust-Optimization","page":"MinimumTimeProblem","title":"With Robust Optimization","text":"Chain with SamplingProblem for robust time-optimal control:\n\n# Base problem\nqcp_base = SmoothPulseProblem(qtraj, N; Q=100.0, Œît_bounds=(0.05, 0.5))\nsolve!(qcp_base; max_iter=100)\n\n# Add robustness\nsys_perturbed = QuantumSystem(1.1 * H_drift, H_drives, [1.0, 1.0])\nqcp_robust = SamplingProblem(qcp_base, [sys, sys_perturbed])\nsolve!(qcp_robust; max_iter=100)\n\n# Minimize time while maintaining robustness\nqcp_mintime = MinimumTimeProblem(qcp_robust; final_fidelity=0.95)\nsolve!(qcp_mintime; max_iter=100)","category":"section"},{"location":"generated/problem-templates/minimum_time/#Fidelity-Constraints-by-Trajectory-Type","page":"MinimumTimeProblem","title":"Fidelity Constraints by Trajectory Type","text":"MinimumTimeProblem automatically adds the appropriate fidelity constraint based on the trajectory type:\n\nTrajectory Type Constraint Type\nUnitaryTrajectory FinalUnitaryFidelityConstraint\nKetTrajectory FinalKetFidelityConstraint\nMultiKetTrajectory FinalCoherentKetFidelityConstraint\nDensityTrajectory Not yet implemented","category":"section"},{"location":"generated/problem-templates/minimum_time/#Tips","page":"MinimumTimeProblem","title":"Tips","text":"","category":"section"},{"location":"generated/problem-templates/minimum_time/#Setting-D","page":"MinimumTimeProblem","title":"Setting D","text":"The D parameter controls the weight on total time:\n\nHigher D (e.g., 1000): Aggressively minimize time, may sacrifice fidelity margin\nLower D (e.g., 10): More conservative, maintains fidelity buffer","category":"section"},{"location":"generated/problem-templates/minimum_time/#Initial-Solution-Quality","page":"MinimumTimeProblem","title":"Initial Solution Quality","text":"MinimumTimeProblem works best when starting from a good solution. If your base problem has low fidelity, solve it first:\n\n# Ensure good initial solution\nqcp_base = SmoothPulseProblem(qtraj, N; Q=1000.0, Œît_bounds=(0.05, 0.5))\nsolve!(qcp_base; max_iter=200)\n\n# Only then minimize time\nif fidelity(qcp_base) > 0.99\n    qcp_mintime = MinimumTimeProblem(qcp_base; final_fidelity=0.99)\n    solve!(qcp_mintime; max_iter=100)\nend","category":"section"},{"location":"generated/problem-templates/minimum_time/#Changing-the-Goal","page":"MinimumTimeProblem","title":"Changing the Goal","text":"You can optimize for a different goal without recreating the base problem:\n\nqcp_y = MinimumTimeProblem(qcp_base; goal = GATES[:Y], final_fidelity = 0.99)\ncached_solve!(qcp_y, \"mintime_y_gate\"; max_iter = 100)","category":"section"},{"location":"generated/problem-templates/minimum_time/#See-Also","page":"MinimumTimeProblem","title":"See Also","text":"SmoothPulseProblem - Base problem for piecewise constant controls\nSplinePulseProblem - Base problem for spline controls\nSamplingProblem - Add robustness before minimizing time\nComposing Templates - Advanced composition patterns\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/first_gate/#first-gate-tutorial","page":"Your First Gate","title":"Your First Gate","text":"This tutorial walks through synthesizing your first quantum gate with Piccolo.jl. We'll implement an X gate (NOT gate) on a single qubit.","category":"section"},{"location":"generated/first_gate/#What-We're-Doing","page":"Your First Gate","title":"What We're Doing","text":"We want to find control pulses that implement:\n\nX = beginpmatrix 0  1  1  0 endpmatrix\n\nOur qubit has Hamiltonian:\n\nH(t) = fracomega2sigma_z + u_x(t)sigma_x + u_y(t)sigma_y\n\nThe optimizer will find u_x(t) and u_y(t) that produce the X gate.","category":"section"},{"location":"generated/first_gate/#Setup","page":"Your First Gate","title":"Setup","text":"First, load the required packages:\n\nusing Piccolo\nusing CairoMakie\nusing Random\nRandom.seed!(42)  # For reproducibility","category":"section"},{"location":"generated/first_gate/#Step-1:-Define-the-Quantum-System","page":"Your First Gate","title":"Step 1: Define the Quantum System","text":"A QuantumSystem needs:\n\nDrift Hamiltonian: Always-on terms (qubit frequency)\nDrive Hamiltonians: Controllable interactions\nDrive bounds: Maximum control amplitudes\n\n# The drift Hamiltonian: œâ/2 œÉ_z (qubit frequency)\n# We set œâ = 1.0 for simplicity\nH_drift = 0.5 * PAULIS[:Z]\n\n# The drive Hamiltonians: œÉ_x and œÉ_y controls\nH_drives = [PAULIS[:X], PAULIS[:Y]]\n\n# Maximum amplitude for each drive (in same units as H_drift)\ndrive_bounds = [1.0, 1.0]\n\n# Create the system\nsys = QuantumSystem(H_drift, H_drives, drive_bounds)\n\nLet's check what we created:\n\nsys.levels, sys.n_drives","category":"section"},{"location":"generated/first_gate/#Step-2:-Create-an-Initial-Pulse","page":"Your First Gate","title":"Step 2: Create an Initial Pulse","text":"We need an initial guess for the control pulse. ZeroOrderPulse represents piecewise constant controls - the standard choice for most problems.\n\n# Gate duration and discretization\nT = 10.0   # Total time (in units where œâ = 1)\nN = 100    # Number of timesteps\n\n# Time vector\ntimes = collect(range(0, T, length = N))\n\n# Random initial controls (small amplitude)\n# Shape: (n_drives, N) = (2, 100)\ninitial_controls = 0.1 * randn(2, N)\n\n# Create the pulse\npulse = ZeroOrderPulse(initial_controls, times)\n\nCheck the pulse:\n\nduration(pulse)\n\nn_drives(pulse)\n\npulse(5.0)","category":"section"},{"location":"generated/first_gate/#Step-3:-Define-the-Goal","page":"Your First Gate","title":"Step 3: Define the Goal","text":"A UnitaryTrajectory combines the system, pulse, and target gate.\n\n# Our target: the X gate\nU_goal = GATES[:X]\n\nU_goal\n\n# Create the trajectory\nqtraj = UnitaryTrajectory(sys, pulse, U_goal)","category":"section"},{"location":"generated/first_gate/#Step-4:-Set-Up-the-Optimization-Problem","page":"Your First Gate","title":"Step 4: Set Up the Optimization Problem","text":"SmoothPulseProblem creates an optimization problem with:\n\nFidelity objective (weight Q)\nControl regularization (weight R)\nSmoothness via derivative bounds\n\nqcp = SmoothPulseProblem(\n    qtraj,\n    N;\n    Q = 100.0,       # Fidelity weight (higher = prioritize fidelity)\n    R = 1e-2,        # Regularization weight (higher = smoother controls)\n    ddu_bound = 1.0,  # Limit on control acceleration\n)","category":"section"},{"location":"generated/first_gate/#Step-5:-Solve!","page":"Your First Gate","title":"Step 5: Solve!","text":"The solve! function runs the optimizer:\n\ncached_solve!(qcp, \"first_gate\"; max_iter = 20, verbose = false, print_level = 1)","category":"section"},{"location":"generated/first_gate/#Step-6:-Analyze-the-Results","page":"Your First Gate","title":"Step 6: Analyze the Results","text":"First, check the fidelity:\n\nfidelity(qcp)\n\nGet the optimized trajectory:\n\ntraj = get_trajectory(qcp)\n\n# Check the final unitary\nU_final = iso_vec_to_operator(traj[:≈®‚Éó][:, end])\nround.(U_final, digits = 3)","category":"section"},{"location":"generated/first_gate/#Step-7:-Visualize","page":"Your First Gate","title":"Step 7: Visualize","text":"Plot the optimized control pulses:\n\nfig = Figure(size = (800, 400))\n\n# Time axis\nplot_times = cumsum([0; get_timesteps(traj)])[1:(end-1)]\n\n# Control pulses\nax1 = Axis(\n    fig[1, 1],\n    xlabel = \"Time\",\n    ylabel = \"Control Amplitude\",\n    title = \"Optimized Controls\",\n)\nlines!(ax1, plot_times, traj[:u][1, :], label = \"u_x (œÉ_x drive)\", linewidth = 2)\nlines!(ax1, plot_times, traj[:u][2, :], label = \"u_y (œÉ_y drive)\", linewidth = 2)\naxislegend(ax1, position = :rt)\n\nfig","category":"section"},{"location":"generated/first_gate/#Understanding-the-Solution","page":"Your First Gate","title":"Understanding the Solution","text":"The optimizer found control pulses that:\n\nStart and end smoothly (due to derivative regularization)\nStay within bounds (due to drive_bounds)\nAchieve high fidelity (due to the Q-weighted objective)\n\nThe X gate rotates the qubit state around the X-axis by œÄ radians. You can see the controls create the right rotation!","category":"section"},{"location":"generated/first_gate/#What's-Next?","page":"Your First Gate","title":"What's Next?","text":"Now that you've synthesized your first gate, try:\n\nDifferent gates: Change U_goal to GATES[:H] (Hadamard) or GATES[:T]\nFaster gates: Reduce T and see how fidelity changes\nSmoother pulses: Increase R or decrease ddu_bound\nTime-optimal: Add Œît_bounds and use MinimumTimeProblem\n\nContinue to the State Transfer tutorial to learn about preparing specific quantum states.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
